{"version":3,"names":[],"mappings":"","sources":["dist/fairygui.js"],"sourcesContent":["var fgui;\n(function (fgui) {\n    class ControllerAction {\n        constructor() {\n        }\n        run(controller, prevPage, curPage) {\n            if ((!this.fromPage || this.fromPage.length == 0 || this.fromPage.indexOf(prevPage) != -1)\n                && (!this.toPage || this.toPage.length == 0 || this.toPage.indexOf(curPage) != -1))\n                this.enter(controller);\n            else\n                this.leave(controller);\n        }\n        enter(controller) {\n        }\n        leave(controller) {\n        }\n        setup(buffer) {\n            var cnt;\n            var i;\n            cnt = buffer.readShort();\n            this.fromPage = [];\n            for (i = 0; i < cnt; i++)\n                this.fromPage[i] = buffer.readS();\n            cnt = buffer.readShort();\n            this.toPage = [];\n            for (i = 0; i < cnt; i++)\n                this.toPage[i] = buffer.readS();\n        }\n    }\n    fgui.ControllerAction = ControllerAction;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class ChangePageAction extends fgui.ControllerAction {\n        constructor() {\n            super();\n        }\n        enter(controller) {\n            if (!this.controllerName)\n                return;\n            var gcom;\n            if (this.objectId)\n                gcom = controller.parent.getChildById(this.objectId);\n            else\n                gcom = controller.parent;\n            if (gcom) {\n                var cc = gcom.getController(this.controllerName);\n                if (cc && cc != controller && !cc.changing) {\n                    if (this.targetPage == \"~1\") {\n                        if (controller.selectedIndex < cc.pageCount)\n                            cc.selectedIndex = controller.selectedIndex;\n                    }\n                    else if (this.targetPage == \"~2\")\n                        cc.selectedPage = controller.selectedPage;\n                    else\n                        cc.selectedPageId = this.targetPage;\n                }\n            }\n        }\n        setup(buffer) {\n            super.setup(buffer);\n            this.objectId = buffer.readS();\n            this.controllerName = buffer.readS();\n            this.targetPage = buffer.readS();\n        }\n    }\n    fgui.ChangePageAction = ChangePageAction;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class PlayTransitionAction extends fgui.ControllerAction {\n        constructor() {\n            super();\n            this.playTimes = 1;\n            this.delay = 0;\n        }\n        enter(controller) {\n            var trans = controller.parent.getTransition(this.transitionName);\n            if (trans) {\n                if (this._currentTransition && this._currentTransition.playing)\n                    trans.changePlayTimes(this.playTimes);\n                else\n                    trans.play(null, this.playTimes, this.delay);\n                this._currentTransition = trans;\n            }\n        }\n        leave(controller) {\n            if (this.stopOnExit && this._currentTransition) {\n                this._currentTransition.stop();\n                this._currentTransition = null;\n            }\n        }\n        setup(buffer) {\n            super.setup(buffer);\n            this.transitionName = buffer.readS();\n            this.playTimes = buffer.readInt();\n            this.delay = buffer.readFloat();\n            this.stopOnExit = buffer.readBool();\n        }\n    }\n    fgui.PlayTransitionAction = PlayTransitionAction;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    fgui.Decls = {};\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class EventDispatcher {\n        constructor() {\n            this._listeners = {};\n        }\n        on(type, callback, target, capture) {\n            let col = this._listeners[type];\n            if (!col) {\n                col = { dispatching: 0, callbacks: [], captures: [] };\n                this._listeners[type] = col;\n            }\n            let arr = capture ? col.captures : col.callbacks;\n            let index = arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target);\n            if (index != -1)\n                arr[index + 2] = false;\n            else\n                arr.push(callback, target, false);\n        }\n        off(type, callback, target, capture) {\n            let col = this._listeners[type];\n            if (!col)\n                return;\n            let arr = capture ? col.captures : col.callbacks;\n            let index = arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target);\n            if (index != -1) {\n                if (col.dispatching != 0) {\n                    arr[index + 2] = true;\n                    col.dispatching = 2;\n                }\n                else\n                    arr.splice(index, 3);\n            }\n        }\n        offAll(type) {\n            if (type) {\n                let col = this._listeners[type];\n                if (col) {\n                    if (col.dispatching != 0) {\n                        col.callbacks.forEach((value, index, arr) => arr[index + 2] = true);\n                        col.captures.forEach((value, index, arr) => arr[index + 2] = true);\n                        col.dispatching = 2;\n                    }\n                    else {\n                        col.callbacks.length = 0;\n                        col.captures.length = 0;\n                    }\n                }\n            }\n            else {\n                for (var key in this._listeners) {\n                    delete this._listeners[key];\n                }\n            }\n        }\n        hasListener(type, callback, target, capture) {\n            let col = this._listeners[type];\n            if (!col)\n                return false;\n            let arr = capture ? col.captures : col.callbacks;\n            if (!callback)\n                return arr.length > 0;\n            else\n                arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target) != -1;\n        }\n        dispatchEvent(type, data) {\n            let col = this._listeners[type];\n            if (!col || col.callbacks.length == 0 && col.captures.length == 0)\n                return;\n            let ev = fgui.EventPool.borrow(type);\n            ev._type = type;\n            ev.data = data;\n            this._dispatch(col, ev, true);\n            this._dispatch(col, ev, false);\n            fgui.EventPool.returns(ev);\n            return ev._defaultPrevented;\n        }\n        _dispatch(col, ev, capture) {\n            if (col.dispatching != 0)\n                return;\n            col.dispatching = 1;\n            ev._sender = this;\n            let arr = capture ? col.captures : col.callbacks;\n            let cnt = arr.length;\n            for (let i = 0; i < cnt; i += 3) {\n                arr[i].call(arr[i + 1], ev);\n            }\n            if (col.dispatching == 2) {\n                let cnt = arr.length;\n                let i = 0;\n                while (i < cnt) {\n                    if (arr[i + 2]) {\n                        arr.splice(i, 3);\n                        cnt -= 3;\n                        continue;\n                    }\n                    else\n                        i += 3;\n                }\n            }\n            col.dispatching = 0;\n        }\n    }\n    fgui.EventDispatcher = EventDispatcher;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Rect {\n        constructor(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        }\n        set(x, y, width, height) {\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n        }\n        setMinMax(xMin, yMin, xMax, yMax) {\n            this.x = xMin;\n            this.y = yMin;\n            this.width = xMax - xMin;\n            this.height = yMax - yMin;\n        }\n        get position() {\n            return new THREE.Vector2(this.x, this.y);\n        }\n        get size() {\n            return new THREE.Vector2(this.width, this.height);\n        }\n        get xMin() {\n            return this.x;\n        }\n        set xMin(value) {\n            let d = value - this.x;\n            this.x = value;\n            this.width -= d;\n        }\n        get xMax() {\n            return this.x + this.width;\n        }\n        set xMax(value) {\n            this.width = value - this.x;\n        }\n        get yMin() {\n            return this.y;\n        }\n        set yMin(value) {\n            let d = value - this.y;\n            this.y = value;\n            this.height -= d;\n        }\n        get yMax() {\n            return this.y + this.height;\n        }\n        set yMax(value) {\n            this.height = value - this.y;\n        }\n        intersection(another) {\n            if (this.width == 0 || this.height == 0 || another.width == 0 || another.height == 0)\n                return new Rect(0, 0, 0, 0);\n            let left = this.x > another.x ? this.x : another.x;\n            let right = this.xMax < another.xMax ? this.xMax : another.xMax;\n            let top = this.y > another.y ? this.y : another.y;\n            let bottom = this.yMax < another.yMax ? this.yMax : another.yMax;\n            if (left > right || top > bottom)\n                this.set(0, 0, 0, 0);\n            else\n                this.setMinMax(left, top, right, bottom);\n            return this;\n        }\n        union(another) {\n            if (another.width == 0 || another.height == 0)\n                return this;\n            if (this.width == 0 || this.height == 0) {\n                this.copy(another);\n                return this;\n            }\n            let x = Math.min(this.x, another.x);\n            let y = Math.min(this.y, another.y);\n            this.setMinMax(x, y, Math.max(this.xMax, another.xMax), Math.max(this.yMax, another.yMax));\n            return this;\n        }\n        extend(x, y) {\n            this.x -= x;\n            this.y -= y;\n            this.width += x * 2;\n            this.height += y * 2;\n        }\n        contains(x, y) {\n            if (x && x.isVector2) {\n                y = x.y;\n                x = x.x;\n            }\n            return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;\n        }\n        copy(source) {\n            this.set(source.x, source.y, source.width, source.height);\n        }\n        clone() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        }\n    }\n    fgui.Rect = Rect;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class DisplayObject extends fgui.EventDispatcher {\n        constructor() {\n            super();\n            this._obj3D = new THREE.Object3D();\n            this._obj3D[\"isGroup\"] = true;\n            this._obj3D[\"$owner\"] = this;\n            this._obj3D.layers.set(fgui.UILayer);\n            this._pos = this._obj3D.position;\n            this._rot = this._obj3D.rotation;\n            this._pivot = new THREE.Vector2();\n            this._pivotOffset = new THREE.Vector3();\n            this._contentRect = new fgui.Rect();\n            this._alpha = 1;\n            this._touchable = true;\n        }\n        get obj3D() {\n            return this._obj3D;\n        }\n        get name() {\n            return this._obj3D.name;\n        }\n        set name(value) {\n            this._obj3D.name = value;\n        }\n        get x() {\n            return this._pos.x;\n        }\n        set x(value) {\n            this.setPosition(value, -this._pos.y, this._pos.z);\n        }\n        get y() {\n            return -this._pos.y;\n        }\n        set y(value) {\n            this.setPosition(this._pos.x, value, this._pos.z);\n        }\n        get z() {\n            return this._pos.z;\n        }\n        set z(value) {\n            this.setPosition(this._pos.x, -this._pos.y, value);\n        }\n        setPosition(x, y, z, isPivot) {\n            z = z || 0;\n            if (isPivot) {\n                x -= this._pivotOffset.x;\n                y += this._pivotOffset.y;\n                z -= this._pivotOffset.z;\n            }\n            this._matrixDirty = true;\n            this._pos.set(x, -y, z);\n        }\n        get width() {\n            this.ensureSizeCorrect();\n            return this._contentRect.width;\n        }\n        set width(value) {\n            if (this._contentRect.width != value) {\n                this._contentRect.width = value;\n                this.onSizeChanged();\n            }\n        }\n        get height() {\n            this.ensureSizeCorrect();\n            return this._contentRect.height;\n        }\n        set height(value) {\n            if (this._contentRect.height != value) {\n                this._contentRect.height = value;\n                this.onSizeChanged();\n            }\n        }\n        setSize(wv, hv) {\n            if (wv != this._contentRect.width || hv != this._contentRect.height) {\n                this._contentRect.width = wv;\n                this._contentRect.height = hv;\n                this.onSizeChanged();\n            }\n        }\n        ensureSizeCorrect() {\n        }\n        onSizeChanged() {\n            this.applyPivot();\n            if (this._graphics)\n                this._graphics.setDrawRect(this._contentRect);\n        }\n        get pivotX() {\n            return this._pivot.x;\n        }\n        set pivotX(value) {\n            this.setPivot(value, this._pivot.y);\n        }\n        get pivotY() {\n            return this._pivot.y;\n        }\n        set pivotY(value) {\n            this.setPosition(this._pivot.x, value);\n        }\n        setPivot(xv, yv) {\n            if (this._pivot.x != xv || this._pivot.y != yv) {\n                let dpx = (xv - this._pivot.x) * this._contentRect.width;\n                let dpy = (this._pivot.y - yv) * this._contentRect.height;\n                s_v3.copy(this._pivotOffset);\n                this._pivot.set(xv, yv);\n                this.updatePivotOffset();\n                this._pos.x += s_v3.x - this._pivotOffset.x + dpx;\n                this._pos.y += s_v3.y - this._pivotOffset.y + dpy;\n                this._pos.y += s_v3.z - this._pivotOffset.z;\n                this._matrixDirty = true;\n            }\n        }\n        updatePivotOffset() {\n            let px = this._pivot.x * this._contentRect.width;\n            let py = this._pivot.y * this._contentRect.height;\n            s_quaternion.setFromEuler(this._rot);\n            s_mat.compose(s_v3_2, s_quaternion, this._obj3D.scale);\n            this._pivotOffset.set(px, -py, 0);\n            this._pivotOffset.applyMatrix4(s_mat);\n        }\n        applyPivot() {\n            if (this._pivot.x != 0 || this._pivot.y != 0) {\n                s_v3.copy(this._pivotOffset);\n                this.updatePivotOffset();\n                this._pos.x += s_v3.x - this._pivotOffset.x;\n                this._pos.y += s_v3.y - this._pivotOffset.y;\n                this._matrixDirty = true;\n            }\n        }\n        get scaleX() {\n            return this._obj3D.scale.x;\n        }\n        set scaleX(value) {\n            this.setScale(value, this._obj3D.scale.y);\n        }\n        get scaleY() {\n            return this._obj3D.scale.y;\n        }\n        set scaleY(value) {\n            this.setScale(this._obj3D.scale.x, value);\n        }\n        setScale(xv, yv) {\n            this._obj3D.scale.set(xv, yv, xv);\n            this.applyPivot();\n            this._matrixDirty = true;\n        }\n        get rotationX() {\n            return this._rot.x * 180 / Math.PI;\n        }\n        set rotationX(value) {\n            this._rot.x = value * Math.PI / 180;\n            this.applyPivot();\n            this._matrixDirty = true;\n        }\n        get rotationY() {\n            return this._rot.y * 180 / Math.PI;\n        }\n        set rotationY(value) {\n            this._rot.y = value * Math.PI / 180;\n            this.applyPivot();\n            this._matrixDirty = true;\n        }\n        get rotation() {\n            return -this._rot.z * 180 / Math.PI;\n        }\n        set rotation(value) {\n            this._rot.z = -value * Math.PI / 180;\n            this.applyPivot();\n            this._matrixDirty = true;\n        }\n        get parent() {\n            return this._obj3D.parent;\n        }\n        get stage() {\n            let t = this._obj3D;\n            while (t.parent)\n                t = t.parent;\n            return t[\"isScene\"];\n        }\n        get graphics() {\n            return this._graphics;\n        }\n        get alpha() {\n            return this._alpha;\n        }\n        set alpha(value) {\n            this._alpha = value;\n        }\n        get touchable() {\n            return this._touchable;\n        }\n        set touchable(value) {\n            this._touchable = value;\n        }\n        get visible() {\n            return this._obj3D.visible;\n        }\n        set visible(value) {\n            this._obj3D.visible = value;\n        }\n        get color() {\n            return this._graphics ? this._graphics.color : 0;\n        }\n        set color(value) {\n            if (this._graphics)\n                this._graphics.color = value;\n        }\n        get blendMode() {\n            return this._graphics ? this._graphics.material.blending : THREE.NormalBlending;\n        }\n        set blendMode(value) {\n            if (this._graphics)\n                this._graphics.material.blending = value;\n        }\n        setLayer(layer) {\n            this._obj3D.traverse(obj => obj.layers.set(layer));\n        }\n        validateMatrix() {\n            this._obj3D.traverseAncestors(e => {\n                let dobj = e[\"$owner\"];\n                if (dobj && dobj._matrixDirty) {\n                    dobj._matrixDirty = false;\n                    dobj._obj3D.updateMatrixWorld(true);\n                }\n            });\n            if (this._matrixDirty) {\n                this._matrixDirty = false;\n                this._obj3D.updateMatrixWorld(true);\n            }\n        }\n        _getRenderCamera() {\n            let p = this._obj3D;\n            while (p) {\n                let dobj = p[\"$owner\"];\n                if (dobj && dobj.camera)\n                    return dobj.camera;\n                p = p.parent;\n            }\n            return fgui.Stage.camera;\n        }\n        worldToLocal(pt, direction, validate) {\n            if (validate)\n                this.validateMatrix();\n            pt = this._obj3D.worldToLocal(pt);\n            if (pt.z != 0) {\n                s_dir.copy(direction || s_forward);\n                s_dir.applyQuaternion(this._obj3D.getWorldQuaternion(s_quaternion).inverse()).normalize();\n                let distOnLine = -pt.dot(s_forward) / s_dir.dot(s_forward);\n                pt.add(s_dir.multiplyScalar(distOnLine));\n            }\n            pt.y = -pt.y;\n            return pt;\n        }\n        localToWorld(pt, validate) {\n            if (validate)\n                this.validateMatrix();\n            pt.y = -pt.y;\n            pt = this._obj3D.localToWorld(pt);\n            return pt;\n        }\n        globalToLocal(x, y, result) {\n            if (!fgui.Stage.disableMatrixValidation)\n                this.validateMatrix();\n            fgui.screenToWorld(this._getRenderCamera(), x, y, s_v3, s_dir);\n            this.worldToLocal(s_v3, s_dir);\n            if (!result)\n                result = new THREE.Vector2();\n            result.set(s_v3.x, s_v3.y);\n            return result;\n        }\n        localToGlobal(x, y, result) {\n            if (!fgui.Stage.disableMatrixValidation)\n                this.validateMatrix();\n            s_v3.set(x, -y, 0);\n            this._obj3D.localToWorld(s_v3);\n            if (!result)\n                result = new THREE.Vector2();\n            fgui.worldToScreen(this._getRenderCamera(), s_v3, result);\n            return result;\n        }\n        getBounds(targetSpace, result) {\n            this.ensureSizeCorrect();\n            if (!result)\n                result = new fgui.Rect();\n            if (targetSpace == this._obj3D)\n                result.copy(this._contentRect);\n            else if (targetSpace == this._obj3D.parent && this._rot.z == 0)\n                result.set(this._pos.x, -this._pos.y, this._contentRect.width * this._obj3D.scale.x, this._contentRect.height * this._obj3D.scale.y);\n            else\n                result = this.transformRect(this._contentRect, targetSpace, result);\n            return result;\n        }\n        transformPoint(x, y, targetSpace, result) {\n            if (!result)\n                result = new THREE.Vector2();\n            if (targetSpace == this._obj3D)\n                result.set(x, y);\n            else {\n                if (!fgui.Stage.disableMatrixValidation)\n                    this.validateMatrix();\n                s_v3.set(x, -y, 0);\n                this._obj3D.localToWorld(s_v3);\n                if (targetSpace)\n                    targetSpace.worldToLocal(s_v3);\n                result.set(s_v3.x, -s_v3.y);\n            }\n            return result;\n        }\n        transformRect(rect, targetSpace, result) {\n            if (!result)\n                result = new fgui.Rect();\n            if (targetSpace == this._obj3D) {\n                result.copy(rect);\n                return result;\n            }\n            if (targetSpace && targetSpace == this._obj3D.parent && this._rot.z == 0) {\n                let scale = this._obj3D.scale;\n                result.set((this._pos.x + rect.x) * scale.x, (this.y + rect.y) * scale.y, rect.width * scale.x, rect.height * scale.y);\n            }\n            else {\n                s_v4.set(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n                if (!fgui.Stage.disableMatrixValidation)\n                    this.validateMatrix();\n                this.transformRectPoint(rect.x, rect.y, targetSpace);\n                this.transformRectPoint(rect.xMax, rect.y, targetSpace);\n                this.transformRectPoint(rect.x, rect.yMax, targetSpace);\n                this.transformRectPoint(rect.xMax, rect.yMax, targetSpace);\n                result.setMinMax(s_v4.x, s_v4.y, s_v4.z, s_v4.w);\n            }\n            return result;\n        }\n        transformRectPoint(x, y, targetSpace) {\n            s_v3.set(x, y, 0);\n            this.localToWorld(s_v3);\n            if (targetSpace)\n                targetSpace.worldToLocal(s_v3);\n            if (s_v4.x > s_v3.x)\n                s_v4.x = s_v3.x;\n            if (s_v4.z < s_v3.x)\n                s_v4.z = s_v3.x;\n            if (s_v4.y > s_v3.y)\n                s_v4.y = s_v3.y;\n            if (s_v4.w < s_v3.y)\n                s_v4.w = s_v3.y;\n        }\n        addChild(child) {\n            this.addChildAt(child, Number.POSITIVE_INFINITY);\n        }\n        addChildAt(child, index) {\n            if (child._obj3D.parent) {\n                let i = child._obj3D.parent.children.indexOf(child._obj3D);\n                child._obj3D.parent.children.splice(i, 1);\n            }\n            if (index >= this._obj3D.children.length)\n                this._obj3D.children.push(child._obj3D);\n            else\n                this._obj3D.children.splice(index, 0, child._obj3D);\n            child._obj3D.parent = this._obj3D;\n            child._obj3D.layers.mask = this._obj3D.layers.mask;\n            if (this.stage)\n                fgui.broadcastEvent(child.obj3D, fgui.StageEvent.AddtoStage);\n        }\n        removeChild(child) {\n            let index = this._obj3D.children.indexOf(child._obj3D);\n            if (index == -1)\n                throw 'not a child';\n            this.removeChildAt(index);\n        }\n        removeChildAt(index) {\n            let child = this._obj3D.children[index];\n            if (this.stage)\n                fgui.broadcastEvent(child, fgui.StageEvent.RemoveFromStage);\n            this._obj3D.children.splice(index, 1);\n            child.parent = null;\n        }\n        setChildIndex(child, index) {\n            let oldIndex = this._obj3D.children.indexOf(child._obj3D);\n            if (oldIndex == index)\n                return;\n            if (oldIndex == -1)\n                throw 'Not a child';\n            this._obj3D.children.splice(oldIndex, 1);\n            if (index >= this._obj3D.children.length)\n                this._obj3D.children.push(child._obj3D);\n            else\n                this._obj3D.children.splice(index, 0, child._obj3D);\n        }\n        getIndex(child) {\n            return this._obj3D.children.indexOf(child._obj3D);\n        }\n        get numChildren() {\n            return this._obj3D.children.length;\n        }\n        get clipRect() {\n            return this._clipRect;\n        }\n        set clipRect(value) {\n            this._clipRect = value;\n        }\n        update(clipPlanes, alpha) {\n            if (this._clipRect) {\n                this.transformRect(this._clipRect, null, s_rect);\n                if (clipPlanes) {\n                    s_rect2.setMinMax(-clipPlanes[0].constant, -clipPlanes[3].constant, clipPlanes[1].constant, clipPlanes[2].constant);\n                    s_rect.intersection(s_rect2);\n                }\n                if (!this._clipPlanes) {\n                    this._clipPlanes = [\n                        new THREE.Plane(new THREE.Vector3(1, 0, 0)),\n                        new THREE.Plane(new THREE.Vector3(-1, 0, 0)),\n                        new THREE.Plane(new THREE.Vector3(0, -1, 0)),\n                        new THREE.Plane(new THREE.Vector3(0, 1, 0))\n                    ];\n                }\n                clipPlanes = this._clipPlanes;\n                clipPlanes[0].constant = -s_rect.x;\n                clipPlanes[1].constant = s_rect.xMax;\n                clipPlanes[2].constant = s_rect.yMax;\n                clipPlanes[3].constant = -s_rect.y;\n            }\n            if (this._graphics)\n                this._graphics.update(clipPlanes, this._alpha * alpha);\n        }\n        hitTest(context) {\n            if (this._obj3D.scale.x == 0 || this._obj3D.scale.y == 0)\n                return null;\n            let backupRay;\n            if (this.camera) {\n                backupRay = context.ray;\n                context.camera = this.camera;\n            }\n            let target;\n            let pt = context.getLocal(this);\n            let lx = pt.x;\n            let ly = pt.y;\n            if (this.hitArea) {\n                if (!this.hitArea.hitTest(this._contentRect, lx, ly))\n                    return null;\n            }\n            else {\n                if (this._clipRect && !this._clipRect.contains(lx, ly))\n                    return null;\n            }\n            if (this.mask) {\n                let tmp = this.mask.visible ? this.mask.hitTest(context) : null;\n                if (!this.reversedMask && !tmp || this.reversedMask && tmp)\n                    return null;\n            }\n            target = traverseHitTest(this._obj3D, context, this.mask);\n            if (!target && this.opaque && (this.hitArea || this._contentRect.contains(lx, ly)))\n                target = this;\n            if (backupRay)\n                context.ray = backupRay;\n            return target;\n        }\n        dispose() {\n        }\n    }\n    fgui.DisplayObject = DisplayObject;\n    var s_v3 = new THREE.Vector3();\n    var s_v3_2 = new THREE.Vector3();\n    var s_v4 = new THREE.Vector4();\n    var s_rect = new fgui.Rect();\n    var s_rect2 = new fgui.Rect();\n    var s_mat = new THREE.Matrix4();\n    var s_quaternion = new THREE.Quaternion();\n    var s_dir = new THREE.Vector3();\n    const s_forward = new THREE.Vector3(0, 0, 1);\n    function traverseUpdate(p, clippingPlanes, alpha) {\n        let children = p.children;\n        let cnt = children.length;\n        let dobj = p[\"$owner\"];\n        if (dobj) {\n            if (dobj._clipRect)\n                clippingPlanes = dobj._clipPlanes;\n            alpha *= dobj.alpha;\n        }\n        for (let i = 0; i < cnt; i++) {\n            let child = children[i];\n            dobj = child[\"$owner\"];\n            if (dobj)\n                dobj.update(clippingPlanes, alpha);\n            if (child.children.length > 0)\n                traverseUpdate(child, clippingPlanes, alpha);\n        }\n    }\n    fgui.traverseUpdate = traverseUpdate;\n    function traverseHitTest(p, context, mask) {\n        let count = p.children.length;\n        for (let i = count - 1; i >= 0; --i) {\n            let child = p.children[i];\n            if (!child.visible)\n                continue;\n            let dobj = child[\"$owner\"];\n            if (dobj) {\n                if (dobj == mask || dobj._touchDisabled)\n                    continue;\n                if (!context.forTouch || dobj._touchable) {\n                    let target = dobj.hitTest(context);\n                    if (target)\n                        return target;\n                }\n            }\n            if (child.children.length > 0) {\n                let target = traverseHitTest(child, context);\n                if (target)\n                    return target;\n            }\n        }\n    }\n    fgui.traverseHitTest = traverseHitTest;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Image extends fgui.DisplayObject {\n        constructor() {\n            super();\n            this._tileGridIndice = 0;\n            this._graphics = new fgui.NGraphics(this._obj3D);\n            this._graphics.meshFactory = this;\n            this._textureScale = new THREE.Vector2(1, 1);\n        }\n        get texture() {\n            return this._graphics.texture;\n        }\n        set texture(value) {\n            this._graphics.texture = value;\n        }\n        get textureScale() {\n            return this._textureScale;\n        }\n        set textureScale(value) {\n            if (!this._textureScale.equals(value)) {\n                this._textureScale.copy(value);\n                this._graphics.setMeshDirty();\n            }\n        }\n        get scale9Grid() {\n            return this._scale9Grid;\n        }\n        set scale9Grid(value) {\n            this._scale9Grid = value;\n            this._graphics.setMeshDirty();\n        }\n        get scaleByTile() {\n            return this._scaleByTile;\n        }\n        set scaleByTile(value) {\n            if (this._scaleByTile != value) {\n                this._scaleByTile = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        get tileGridIndice() {\n            return this._tileGridIndice;\n        }\n        set tileGridIndice(value) {\n            if (this._tileGridIndice != value) {\n                this._tileGridIndice = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        get fillMethod() {\n            return this._fillMesh ? this._fillMesh.method : fgui.FillMethod.None;\n        }\n        set fillMethod(value) {\n            if (!this._fillMesh) {\n                if (value == fgui.FillMethod.None)\n                    return;\n                this._fillMesh = new fgui.FillMesh();\n            }\n            if (this._fillMesh.method != value) {\n                this._fillMesh.method = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        get fillOrigin() {\n            return this._fillMesh ? this._fillMesh.origin : 0;\n        }\n        set fillOrigin(value) {\n            if (!this._fillMesh)\n                this._fillMesh = new fgui.FillMesh();\n            if (this._fillMesh.origin != value) {\n                this._fillMesh.origin = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        get fillClockwise() {\n            return this._fillMesh ? this._fillMesh.clockwise : true;\n        }\n        set fillClockwise(value) {\n            if (!this._fillMesh)\n                this._fillMesh = new fgui.FillMesh();\n            if (this._fillMesh.clockwise != value) {\n                this._fillMesh.clockwise = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        get fillAmount() {\n            return this._fillMesh ? this._fillMesh.amount : 0;\n        }\n        set fillAmount(value) {\n            if (!this._fillMesh)\n                this._fillMesh = new fgui.FillMesh();\n            if (this._fillMesh.amount != value) {\n                this._fillMesh.amount = value;\n                this._graphics.setMeshDirty();\n            }\n        }\n        onPopulateMesh(vb) {\n            if (this._fillMesh && this._fillMesh.method != fgui.FillMethod.None) {\n                this._fillMesh.onPopulateMesh(vb);\n            }\n            else if (this._scaleByTile) {\n                contentRect.copy(vb.contentRect);\n                contentRect.width *= this._textureScale.x;\n                contentRect.height *= this._textureScale.y;\n                this.tileFill(vb, contentRect, vb.uvRect, this._graphics.texture.width, this._graphics.texture.height);\n                vb.addTriangles();\n            }\n            else if (this._scale9Grid) {\n                this.sliceFill(vb);\n            }\n            else\n                this._graphics.onPopulateMesh(vb);\n        }\n        sliceFill(vb) {\n            let texture = this.texture;\n            gridRect.copy(this._scale9Grid);\n            contentRect.copy(vb.contentRect);\n            contentRect.width *= this._textureScale.x;\n            contentRect.height *= this._textureScale.y;\n            let uvRect = vb.uvRect;\n            let sourceW = texture.width;\n            let sourceH = texture.height;\n            let flip = this._graphics.flip;\n            if (flip != fgui.FlipType.None) {\n                if (flip == fgui.FlipType.Horizontal || flip == fgui.FlipType.Both) {\n                    gridRect.x = sourceW - gridRect.xMax;\n                    gridRect.xMax = gridRect.x + gridRect.width;\n                }\n                if (flip == fgui.FlipType.Vertical || flip == fgui.FlipType.Both) {\n                    gridRect.y = sourceH - gridRect.yMax;\n                    gridRect.yMax = gridRect.y + gridRect.height;\n                }\n            }\n            let sx = uvRect.width / sourceW;\n            let sy = uvRect.height / sourceH;\n            let xMax = uvRect.xMax;\n            let yMax = uvRect.yMax;\n            let xMax2 = gridRect.xMax;\n            let yMax2 = gridRect.yMax;\n            gridTexX[0] = uvRect.x;\n            gridTexX[1] = uvRect.x + gridRect.x * sx;\n            gridTexX[2] = uvRect.x + xMax2 * sx;\n            gridTexX[3] = xMax;\n            gridTexY[0] = yMax;\n            gridTexY[1] = yMax - gridRect.y * sy;\n            gridTexY[2] = yMax - yMax2 * sy;\n            gridTexY[3] = uvRect.y;\n            if (contentRect.width >= (sourceW - gridRect.width)) {\n                gridX[1] = gridRect.x;\n                gridX[2] = contentRect.width - (sourceW - xMax2);\n                gridX[3] = contentRect.width;\n            }\n            else {\n                let tmp = gridRect.x / (sourceW - xMax2);\n                tmp = contentRect.width * tmp / (1 + tmp);\n                gridX[1] = tmp;\n                gridX[2] = tmp;\n                gridX[3] = contentRect.width;\n            }\n            if (contentRect.height >= (sourceH - gridRect.height)) {\n                gridY[1] = gridRect.y;\n                gridY[2] = contentRect.height - (sourceH - yMax2);\n                gridY[3] = contentRect.height;\n            }\n            else {\n                let tmp = gridRect.y / (sourceH - yMax2);\n                tmp = contentRect.height * tmp / (1 + tmp);\n                gridY[1] = tmp;\n                gridY[2] = tmp;\n                gridY[3] = contentRect.height;\n            }\n            if (this._tileGridIndice == 0) {\n                for (let cy = 0; cy < 4; cy++) {\n                    for (let cx = 0; cx < 4; cx++)\n                        vb.addVert(gridX[cx] / this._textureScale.x, gridY[cy] / this._textureScale.y, 0, gridTexX[cx], gridTexY[cy], vb.vertexColor);\n                }\n                vb.addTriangles(0, TRIANGLES_9_GRID);\n            }\n            else {\n                let row, col;\n                let part;\n                for (let pi = 0; pi < 9; pi++) {\n                    col = pi % 3;\n                    row = pi / 3;\n                    part = gridTileIndice[pi];\n                    drawRect.setMinMax(gridX[col], gridY[row], gridX[col + 1], gridY[row + 1]);\n                    texRect.setMinMax(gridTexX[col], gridTexY[row + 1], gridTexX[col + 1], gridTexY[row]);\n                    if (part != -1 && (this._tileGridIndice & (1 << part)) != 0) {\n                        this.tileFill(vb, drawRect, texRect, (part == 0 || part == 1 || part == 4) ? gridRect.width : drawRect.width, (part == 2 || part == 3 || part == 4) ? gridRect.height : drawRect.height);\n                    }\n                    else {\n                        drawRect.x /= this._textureScale.x;\n                        drawRect.y /= this._textureScale.y;\n                        drawRect.width /= this._textureScale.x;\n                        drawRect.height /= this._textureScale.y;\n                        vb.addQuad(drawRect, texRect, vb.vertexColor);\n                    }\n                }\n                vb.addTriangles();\n            }\n        }\n        tileFill(vb, contentRect, uvRect, sourceW, sourceH) {\n            let hc = Math.ceil(contentRect.width / sourceW);\n            let vc = Math.ceil(contentRect.height / sourceH);\n            let tailWidth = contentRect.width - (hc - 1) * sourceW;\n            let tailHeight = contentRect.height - (vc - 1) * sourceH;\n            let xMax = uvRect.xMax;\n            let yMax = uvRect.yMax;\n            for (let i = 0; i < hc; i++) {\n                for (let j = 0; j < vc; j++) {\n                    texRect2.copy(uvRect);\n                    if (i == hc - 1)\n                        texRect2.xMax = fgui.lerp(uvRect.x, xMax, tailWidth / sourceW);\n                    if (j == vc - 1)\n                        texRect2.yMin = fgui.lerp(uvRect.y, yMax, 1 - tailHeight / sourceH);\n                    drawRect2.set(contentRect.x + i * sourceW, contentRect.y + j * sourceH, i == (hc - 1) ? tailWidth : sourceW, j == (vc - 1) ? tailHeight : sourceH);\n                    drawRect2.x /= this._textureScale.x;\n                    drawRect2.y /= this._textureScale.y;\n                    drawRect2.width /= this._textureScale.x;\n                    drawRect2.height /= this._textureScale.y;\n                    vb.addQuad(drawRect2, texRect2, vb.vertexColor);\n                }\n            }\n        }\n    }\n    fgui.Image = Image;\n    const TRIANGLES_9_GRID = [\n        4, 1, 0, 1, 4, 5,\n        5, 2, 1, 2, 5, 6,\n        6, 3, 2, 3, 6, 7,\n        8, 5, 4, 5, 8, 9,\n        9, 6, 5, 6, 9, 10,\n        10, 7, 6, 7, 10, 11,\n        12, 9, 8, 9, 12, 13,\n        13, 10, 9, 10, 13, 14,\n        14, 11, 10,\n        11, 14, 15\n    ];\n    const gridTileIndice = [-1, 0, -1, 2, 4, 3, -1, 1, -1];\n    var gridX = [0, 0, 0, 0];\n    var gridY = [0, 0, 0, 0];\n    var gridTexX = [0, 0, 0, 0];\n    var gridTexY = [0, 0, 0, 0];\n    var gridRect = new fgui.Rect();\n    var contentRect = new fgui.Rect();\n    var drawRect = new fgui.Rect();\n    var texRect = new fgui.Rect();\n    var drawRect2 = new fgui.Rect();\n    var texRect2 = new fgui.Rect();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class MovieClip extends fgui.Image {\n        constructor() {\n            super();\n            this.interval = 0;\n            this.swing = false;\n            this.repeatDelay = 0;\n            this.timeScale = 1;\n            this._playing = true;\n            this._frameCount = 0;\n            this._frame = 0;\n            this._start = 0;\n            this._end = 0;\n            this._times = 0;\n            this._endAt = 0;\n            this._status = 0;\n            this._frameElapsed = 0;\n            this._reversed = false;\n            this._repeatedCount = 0;\n            this.setPlaySettings();\n            this.on(fgui.StageEvent.AddtoStage, this.__addToStage, this);\n            this.on(fgui.StageEvent.RemoveFromStage, this.__removeFromStage, this);\n        }\n        get frames() {\n            return this._frames;\n        }\n        set frames(value) {\n            this._frames = value;\n            this._scaleByTile = false;\n            this._scale9Grid = null;\n            if (this._frames) {\n                this._frameCount = this._frames.length;\n                if (this._end == -1 || this._end > this._frameCount - 1)\n                    this._end = this._frameCount - 1;\n                if (this._endAt == -1 || this._endAt > this._frameCount - 1)\n                    this._endAt = this._frameCount - 1;\n                if (this._frame < 0 || this._frame > this._frameCount - 1)\n                    this._frame = this._frameCount - 1;\n                this._frameElapsed = 0;\n                this._repeatedCount = 0;\n                this._reversed = false;\n            }\n            else\n                this._frameCount = 0;\n            this.drawFrame();\n            this.checkTimer();\n        }\n        get frameCount() {\n            return this._frameCount;\n        }\n        get frame() {\n            return this._frame;\n        }\n        set frame(value) {\n            if (this._frame != value) {\n                if (this._frames && value >= this._frameCount)\n                    value = this._frameCount - 1;\n                this._frame = value;\n                this._frameElapsed = 0;\n                this.drawFrame();\n            }\n        }\n        get playing() {\n            return this._playing;\n        }\n        set playing(value) {\n            if (this._playing != value) {\n                this._playing = value;\n                this.checkTimer();\n            }\n        }\n        rewind() {\n            this._frame = 0;\n            this._frameElapsed = 0;\n            this._reversed = false;\n            this._repeatedCount = 0;\n            this.drawFrame();\n        }\n        syncStatus(anotherMc) {\n            this._frame = anotherMc._frame;\n            this._frameElapsed = anotherMc._frameElapsed;\n            this._reversed = anotherMc._reversed;\n            this._repeatedCount = anotherMc._repeatedCount;\n            this.drawFrame();\n        }\n        advance(timeInMiniseconds) {\n            var beginFrame = this._frame;\n            var beginReversed = this._reversed;\n            var backupTime = timeInMiniseconds;\n            while (true) {\n                var tt = this.interval + (this._frames[this._frame].addDelay || 0);\n                if (this._frame == 0 && this._repeatedCount > 0)\n                    tt += this.repeatDelay;\n                if (timeInMiniseconds < tt) {\n                    this._frameElapsed = 0;\n                    break;\n                }\n                timeInMiniseconds -= tt;\n                if (this.swing) {\n                    if (this._reversed) {\n                        this._frame--;\n                        if (this._frame <= 0) {\n                            this._frame = 0;\n                            this._repeatedCount++;\n                            this._reversed = !this._reversed;\n                        }\n                    }\n                    else {\n                        this._frame++;\n                        if (this._frame > this._frameCount - 1) {\n                            this._frame = Math.max(0, this._frameCount - 2);\n                            this._repeatedCount++;\n                            this._reversed = !this._reversed;\n                        }\n                    }\n                }\n                else {\n                    this._frame++;\n                    if (this._frame > this._frameCount - 1) {\n                        this._frame = 0;\n                        this._repeatedCount++;\n                    }\n                }\n                if (this._frame == beginFrame && this._reversed == beginReversed) {\n                    var roundTime = backupTime - timeInMiniseconds;\n                    timeInMiniseconds -= Math.floor(timeInMiniseconds / roundTime) * roundTime;\n                }\n            }\n            this.drawFrame();\n        }\n        setPlaySettings(start, end, times, endAt) {\n            this._start = start || 0;\n            this._end = end || -1;\n            if (this._end == -1 || this._end > this._frameCount - 1)\n                this._end = this._frameCount - 1;\n            this._times = times || 0;\n            this._endAt = endAt || -1;\n            if (this._endAt == -1)\n                this._endAt = this._end;\n            this._status = 0;\n            this.frame = this._start;\n        }\n        onTimer() {\n            if (!this._playing || this._frameCount == 0 || this._status == 3)\n                return;\n            var dt = fgui.Timers.deltaTime;\n            if (dt > 100)\n                dt = 100;\n            if (this.timeScale != 1)\n                dt *= this.timeScale;\n            this._frameElapsed += dt;\n            var tt = this.interval + (this._frames[this._frame].addDelay || 0);\n            if (this._frame == 0 && this._repeatedCount > 0)\n                tt += this.repeatDelay;\n            if (this._frameElapsed < tt)\n                return;\n            this._frameElapsed -= tt;\n            if (this._frameElapsed > this.interval)\n                this._frameElapsed = this.interval;\n            if (this.swing) {\n                if (this._reversed) {\n                    this._frame--;\n                    if (this._frame <= 0) {\n                        this._frame = 0;\n                        this._repeatedCount++;\n                        this._reversed = !this._reversed;\n                    }\n                }\n                else {\n                    this._frame++;\n                    if (this._frame > this._frameCount - 1) {\n                        this._frame = Math.max(0, this._frameCount - 2);\n                        this._repeatedCount++;\n                        this._reversed = !this._reversed;\n                    }\n                }\n            }\n            else {\n                this._frame++;\n                if (this._frame > this._frameCount - 1) {\n                    this._frame = 0;\n                    this._repeatedCount++;\n                }\n            }\n            if (this._status == 1) {\n                this._frame = this._start;\n                this._frameElapsed = 0;\n                this._status = 0;\n            }\n            else if (this._status == 2) {\n                this._frame = this._endAt;\n                this._frameElapsed = 0;\n                this._status = 3;\n                this.dispatchEvent(fgui.PlayEvent.PlayEnd);\n            }\n            else {\n                if (this._frame == this._end) {\n                    if (this._times > 0) {\n                        this._times--;\n                        if (this._times == 0)\n                            this._status = 2;\n                        else\n                            this._status = 1;\n                    }\n                    else {\n                        this._status = 1;\n                    }\n                }\n            }\n            this.drawFrame();\n        }\n        drawFrame() {\n            if (this._frameCount > 0 && this._frame < this._frames.length) {\n                var frame = this._frames[this._frame];\n                this._graphics.texture = frame.texture;\n            }\n            else\n                this._graphics.texture = null;\n        }\n        checkTimer() {\n            if (this._playing && this._frameCount > 0 && this.stage)\n                fgui.Timers.addUpdate(this.onTimer, this);\n            else\n                fgui.Timers.remove(this.onTimer, this);\n        }\n        __addToStage() {\n            if (this._playing && this._frameCount > 0)\n                fgui.Timers.addUpdate(this.onTimer, this);\n        }\n        __removeFromStage() {\n            fgui.Timers.remove(this.onTimer, this);\n        }\n    }\n    fgui.MovieClip = MovieClip;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Color4 extends THREE.Color {\n        constructor(rgb, a) {\n            super(rgb || 0);\n            this.a = a != null ? a : 1;\n        }\n    }\n    fgui.Color4 = Color4;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class NGraphics {\n        constructor(owner) {\n            this._flip = 0;\n            this._color = 0xFFFFFF;\n            this._contentRect = new fgui.Rect();\n            this._material = new fgui.NMaterial();\n            this._geometry = new THREE.BufferGeometry();\n            let o = owner;\n            o.geometry = this._geometry;\n            o.material = this._material;\n            o.isMesh = true;\n            o.drawMode = THREE.TrianglesDrawMode;\n            delete o.isGroup;\n        }\n        get texture() {\n            return this._texture;\n        }\n        set texture(value) {\n            if (this._texture != value) {\n                this._texture = value;\n                this._meshDirty = true;\n            }\n            if (this._texture)\n                this._material.map = this._texture.nativeTexture;\n            else\n                this._material.map = null;\n        }\n        get material() {\n            return this._material;\n        }\n        set material(value) {\n            this._material = value;\n        }\n        get meshFactory() {\n            return this._meshFactory;\n        }\n        set meshFactory(value) {\n            if (this._meshFactory != value) {\n                this._meshFactory = value;\n                this._meshDirty = true;\n            }\n        }\n        getMeshFactory(type) {\n            if (!(this._meshFactory instanceof type)) {\n                this._meshFactory = new type();\n                this._meshDirty = true;\n            }\n            return this._meshFactory;\n        }\n        setDrawRect(rect) {\n            this._contentRect.copy(rect);\n            this._meshDirty = true;\n        }\n        get flip() {\n            return this._flip;\n        }\n        set flip(value) {\n            if (this._flip != value) {\n                this._flip = value;\n                this._meshDirty = true;\n            }\n        }\n        get color() {\n            return this._color;\n        }\n        set color(value) {\n            if (this._color != value) {\n                this._color = value;\n                if (!this._meshDirty) {\n                    s_col.setHex(value);\n                    let attr = this._geometry.attributes[\"color\"];\n                    if (attr) {\n                        let arr = attr.array;\n                        let len = arr.length;\n                        for (let i = 0; i < len; i += 4) {\n                            arr[i] = s_col.r;\n                            arr[i + 1] = s_col.g;\n                            arr[i + 2] = s_col.b;\n                            arr[i + 3] = s_col.a;\n                        }\n                        attr.needsUpdate = true;\n                    }\n                }\n            }\n        }\n        get grayed() {\n            return this._material.defines.GRAYED;\n        }\n        set grayed(value) {\n            this.setKeyword(\"GRAYED\", value);\n        }\n        setKeyword(key, value) {\n            if (value) {\n                this._material.defines[key] = value;\n                this._material.needsUpdate = true;\n            }\n            else\n                delete this._material.defines[key];\n        }\n        setMeshDirty() {\n            this._meshDirty = true;\n        }\n        updateMesh() {\n            if (this._meshDirty) {\n                this.updateMeshNow();\n                return true;\n            }\n            else\n                return false;\n        }\n        update(clipPlanes, alpha) {\n            if (this._meshDirty)\n                this.updateMeshNow();\n            this._material.clippingPlanes = clipPlanes;\n            this._material.clipping = clipPlanes != null;\n            this._material.opacity = alpha;\n        }\n        updateMeshNow() {\n            this._meshDirty = false;\n            if (!this._texture || !this._meshFactory) {\n                if (this._geometry.drawRange.count > 0) {\n                    this._geometry.setDrawRange(0, 0);\n                    this._geometry.computeBoundingSphere();\n                }\n                return;\n            }\n            let vb = fgui.VertexBuffer.begin();\n            vb.contentRect.copy(this._contentRect);\n            vb.uvRect.copy(this._texture.uvRect);\n            if (this._texture)\n                vb.textureSize.set(this._texture.width, this._texture.height);\n            else\n                vb.textureSize.set(0, 0);\n            if (this._flip != fgui.FlipType.None) {\n                if (this._flip == fgui.FlipType.Horizontal || this._flip == fgui.FlipType.Both) {\n                    let tmp = vb.uvRect.xMin;\n                    vb.uvRect.xMin = vb.uvRect.xMax;\n                    vb.uvRect.xMax = tmp;\n                }\n                if (this._flip == fgui.FlipType.Vertical || this._flip == fgui.FlipType.Both) {\n                    let tmp = vb.uvRect.yMin;\n                    vb.uvRect.yMin = vb.uvRect.yMax;\n                    vb.uvRect.yMax = tmp;\n                }\n            }\n            vb.vertexColor.setHex(this._color);\n            this._meshFactory.onPopulateMesh(vb);\n            let vertCount = vb.currentVertCount;\n            if (vertCount == 0) {\n                if (this._geometry.drawRange.count > 0) {\n                    this._geometry.setDrawRange(0, 0);\n                    this._geometry.computeBoundingSphere();\n                }\n                vb.end();\n                return;\n            }\n            if (this._texture.rotated) {\n                let xMin = this._texture.uvRect.x;\n                let yMin = this._texture.uvRect.y;\n                let yMax = this._texture.uvRect.yMax;\n                let k = 0;\n                for (let i = 0; i < vertCount; i++) {\n                    let v1 = vb.uvs[k];\n                    let v2 = vb.uvs[k + 1];\n                    vb.uvs[k + 1] = yMin + v1 - xMin;\n                    vb.uvs[k] = xMin + yMax - v2;\n                }\n            }\n            let gm = this._geometry;\n            this.writeAttribute(gm, \"position\", vb.vertices, 3);\n            this.writeAttribute(gm, \"uv\", vb.uvs, 2);\n            this.writeAttribute(gm, \"color\", vb.colors, 4);\n            this.writeIndexAttribute(gm, vb.triangles);\n            gm.setDrawRange(0, vb.triangles.length);\n            gm.computeBoundingSphere();\n            vb.end();\n        }\n        writeAttribute(gm, name, arr, itemSize) {\n            let attr = gm.attributes[name];\n            if (!attr || !attr.isBufferAttribute || attr.array.length < arr.length) {\n                attr = new THREE.BufferAttribute(new Float32Array(arr.length), itemSize);\n                gm.setAttribute(name, attr);\n            }\n            attr.copyArray(arr);\n            attr.needsUpdate = true;\n        }\n        writeIndexAttribute(gm, arr) {\n            let attr = gm.index;\n            if (!attr || !attr.isBufferAttribute || attr.array.length < arr.length) {\n                attr = new THREE.BufferAttribute(new Uint16Array(arr.length), 1);\n                gm.index = attr;\n            }\n            attr.copyArray(arr);\n            attr.needsUpdate = true;\n        }\n        onPopulateMesh(vb) {\n            this._texture.getDrawRect(vb.contentRect);\n            vb.addQuad(vb.contentRect, vb.uvRect, vb.vertexColor);\n            vb.addTriangles();\n        }\n    }\n    fgui.NGraphics = NGraphics;\n    var s_col = new fgui.Color4();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class NMaterial extends THREE.ShaderMaterial {\n        constructor() {\n            super();\n            let customUniforms = THREE.UniformsUtils.merge([\n                THREE.ShaderLib.basic.uniforms,\n                { _ColorMatrix: new THREE.Uniform(new THREE.Matrix4()) },\n                { _ColorOffset: new THREE.Uniform(new THREE.Vector4()) }\n            ]);\n            this.uniforms = customUniforms;\n            this.vertexShader = `\n            #include <common>\n            #include <uv_pars_vertex>\n            #include <uv2_pars_vertex>\n            #include <envmap_pars_vertex>\n            varying vec4 vColor;\n            attribute vec4 color;\n            #include <fog_pars_vertex>\n            #include <morphtarget_pars_vertex>\n            #include <skinning_pars_vertex>\n            #include <logdepthbuf_pars_vertex>\n            #include <clipping_planes_pars_vertex>\n            \n            void main() {\n            \n                #include <uv_vertex>\n                #include <uv2_vertex>\n    \n                vColor = color;\n    \n                #include <skinbase_vertex>\n            \n                #ifdef USE_ENVMAP\n            \n                #include <beginnormal_vertex>\n                #include <morphnormal_vertex>\n                #include <skinnormal_vertex>\n                #include <defaultnormal_vertex>\n            \n                #endif\n            \n                #include <begin_vertex>\n                #include <morphtarget_vertex>\n                #include <skinning_vertex>\n                #include <project_vertex>\n                #include <logdepthbuf_vertex>\n            \n                #include <worldpos_vertex>\n                #include <clipping_planes_vertex>\n                #include <envmap_vertex>\n                #include <fog_vertex>\n            \n            }\n            `;\n            this.fragmentShader = `\n            uniform bool grayed;\n            uniform bool filter;\n            uniform mat4 colorMatrix;\n            uniform vec4 colorOffset;\n    \n            uniform vec3 diffuse;\n            uniform float opacity;\n            #ifndef FLAT_SHADED\n                varying vec3 vNormal;\n            #endif\n            #include <common>\n            #include <dithering_pars_fragment>\n    \n            varying vec4 vColor;\n    \n            #include <uv_pars_fragment>\n            #include <uv2_pars_fragment>\n            #include <map_pars_fragment>\n            #include <alphamap_pars_fragment>\n            #include <aomap_pars_fragment>\n            #include <lightmap_pars_fragment>\n            #include <envmap_common_pars_fragment>\n            #include <envmap_pars_fragment>\n            #include <cube_uv_reflection_fragment>\n            #include <fog_pars_fragment>\n            #include <specularmap_pars_fragment>\n            #include <logdepthbuf_pars_fragment>\n            #include <clipping_planes_pars_fragment>\n            void main() {\n                #include <clipping_planes_fragment>\n                vec4 diffuseColor = vec4( diffuse, opacity );\n                #include <logdepthbuf_fragment>\n                #ifdef USE_MAP\n                    #ifdef TEXT\n                        vec4 sampleColor = texture2D( map, vUv );\n                        if(vColor.a<0.1)\n                            diffuseColor.a *= sampleColor.r;\n                        else if(vColor.a<0.4)\n                            diffuseColor.a *= sampleColor.g;\n                        else\n                            diffuseColor.a *= sampleColor.b;\n                    #else\n                        #include <map_fragment>\n                    #endif\n                #endif\n    \n                #ifdef TEXT\n                diffuseColor.rgb *= vColor.rgb;\n                #else\n                diffuseColor *= vColor;\n                #endif\n    \n                #include <alphamap_fragment>\n                #include <alphatest_fragment>\n                #include <specularmap_fragment>\n                ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n                // accumulation (baked indirect lighting only)\n                #ifdef USE_LIGHTMAP\n                    vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n                    reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n                #else\n                    reflectedLight.indirectDiffuse += vec3( 1.0 );\n                #endif\n                // modulation\n                #include <aomap_fragment>\n                reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n                vec3 outgoingLight = reflectedLight.indirectDiffuse;\n                #include <envmap_fragment>\n                gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n                #include <tonemapping_fragment>\n                #include <encodings_fragment>\n                #include <fog_fragment>\n                #include <premultiplied_alpha_fragment>\n                #include <dithering_fragment>\n    \n                #ifdef GRAYED\n                float grey = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));\n                gl_FragColor.rgb = vec3(grey, grey, grey);\n                #endif\n    \n                #ifdef COLOR_FILTER\n                vec4 col = gl_FragColor;\n                gl_FragColor.r = dot(col, _ColorMatrix[0]) + _ColorOffset.x;\n                gl_FragColor.g = dot(col, _ColorMatrix[1]) + _ColorOffset.y;\n                gl_FragColor.b = dot(col, _ColorMatrix[2]) + _ColorOffset.z;\n                gl_FragColor.a = dot(col, _ColorMatrix[3]) + _ColorOffset.w;\n                #endif\n            }\n            `;\n            this.name = \"ui-material\";\n            this.lights = false;\n            this.transparent = true;\n            this.depthTest = false;\n            this.side = THREE.DoubleSide;\n            this[\"isMeshBasicMaterial\"] = true;\n        }\n    }\n    fgui.NMaterial = NMaterial;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class NTexture {\n        constructor(texture, xScale, yScale) {\n            xScale = xScale || 1;\n            yScale = yScale || 1;\n            this._nativeTexture = texture;\n            this._root = this;\n            this.uvRect = new fgui.Rect(0, 0, xScale, yScale);\n            if (yScale < 0) {\n                this.uvRect.y = -yScale;\n                this.uvRect.height = yScale;\n            }\n            if (xScale < 0) {\n                this.uvRect.x = -xScale;\n                this.uvRect.width = xScale;\n            }\n            this.originalSize = texture ? new THREE.Vector2(texture.image.width, texture.image.height) : new THREE.Vector2(2, 2);\n            this.region = new fgui.Rect(0, 0, this.originalSize.x, this.originalSize.y);\n            this.offset = new THREE.Vector2(0, 0);\n        }\n        createSubTexture(region, rotated, offset, originalSize) {\n            let nt = new NTexture();\n            nt._root = this;\n            nt.rotated = rotated || false;\n            nt.region.copy(region);\n            nt.region.x += this.region.x;\n            nt.region.y += this.region.y;\n            nt.uvRect.set(nt.region.x * this.uvRect.width / this.width, 1 - nt.region.yMax * this.uvRect.height / this.height, nt.region.width * this.uvRect.width / this.width, nt.region.height * this.uvRect.height / this.height);\n            if (rotated) {\n                let tmp = nt.region.width;\n                nt.region.width = nt.region.height;\n                nt.region.height = tmp;\n                tmp = nt.uvRect.width;\n                nt.uvRect.width = nt.uvRect.height;\n                nt.uvRect.height = tmp;\n            }\n            if (originalSize)\n                nt.originalSize.copy(originalSize);\n            else\n                nt.originalSize.set(nt.region.width, nt.region.height);\n            if (offset)\n                nt.offset.copy(offset);\n            return nt;\n        }\n        get width() {\n            return this.region.width;\n        }\n        get height() {\n            return this.region.height;\n        }\n        get nativeTexture() {\n            return this._root == this ? this._nativeTexture : this._root.nativeTexture;\n        }\n        getDrawRect(drawRect) {\n            if (this.originalSize.x == this.region.width && this.originalSize.y == this.region.height)\n                return drawRect;\n            let sx = drawRect.width / this.originalSize.x;\n            let sy = drawRect.height / this.originalSize.y;\n            drawRect.x = this.offset.x * sx;\n            drawRect.y = this.offset.y * sy;\n            drawRect.width = this.region.width * sx;\n            drawRect.height = this.region.height * sy;\n            return drawRect;\n        }\n        getUV(uv) {\n            uv[0] = this.uvRect.position;\n            uv[1] = new THREE.Vector2(this.uvRect.x, this.uvRect.yMax);\n            uv[2] = new THREE.Vector2(this.uvRect.xMax, this.uvRect.yMax);\n            uv[3] = new THREE.Vector2(this.uvRect.xMax, this.uvRect.y);\n            if (this.rotated) {\n                let xMin = this.uvRect.xMin;\n                let yMin = this.uvRect.yMin;\n                let yMax = this.uvRect.yMax;\n                for (let i = 0; i < 4; i++) {\n                    let m = uv[i];\n                    let tmp = m.y;\n                    m.y = yMin + m.x - xMin;\n                    m.x = xMin + yMax - tmp;\n                }\n            }\n        }\n        get root() {\n            return this._root;\n        }\n        reload(nativeTexture) {\n            if (this._root != this)\n                throw new Error(\"Reload is not allow to call on none root NTexture.\");\n            if (this._nativeTexture && this._nativeTexture != nativeTexture)\n                this._nativeTexture.dispose();\n            this._nativeTexture = nativeTexture;\n            if (this._nativeTexture)\n                this.originalSize.set(nativeTexture.image.width, nativeTexture.image.height);\n            else\n                this.originalSize.set(0, 0);\n            this.region.set(0, 0, this.originalSize.x, this.originalSize.y);\n        }\n        dispose() {\n            if (this._root == this)\n                this._nativeTexture.dispose();\n        }\n    }\n    fgui.NTexture = NTexture;\n    fgui.EmptyTexture = new NTexture();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Shape extends fgui.DisplayObject {\n        constructor() {\n            super();\n            this._graphics = new fgui.NGraphics(this._obj3D);\n            this._graphics.texture = fgui.EmptyTexture;\n        }\n        drawRect(lineWidth, lineColor, fillColor) {\n            let mesh = this._graphics.getMeshFactory(fgui.RectMesh);\n            mesh.lineWidth = lineWidth;\n            mesh.lineColor = lineColor;\n            mesh.fillColor = fillColor;\n            this._graphics.setMeshDirty();\n            if (fillColor.a == 1) {\n                mesh.fillColor = null;\n                this._graphics.color = fillColor.getHex();\n            }\n            else\n                this._graphics.color = 0xFFFFFF;\n        }\n        drawRoundRect(lineWidth, lineColor, fillColor, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {\n            let mesh = this._graphics.getMeshFactory(fgui.RoundedRectMesh);\n            mesh.lineWidth = lineWidth;\n            mesh.lineColor = lineColor;\n            mesh.fillColor = fillColor;\n            mesh.topLeftRadius = topLeftRadius;\n            mesh.topRightRadius = topRightRadius;\n            mesh.bottomLeftRadius = bottomLeftRadius;\n            mesh.bottomRightRadius = bottomRightRadius;\n            this._graphics.setMeshDirty();\n            if (fillColor.a == 1) {\n                mesh.fillColor = null;\n                this._graphics.color = fillColor.getHex();\n            }\n            else\n                this._graphics.color = 0xFFFFFF;\n        }\n        drawEllipse(lineWidth, centerColor, lineColor, fillColor, startDegree, endDegree) {\n            let mesh = this._graphics.getMeshFactory(fgui.EllipseMesh);\n            mesh.lineWidth = lineWidth;\n            mesh.lineColor = lineColor;\n            mesh.fillColor = fillColor;\n            if (centerColor.equals(fillColor))\n                mesh.centerColor = null;\n            else\n                mesh.centerColor = centerColor;\n            mesh.startDegree = startDegree;\n            mesh.endDegreee = endDegree;\n            this._graphics.setMeshDirty();\n            if (fillColor.a == 1) {\n                mesh.fillColor = null;\n                this._graphics.color = fillColor.getHex();\n            }\n            else\n                this._graphics.color = 0xFFFFFF;\n        }\n        drawPolygon(points, fillColor, lineWidth, lineColor) {\n            let mesh = this._graphics.getMeshFactory(fgui.PolygonMesh);\n            mesh.points.length = 0;\n            mesh.points.push.apply(mesh.points, points);\n            mesh.fillColor = fillColor;\n            mesh.lineWidth = lineWidth;\n            mesh.lineColor = lineColor;\n            this._graphics.setMeshDirty();\n            if (fillColor.a == 1) {\n                mesh.fillColor = null;\n                this._graphics.color = fillColor.getHex();\n            }\n            else\n                this._graphics.color = 0xFFFFFF;\n        }\n        drawRegularPolygon(sides, lineWidth, centerColor, lineColor, fillColor, rotation, distances) {\n            let mesh = this._graphics.getMeshFactory(fgui.RegularPolygonMesh);\n            mesh.sides = sides;\n            mesh.lineWidth = lineWidth;\n            mesh.centerColor = centerColor;\n            mesh.lineColor = lineColor;\n            mesh.fillColor = fillColor;\n            mesh.rotation = rotation;\n            mesh.distances = distances;\n            this._graphics.setMeshDirty();\n            if (fillColor.a == 1) {\n                mesh.fillColor = null;\n                this._graphics.color = fillColor.getHex();\n            }\n            else\n                this._graphics.color = 0xFFFFFF;\n        }\n        clear() {\n            this._graphics.meshFactory = null;\n            this._graphics.setMeshDirty();\n        }\n        hitTest(context) {\n            if (!this._graphics.meshFactory)\n                return null;\n            let pt = context.getLocal(this);\n            let ht = this._graphics.meshFactory;\n            if ('hitTest' in ht)\n                return ht.hitTest(this._contentRect, pt.x, pt.y) ? this : null;\n            else if (this._contentRect.contains(pt))\n                return this;\n            else\n                return null;\n        }\n    }\n    fgui.Shape = Shape;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    fgui.UILayer = 1;\n    class Stage {\n        static init(renderer) {\n            init(renderer);\n        }\n        static set scene(value) {\n            _scene = value;\n        }\n        static get scene() {\n            return _scene;\n        }\n        static get domElement() {\n            return _canvas;\n        }\n        static get devicePixelRatio() {\n            return _devicePixelRatio;\n        }\n        static get camera() {\n            return _camera;\n        }\n        static set camera(value) {\n            _camera = value;\n        }\n        static get width() {\n            return _width;\n        }\n        static get height() {\n            return _height;\n        }\n        static get touchPos() {\n            return _touchPos;\n        }\n        static get touchTarget() {\n            return _touchTarget;\n        }\n        static get touchCount() {\n            return _touchCount;\n        }\n        static getTouchPos(touchId, ret) {\n            if (!ret)\n                ret = new THREE.Vector2();\n            if (touchId == null || touchId == -1)\n                ret.copy(_touchPos);\n            else {\n                let touch = getTouch(touchId);\n                if (touch)\n                    ret.set(touch.x, touch.y);\n                else\n                    ret.copy(_touchPos);\n            }\n            return ret;\n        }\n        static addTouchMonitor(touchId, target) {\n            let touch = getTouch(touchId);\n            if (touch.touchMonitors.indexOf(target) == -1)\n                touch.touchMonitors.push(target);\n        }\n        static removeTouchMonitor(target) {\n            for (let j = 0; j < 5; j++) {\n                let touch = _touches[j];\n                let i = touch.touchMonitors.indexOf(target);\n                if (i != -1)\n                    touch.touchMonitors[i] = null;\n            }\n        }\n        static cancelClick(touchId) {\n            for (let j = 0; j < 5; j++) {\n                let touch = _touches[j];\n                if (touch.touchId == touchId)\n                    touch.clickCancelled = true;\n            }\n        }\n        static update() {\n            this.disableMatrixValidation = true;\n            fgui.traverseUpdate(_scene, null, 1);\n            if (this.fontRebuilt) {\n                _scene.traverseVisible(obj => {\n                    let dobj = obj[\"$owner\"];\n                    if (dobj && ('redraw' in dobj))\n                        dobj.redraw();\n                });\n                this.fontRebuilt = false;\n            }\n            this.disableMatrixValidation = false;\n        }\n        static hitTest(x, y, forTouch) {\n            return hitTest(x, y, forTouch);\n        }\n        static setFocus(obj) {\n            setFocus(obj);\n        }\n    }\n    Stage.eventDispatcher = new fgui.EventDispatcher();\n    fgui.Stage = Stage;\n    class HitTestContext {\n        constructor() {\n            this.screenPt = new THREE.Vector3();\n        }\n        get camera() {\n            return this._camera;\n        }\n        set camera(value) {\n            this._camera = value;\n            this._ray = this._camera[\"$hitTestRay\"];\n            if (!this._ray)\n                this._camera[\"$hitTestRay\"] = this._ray = { origin: new THREE.Vector3(), direction: new THREE.Vector3() };\n            screenToWorld(this._camera, this.screenPt.x, this.screenPt.y, this._ray.origin, this._ray.direction);\n        }\n        get ray() {\n            return this._ray;\n        }\n        set ray(value) {\n            this._ray = value;\n        }\n        getLocal(obj) {\n            hit_tmp.copy(this._ray.origin);\n            obj.worldToLocal(hit_tmp, this._ray.direction);\n            hit_tmp2.set(hit_tmp.x, hit_tmp.y);\n            return hit_tmp2;\n        }\n    }\n    fgui.HitTestContext = HitTestContext;\n    const clickTestThreshold = 10;\n    var _camera;\n    var _scene;\n    var _touches;\n    var _touchTarget;\n    var _touchPos;\n    var _touchCount;\n    var _rollOverChain = [];\n    var _rollOutChain = [];\n    var _hitTestContext = new HitTestContext();\n    var _canvas;\n    var _width;\n    var _height;\n    var _offsetX;\n    var _offsetY;\n    var _touchscreen;\n    var _devicePixelRatio = 1;\n    var hit_tmp = new THREE.Vector3();\n    var hit_tmp2 = new THREE.Vector2();\n    function init(renderer) {\n        _canvas = renderer.domElement;\n        _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1000);\n        _camera.layers.set(fgui.UILayer);\n        _touchscreen = is_touch_enabled();\n        if (renderer instanceof THREE.WebGLRenderer)\n            _devicePixelRatio = renderer.getPixelRatio();\n        _touches = [];\n        for (let i = 0; i < 5; i++)\n            _touches.push(new TouchInfo());\n        if (!_touchscreen)\n            _touches[0].touchId = 0;\n        _touchCount = 0;\n        _touchPos = new THREE.Vector2();\n        if (_touchscreen) {\n            document.addEventListener('touchstart', ev => handleTouch(ev, 0), { passive: false });\n            document.addEventListener('touchend', ev => handleTouch(ev, 1), { passive: false });\n            document.addEventListener('touchmove', ev => handleTouch(ev, 2), { passive: false });\n            document.addEventListener('touchcancel', ev => handleTouch(ev, 3), { passive: false });\n        }\n        else {\n            document.addEventListener('mousedown', ev => handleMouse(ev, 0), { passive: false });\n            document.addEventListener('mouseup', ev => handleMouse(ev, 1), { passive: false });\n            document.addEventListener('mousemove', ev => handleMouse(ev, 2), { passive: false });\n        }\n        document.addEventListener('wheel', ev => handleWheel(ev), { passive: false });\n        window.addEventListener('resize', onWindowResize, false);\n        _offsetX = _offsetY = 0;\n        var element = _canvas;\n        var style = getComputedStyle(element, null);\n        _offsetY += parseInt(style.getPropertyValue(\"padding-top\"), 10);\n        _offsetX += parseInt(style.getPropertyValue(\"padding-left\"), 10);\n        do {\n            _offsetX += element.offsetLeft;\n            _offsetY += element.offsetTop;\n            style = getComputedStyle(element, null);\n            _offsetX += parseInt(style.getPropertyValue(\"border-left-width\"), 10);\n            _offsetY += parseInt(style.getPropertyValue(\"border-top-width\"), 10);\n        } while (element = element.offsetParent);\n        onWindowResize();\n    }\n    function onWindowResize(evt) {\n        _width = _canvas.clientWidth;\n        _height = _canvas.clientHeight;\n        let aspectRatio = _width / _height;\n        if (_camera instanceof THREE.OrthographicCamera) {\n            let cameraSize = _height / 2;\n            _camera.left = -cameraSize * aspectRatio;\n            _camera.right = cameraSize * aspectRatio;\n            _camera.top = cameraSize;\n            _camera.bottom = -cameraSize;\n            _camera.position.x = cameraSize * aspectRatio;\n            _camera.position.y = -cameraSize;\n            _camera.position.z = 0;\n            _camera.updateProjectionMatrix();\n        }\n        else if (_camera instanceof THREE.PerspectiveCamera) {\n            _camera.aspect = window.innerWidth / window.innerHeight;\n            _camera.updateProjectionMatrix();\n        }\n        if (activeTextInput)\n            setFocus(null);\n        if (evt)\n            Stage.eventDispatcher.dispatchEvent(fgui.DisplayObjectEvent.XY_CHANGED);\n    }\n    function is_touch_enabled() {\n        return ('ontouchstart' in window) ||\n            (navigator.maxTouchPoints > 0) ||\n            (navigator.msMaxTouchPoints > 0);\n    }\n    function handleMouse(ev, type) {\n        if (!activeTextInput || !activeTextInput.stage)\n            ev.preventDefault();\n        _touchPos.set(ev.pageX - _offsetX, ev.pageY - _offsetY);\n        let touch = _touches[0];\n        touch.shiftKey = ev.shiftKey;\n        touch.ctrlKey = ev.ctrlKey;\n        touch.target = _touchTarget = hitTest(_touchPos.x, _touchPos.y, true);\n        if (_touchPos.x != touch.x || _touchPos.y != touch.y) {\n            touch.x = _touchPos.x;\n            touch.y = _touchPos.y;\n            touch.move();\n        }\n        if (touch.lastRollOver != touch.target)\n            handleRollOver(touch);\n        if (type == 0) {\n            if (!touch.began) {\n                _touchCount = 1;\n                touch.begin();\n                touch.button = ev.button;\n                setFocus(touch.target);\n                setLastInput(touch);\n                if (touch.target)\n                    bubbleEvent(touch.target.obj3D, fgui.InteractiveEvents.Down);\n            }\n        }\n        else if (type == 1) {\n            if (touch.began) {\n                _touchCount = 0;\n                touch.end();\n                let clickTarget = touch.clickTest();\n                if (clickTarget) {\n                    setLastInput(touch);\n                    if (ev.button == 1 || ev.button == 2)\n                        bubbleEvent(clickTarget.obj3D, fgui.InteractiveEvents.RightClick);\n                    else\n                        bubbleEvent(clickTarget.obj3D, fgui.InteractiveEvents.Click);\n                }\n                touch.button = -1;\n            }\n        }\n    }\n    function handleWheel(ev) {\n        if (!activeTextInput || !activeTextInput.stage)\n            ev.preventDefault();\n        _touchPos.set(ev.pageX - _offsetX, ev.pageY - _offsetY);\n        let touch = _touches[0];\n        if (_touchscreen) {\n            touch.shiftKey = ev.shiftKey;\n            touch.ctrlKey = ev.ctrlKey;\n            touch.target = _touchTarget = hitTest(_touchPos.x, _touchPos.y, true);\n        }\n        if (_touchTarget != null) {\n            touch.mouseWheelDelta = ev.deltaY;\n            setLastInput(touch);\n            bubbleEvent(_touchTarget.obj3D, fgui.DisplayObjectEvent.MOUSE_WHEEL);\n            touch.mouseWheelDelta = 0;\n        }\n    }\n    function getTouch(touchId) {\n        for (let j = 0; j < 5; j++) {\n            let touch = _touches[j];\n            if (touchId == -1 && touch.touchId != -1\n                || touchId != -1 && touch.touchId == touchId)\n                return touch;\n        }\n        return null;\n    }\n    function handleTouch(ev, type) {\n        if (!activeTextInput || !activeTextInput.stage)\n            ev.preventDefault();\n        let touches = ev.changedTouches;\n        for (let i = 0; i < touches.length; ++i) {\n            let uTouch = touches[i];\n            _touchPos.set(uTouch.pageX - _offsetX, uTouch.pageY - _offsetY);\n            let touch;\n            let free;\n            for (let j = 0; j < 5; j++) {\n                if (_touches[j].touchId == uTouch.identifier) {\n                    touch = _touches[j];\n                    break;\n                }\n                if (_touches[j].touchId == -1)\n                    free = _touches[j];\n            }\n            if (!touch) {\n                touch = free;\n                if (!touch || type != 0)\n                    continue;\n                touch.touchId = uTouch.identifier;\n            }\n            touch.shiftKey = ev.shiftKey;\n            touch.ctrlKey = ev.ctrlKey;\n            touch.target = _touchTarget = hitTest(_touchPos.x, _touchPos.y, true);\n            if (touch.x != _touchPos.x || touch.y != _touchPos.y) {\n                touch.x = _touchPos.x;\n                touch.y = _touchPos.y;\n                if (touch.began)\n                    touch.move();\n            }\n            if (touch.lastRollOver != touch.target)\n                handleRollOver(touch);\n            if (type == 0) {\n                if (!touch.began) {\n                    _touchCount++;\n                    touch.begin();\n                    touch.button = 0;\n                    setFocus(touch.target);\n                    setLastInput(touch);\n                    if (touch.target)\n                        bubbleEvent(touch.target.obj3D, fgui.InteractiveEvents.Down);\n                }\n            }\n            else if (type == 1 || type == 3) {\n                if (touch.began) {\n                    _touchCount--;\n                    touch.end();\n                    if (type != 3) {\n                        let clickTarget = touch.clickTest();\n                        if (clickTarget != null) {\n                            setLastInput(touch);\n                            bubbleEvent(clickTarget.obj3D, fgui.InteractiveEvents.Click);\n                        }\n                    }\n                    touch.target = null;\n                    handleRollOver(touch);\n                    touch.touchId = -1;\n                }\n            }\n        }\n    }\n    function handleRollOver(touch) {\n        _rollOverChain.length = 0;\n        _rollOutChain.length = 0;\n        if (touch.lastRollOver) {\n            _rollOutChain.push(touch.lastRollOver);\n            touch.lastRollOver.obj3D.traverseAncestors(obj => {\n                let dobj = obj[\"$owner\"];\n                if (dobj)\n                    _rollOutChain.push(dobj);\n            });\n        }\n        touch.lastRollOver = touch.target;\n        if (touch.target) {\n            let obj = touch.target.obj3D;\n            while (obj) {\n                let dobj = obj[\"$owner\"];\n                if (dobj) {\n                    let i = _rollOutChain.indexOf(dobj);\n                    if (i != -1) {\n                        _rollOutChain.splice(i, _rollOutChain.length - i);\n                        break;\n                    }\n                    _rollOverChain.push(dobj);\n                }\n                obj = obj.parent;\n            }\n        }\n        let cnt = _rollOutChain.length;\n        if (cnt > 0) {\n            for (let i = 0; i < cnt; i++) {\n                let element = _rollOutChain[i];\n                if (element.stage)\n                    element.dispatchEvent(fgui.RollEvent.RollOut, null);\n            }\n            _rollOutChain.length = 0;\n        }\n        cnt = _rollOverChain.length;\n        if (cnt > 0) {\n            for (let i = 0; i < cnt; i++) {\n                let element = _rollOverChain[i];\n                if (element.stage)\n                    element.dispatchEvent(fgui.RollEvent.RollOver, null);\n            }\n            _rollOverChain.length = 0;\n        }\n        ;\n    }\n    function hitTest(x, y, forTouch) {\n        if (!_hitTestContext)\n            _hitTestContext = new HitTestContext();\n        Stage.disableMatrixValidation = true;\n        _hitTestContext.screenPt.set(x, y, 0);\n        _hitTestContext.camera = _camera;\n        _hitTestContext.forTouch = forTouch != null ? forTouch : true;\n        let ret = fgui.traverseHitTest(_scene, _hitTestContext);\n        Stage.disableMatrixValidation = false;\n        return ret;\n    }\n    var activeTextInput;\n    function setFocus(obj) {\n        if (activeTextInput == obj)\n            return;\n        if (activeTextInput) {\n            let t = activeTextInput;\n            activeTextInput = null;\n            t.dispatchEvent(\"focus_out\");\n        }\n        if (!obj || !obj[\"isInput\"])\n            return;\n        activeTextInput = obj;\n        activeTextInput.dispatchEvent(fgui.TextEvent.FocusIn);\n    }\n    var s_v3 = new THREE.Vector3();\n    function screenToWorld(camera, x, y, outPt, outDir) {\n        outPt.set((x / _width) * 2 - 1, -(y / _height) * 2 + 1, 0);\n        outPt.unproject(camera);\n        if (camera[\"isPerspectiveCamera\"]) {\n            s_v3.setFromMatrixPosition(camera.matrixWorld);\n            outDir.copy(outPt).sub(s_v3).normalize();\n            outDir.multiplyScalar(-1);\n        }\n        else\n            outDir.set(0, 0, 1);\n    }\n    fgui.screenToWorld = screenToWorld;\n    function worldToScreen(camera, input, output) {\n        s_v3.copy(input);\n        s_v3.project(camera);\n        output.set((s_v3.x + 1) / 2 * _width, (1 - s_v3.y) / 2 * _height);\n    }\n    fgui.worldToScreen = worldToScreen;\n    function setLastInput(touch) {\n        fgui.lastInput.touchId = touch.touchId;\n        fgui.lastInput.x = touch.x;\n        fgui.lastInput.y = touch.y;\n        fgui.lastInput.clickCount = touch.clickCount;\n        fgui.lastInput.mouseWheelDelta = touch.mouseWheelDelta;\n        fgui.lastInput.button = touch.button;\n        fgui.lastInput.holdTime = touch.holdTime;\n        fgui.lastInput.ctrlKey = touch.ctrlKey;\n        fgui.lastInput.shiftKey = touch.shiftKey;\n        fgui.lastInput.commandKey = touch.commandKey;\n    }\n    class TouchInfo {\n        constructor() {\n            this.downTargets = new Array();\n            this.touchMonitors = new Array();\n            this.reset();\n        }\n        reset() {\n            this.touchId = -1;\n            this.x = 0;\n            this.y = 0;\n            this.clickCount = 0;\n            this.button = -1;\n            this.mouseWheelDelta = 0;\n            this.lastClickTime = 0;\n            this.began = false;\n            this.target = null;\n            this.downTargets.length = 0;\n            this.lastRollOver = null;\n            this.clickCancelled = false;\n            this.touchMonitors.length = 0;\n        }\n        begin() {\n            this.began = true;\n            this.clickCancelled = false;\n            this.downX = this.x;\n            this.downY = this.y;\n            this.downTime = performance.now();\n            this.downFrame = fgui.Timers.frameCount;\n            this.holdTime = 0;\n            this.downTargets.length = 0;\n            if (this.target) {\n                this.downTargets.push(this.target);\n                this.target.obj3D.traverseAncestors(obj => {\n                    let dobj = obj[\"$owner\"];\n                    if (dobj)\n                        this.downTargets.push(dobj);\n                });\n            }\n        }\n        move() {\n            if (this.began)\n                this.holdTime = (fgui.Timers.frameCount - this.downFrame) == 1 ? (1 / 60) : (performance.now() - this.downTime);\n            setLastInput(this);\n            if (Math.abs(this.x - this.downX) > 50 || Math.abs(this.y - this.downY) > 50)\n                this.clickCancelled = true;\n            if (this.touchMonitors.length > 0) {\n                let len = this.touchMonitors.length;\n                for (let i = 0; i < len; i++) {\n                    let e = this.touchMonitors[i];\n                    if ((e instanceof fgui.DisplayObject) && !e.stage)\n                        this.touchMonitors[i] = null;\n                }\n                bubbleEvent(null, fgui.InteractiveEvents.Move, null, this.touchMonitors);\n            }\n        }\n        end() {\n            this.began = false;\n            let now = performance.now();\n            if (this.downTargets.length == 0\n                || this.clickCancelled\n                || Math.abs(this.x - this.downX) > clickTestThreshold\n                || Math.abs(this.y - this.downY) > clickTestThreshold) {\n                this.clickCancelled = true;\n                this.lastClickTime = 0;\n                this.clickCount = 1;\n            }\n            else {\n                if (now - this.lastClickTime < 0.35\n                    && Math.abs(this.x - this.lastClickX) < clickTestThreshold\n                    && Math.abs(this.y - this.lastClickY) < clickTestThreshold\n                    && this.lastClickButton == this.button) {\n                    if (this.clickCount == 2)\n                        this.clickCount = 1;\n                    else\n                        this.clickCount++;\n                }\n                else\n                    this.clickCount = 1;\n                this.lastClickTime = now;\n                this.lastClickX = this.x;\n                this.lastClickY = this.y;\n                this.lastClickButton = this.button;\n            }\n            this.holdTime = (fgui.Timers.frameCount - this.downFrame) == 1 ? (1 / 60) : (now - this.downTime);\n            setLastInput(this);\n            let bubbleFrom = this.target ? this.target.obj3D : Stage.scene;\n            if (this.touchMonitors.length > 0) {\n                let len = this.touchMonitors.length;\n                for (let i = 0; i < len; i++) {\n                    let e = this.touchMonitors[i];\n                    if ((e instanceof fgui.DisplayObject) && !e.stage)\n                        this.touchMonitors[i] = null;\n                }\n                bubbleEvent(bubbleFrom, fgui.InteractiveEvents.Up, null, this.touchMonitors);\n                this.touchMonitors.length = 0;\n            }\n            else\n                bubbleEvent(bubbleFrom, fgui.InteractiveEvents.Up);\n        }\n        clickTest() {\n            if (this.clickCancelled) {\n                this.downTargets.length = 0;\n                return null;\n            }\n            let obj = this.downTargets[0];\n            if (obj.stage) {\n                this.downTargets.length = 0;\n                return obj;\n            }\n            obj = this.target;\n            while (obj) {\n                let i = this.downTargets.indexOf(obj);\n                if (i != -1 && obj.stage)\n                    break;\n                obj = obj.parent ? obj.parent[\"$owner\"] : null;\n            }\n            this.downTargets.length = 0;\n            return obj;\n        }\n    }\n    function broadcastEvent(p, type, data) {\n        p = p || Stage.scene;\n        let ev = fgui.EventPool.borrow();\n        ev._type = type;\n        ev.data = data;\n        let arr = ev._callChain;\n        p.traverseVisible(obj => {\n            let dobj = obj[\"$owner\"];\n            if (dobj)\n                arr.push(dobj);\n        });\n        arr.forEach(obj => {\n            let col = obj._listeners[type];\n            if (col) {\n                if (col.captures.length > 0)\n                    obj._dispatch(col, ev, true);\n                if (col.callbacks.length > 0)\n                    obj._dispatch(col, ev, false);\n            }\n        });\n        arr.length = 0;\n        fgui.EventPool.returns(ev);\n    }\n    fgui.broadcastEvent = broadcastEvent;\n    function bubbleEvent(p, type, data, addChain) {\n        p = p || Stage.scene;\n        let ev = fgui.EventPool.borrow();\n        ev._type = type;\n        ev.data = data;\n        ev._initiator = p[\"$owner\"];\n        let arr = ev._callChain;\n        if (ev.initiator)\n            arr.push(ev.initiator);\n        p.traverseAncestors(obj => {\n            let dobj = obj[\"$owner\"];\n            if (dobj)\n                arr.push(dobj);\n        });\n        for (let i = arr.length - 1; i >= 0; i--) {\n            let obj = arr[i];\n            let col = obj._listeners[type];\n            if (col && col.captures.length > 0) {\n                obj._dispatch(col, ev, true);\n                if (ev._touchCapture) {\n                    ev._touchCapture = false;\n                    if (type == fgui.InteractiveEvents.Down)\n                        Stage.addTouchMonitor(ev.input.touchId, obj);\n                }\n            }\n        }\n        if (!ev._stopsPropagation) {\n            for (let i = 0; i < arr.length; i++) {\n                let obj = arr[i];\n                let col = obj._listeners[type];\n                if (col && col.callbacks.length > 0) {\n                    obj._dispatch(col, ev, false);\n                    if (ev._touchCapture) {\n                        ev._touchCapture = false;\n                        if (type == fgui.InteractiveEvents.Down)\n                            Stage.addTouchMonitor(ev.input.touchId, obj);\n                    }\n                    if (ev._stopsPropagation)\n                        break;\n                }\n            }\n            if (addChain) {\n                for (let i = 0; i < addChain.length; i++) {\n                    let obj = addChain[i];\n                    if (obj && arr.indexOf(obj) == -1) {\n                        let col = obj._listeners[type];\n                        if (col) {\n                            if (col.captures.length > 0)\n                                obj._dispatch(col, ev, true);\n                            if (col.callbacks.length > 0)\n                                obj._dispatch(col, ev, false);\n                        }\n                    }\n                }\n            }\n        }\n        arr.length = 0;\n        fgui.EventPool.returns(ev);\n    }\n    fgui.bubbleEvent = bubbleEvent;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class PixelHitTestData {\n        load(ba) {\n            ba.readInt();\n            this.pixelWidth = ba.readInt();\n            this.scale = 1.0 / ba.readByte();\n            let len = ba.readInt();\n            this.pixels = new Uint8Array(ba.data, ba.pos, len);\n            ba.skip(len);\n        }\n    }\n    fgui.PixelHitTestData = PixelHitTestData;\n    class PixelHitTest {\n        constructor(data, offsetX, offsetY, sourceWidth, sourceHeight) {\n            this._data = data;\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            this.sourceWidth = sourceWidth;\n            this.sourceHeight = sourceHeight;\n        }\n        hitTest(contentRect, x, y) {\n            if (!contentRect.contains(x, y))\n                return false;\n            let data = this._data;\n            x = Math.floor((x * this.sourceWidth / contentRect.width - this.offsetX) * data.scale);\n            y = Math.floor((y * this.sourceHeight / contentRect.height - this.offsetY) * data.scale);\n            if (x < 0 || y < 0 || x >= data.pixelWidth)\n                return false;\n            let pos = y * data.pixelWidth + x;\n            let pos2 = Math.floor(pos / 8);\n            let pos3 = pos % 8;\n            if (pos2 >= 0 && pos2 < data.pixels.length)\n                return ((data.pixels[pos2] >> pos3) & 0x1) > 0;\n            else\n                return false;\n        }\n    }\n    fgui.PixelHitTest = PixelHitTest;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_vec2 = new THREE.Vector2();\n    class ShapeHitTest {\n        constructor(obj) {\n            this.shape = obj;\n        }\n        hitTest(contentRect, x, y) {\n            if (!this.shape.graphics)\n                return false;\n            if (this.shape.parent) {\n                let p = this.shape.parent[\"$owner\"];\n                if (p) {\n                    p.transformPoint(x, y, this.shape.obj3D, s_vec2);\n                    x = s_vec2.x;\n                    y = s_vec2.y;\n                }\n            }\n            let ht = this.shape.graphics.meshFactory;\n            if (!('hitTest' in ht))\n                return false;\n            return ht.hitTest(contentRect, x, y);\n        }\n    }\n    fgui.ShapeHitTest = ShapeHitTest;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class CompositeMesh {\n        constructor() {\n            this.elements = [];\n            this.activeIndex = -1;\n        }\n        onPopulateMesh(vb) {\n            let cnt = this.elements.length;\n            if (cnt == 1)\n                this.elements[0].onPopulateMesh(vb);\n            else {\n                let vb2 = fgui.VertexBuffer.begin(vb);\n                for (let i = 0; i < cnt; i++) {\n                    if (this.activeIndex == -1 || i == this.activeIndex) {\n                        vb2.clear();\n                        this.elements[i].onPopulateMesh(vb2);\n                        vb.append(vb2);\n                    }\n                }\n                vb2.end();\n            }\n        }\n        hitTest(contentRect, x, y) {\n            if (!contentRect.contains(x, y))\n                return false;\n            let flag = false;\n            let cnt = this.elements.length;\n            for (let i = 0; i < cnt; i++) {\n                if (this.activeIndex == -1 || i == this.activeIndex) {\n                    let ht = this.elements[i];\n                    if ('hitTest' in ht) {\n                        if (ht.hitTest(contentRect, x, y))\n                            return true;\n                    }\n                    else\n                        flag = true;\n                }\n            }\n            return flag;\n        }\n    }\n    fgui.CompositeMesh = CompositeMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    const SECTOR_CENTER_TRIANGLES = [\n        0, 4, 1,\n        0, 3, 4,\n        0, 2, 3,\n        0, 8, 5,\n        0, 7, 8,\n        0, 6, 7,\n        6, 5, 2,\n        2, 1, 6\n    ];\n    var s_v3 = new THREE.Vector3();\n    class EllipseMesh {\n        constructor() {\n            this.lineColor = new fgui.Color4();\n            this.lineWidth = 1;\n            this.startDegree = 0;\n            this.endDegreee = 360;\n        }\n        onPopulateMesh(vb) {\n            let rect = this.drawRect ? this.drawRect : vb.contentRect;\n            let color = this.fillColor ? this.fillColor : vb.vertexColor;\n            let lineColor = this.lineColor;\n            let sectionStart = fgui.clamp(this.startDegree, 0, 360);\n            let sectionEnd = fgui.clamp(this.endDegreee, 0, 360);\n            let clipped = sectionStart > 0 || sectionEnd < 360;\n            sectionStart = sectionStart * Math.PI / 180;\n            sectionEnd = sectionEnd * Math.PI / 180;\n            let enterColor = this.centerColor ? this.centerColor : color;\n            let radiusX = rect.width / 2;\n            let radiusY = rect.height / 2;\n            let sides = Math.ceil(Math.PI * (radiusX + radiusY) / 4);\n            sides = fgui.clamp(sides, 40, 800);\n            let angleDelta = 2 * Math.PI / sides;\n            let angle = 0;\n            let lineAngle = 0;\n            if (this.lineWidth > 0 && clipped) {\n                lineAngle = this.lineWidth / Math.max(radiusX, radiusY);\n                sectionStart += lineAngle;\n                sectionEnd -= lineAngle;\n            }\n            let vpos = vb.currentVertCount;\n            let centerX = rect.x + radiusX;\n            let centerY = rect.y + radiusY;\n            vb.addVert(centerX, centerY, 0, enterColor);\n            for (let i = 0; i < sides; i++) {\n                if (angle < sectionStart)\n                    angle = sectionStart;\n                else if (angle > sectionEnd)\n                    angle = sectionEnd;\n                let vx = Math.cos(angle) * (radiusX - this.lineWidth) + centerX;\n                let vy = Math.sin(angle) * (radiusY - this.lineWidth) + centerY;\n                vb.addVert(vx, vy, 0, color);\n                if (this.lineWidth > 0) {\n                    vb.addVert(vx, vy, 0, lineColor);\n                    vb.addVert(Math.cos(angle) * radiusX + centerX, Math.sin(angle) * radiusY + centerY, 0, lineColor);\n                }\n                angle += angleDelta;\n            }\n            if (this.lineWidth > 0) {\n                let cnt = sides * 3;\n                for (let i = 0; i < cnt; i += 3) {\n                    if (i != cnt - 3) {\n                        vb.addTriangle(0, i + 4, i + 1);\n                        vb.addTriangle(i + 5, i + 3, i + 2);\n                        vb.addTriangle(i + 3, i + 5, i + 6);\n                    }\n                    else if (!clipped) {\n                        vb.addTriangle(0, 1, i + 1);\n                        vb.addTriangle(2, i + 3, i + 2);\n                        vb.addTriangle(i + 3, 2, 3);\n                    }\n                    else {\n                        vb.addTriangle(0, i + 1, i + 1);\n                        vb.addTriangle(i + 2, i + 3, i + 2);\n                        vb.addTriangle(i + 3, i + 2, i + 3);\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < sides; i++) {\n                    if (i != sides - 1)\n                        vb.addTriangle(0, i + 2, i + 1);\n                    else if (!clipped)\n                        vb.addTriangle(0, 1, i + 1);\n                    else\n                        vb.addTriangle(0, i + 1, i + 1);\n                }\n            }\n            if (this.lineWidth > 0 && clipped) {\n                vb.addVert(radiusX, radiusY, 0, lineColor);\n                let centerRadius = this.lineWidth * 0.5;\n                sectionStart -= lineAngle;\n                angle = sectionStart + lineAngle * 0.5 + Math.PI * 0.5;\n                vb.addVert(Math.cos(angle) * centerRadius + radiusX, Math.sin(angle) * centerRadius + radiusY, 0, lineColor);\n                angle -= Math.PI;\n                vb.addVert(Math.cos(angle) * centerRadius + radiusX, Math.sin(angle) * centerRadius + radiusY, 0, lineColor);\n                vb.addVert(Math.cos(sectionStart) * radiusX + radiusX, Math.sin(sectionStart) * radiusY + radiusY, 0, lineColor);\n                vb.getPosition(vpos + 3, s_v3);\n                vb.addVert(s_v3.x, s_v3.y, s_v3.z, lineColor);\n                sectionEnd += lineAngle;\n                angle = sectionEnd - lineAngle * 0.5 + Math.PI * 0.5;\n                vb.addVert(Math.cos(angle) * centerRadius + radiusX, Math.sin(angle) * centerRadius + radiusY, 0, lineColor);\n                angle -= Math.PI;\n                vb.addVert(Math.cos(angle) * centerRadius + radiusX, Math.sin(angle) * centerRadius + radiusY, 0, lineColor);\n                vb.getPosition(vpos + sides * 3, s_v3);\n                vb.addVert(s_v3.x, s_v3.y, s_v3.z, lineColor);\n                vb.addVert(Math.cos(sectionEnd) * radiusX + radiusX, Math.sin(sectionEnd) * radiusY + radiusY, 0, lineColor);\n                vb.addTriangles(sides * 3 + 1, SECTOR_CENTER_TRIANGLES);\n            }\n        }\n        hitTest(contentRect, x, y) {\n            if (!contentRect.contains(x, y))\n                return false;\n            let radiusX = contentRect.width * 0.5;\n            let raduisY = contentRect.height * 0.5;\n            x = x - radiusX - contentRect.x;\n            y = y - raduisY - contentRect.y;\n            if (Math.pow(x / radiusX, 2) + Math.pow(y / raduisY, 2) < 1) {\n                if (this.startDegree != 0 || this.endDegreee != 360) {\n                    let deg = Math.atan2(y, x) * 180 / Math.PI;\n                    if (deg < 0)\n                        deg += 360;\n                    return deg >= this.startDegree && deg <= this.endDegreee;\n                }\n                else\n                    return true;\n            }\n            return false;\n        }\n    }\n    fgui.EllipseMesh = EllipseMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class FillMesh {\n        constructor() {\n            this.origin = 0;\n            this.amount = 1;\n            this.clockwise = true;\n        }\n        onPopulateMesh(vb) {\n            let amount = fgui.clamp01(this.amount);\n            switch (this.method) {\n                case fgui.FillMethod.Horizontal:\n                    fillHorizontal(vb, vb.contentRect, this.origin, amount);\n                    break;\n                case fgui.FillMethod.Vertical:\n                    fillVertical(vb, vb.contentRect, this.origin, amount);\n                    break;\n                case fgui.FillMethod.Radial90:\n                    fillRadial90(vb, vb.contentRect, this.origin, amount, this.clockwise);\n                    break;\n                case fgui.FillMethod.Radial180:\n                    fillRadial180(vb, vb.contentRect, this.origin, amount, this.clockwise);\n                    break;\n                case fgui.FillMethod.Radial360:\n                    fillRadial360(vb, vb.contentRect, this.origin, amount, this.clockwise);\n                    break;\n            }\n        }\n    }\n    fgui.FillMesh = FillMesh;\n    var s_vec3 = new THREE.Vector3();\n    var s_rect = new fgui.Rect();\n    function fillHorizontal(vb, vertRect, origin, amount) {\n        s_rect.copy(vertRect);\n        vertRect = s_rect;\n        let a = vertRect.width * amount;\n        if (origin == fgui.FillOrigin.Right || origin == fgui.FillOrigin.Bottom)\n            vertRect.x += (vertRect.width - a);\n        vertRect.width = a;\n        vb.addQuad(vertRect);\n        vb.addTriangles();\n    }\n    function fillVertical(vb, vertRect, origin, amount) {\n        s_rect.copy(vertRect);\n        vertRect = s_rect;\n        let a = vertRect.height * amount;\n        if (origin == fgui.FillOrigin.Right || origin == fgui.FillOrigin.Bottom)\n            vertRect.y += (vertRect.height - a);\n        vertRect.height = a;\n        vb.addQuad(vertRect);\n        vb.addTriangles();\n    }\n    function fillRadial90(vb, vertRect, origin, amount, clockwise) {\n        let flipX = origin == fgui.FillOrigin.TopRight || origin == fgui.FillOrigin.BottomRight;\n        let flipY = origin == fgui.FillOrigin.BottomLeft || origin == fgui.FillOrigin.BottomRight;\n        if (flipX != flipY)\n            clockwise = !clockwise;\n        let ratio = clockwise ? amount : (1 - amount);\n        let tan = Math.tan(Math.PI * 0.5 * ratio);\n        let thresold = false;\n        if (ratio != 1)\n            thresold = (vertRect.height / vertRect.width - tan) > 0;\n        if (!clockwise)\n            thresold = !thresold;\n        let x = vertRect.x + (ratio == 0 ? Number.POSITIVE_INFINITY : (vertRect.height / tan));\n        let y = vertRect.y + (ratio == 1 ? Number.POSITIVE_INFINITY : (vertRect.width * tan));\n        let x2 = x;\n        let y2 = y;\n        if (flipX)\n            x2 = vertRect.width - x;\n        if (flipY)\n            y2 = vertRect.height - y;\n        let xMin = flipX ? (vertRect.width - vertRect.x) : vertRect.xMin;\n        let yMin = flipY ? (vertRect.height - vertRect.y) : vertRect.yMin;\n        let xMax = flipX ? -vertRect.x : vertRect.xMax;\n        let yMax = flipY ? -vertRect.y : vertRect.yMax;\n        vb.addVert(xMin, yMin, 0);\n        if (clockwise)\n            vb.addVert(xMax, yMin, 0);\n        if (y > vertRect.yMax) {\n            if (thresold)\n                vb.addVert(x2, yMax, 0);\n            else\n                vb.addVert(xMax, yMax, 0);\n        }\n        else\n            vb.addVert(xMax, y2, 0);\n        if (x > vertRect.xMax) {\n            if (thresold)\n                vb.addVert(xMax, y2, 0);\n            else\n                vb.addVert(xMax, yMax, 0);\n        }\n        else\n            vb.addVert(x2, yMax, 0);\n        if (!clockwise)\n            vb.addVert(xMin, yMax, 0);\n        if (flipX == flipY) {\n            vb.addTriangle(0, 2, 1);\n            vb.addTriangle(0, 3, 2);\n        }\n        else {\n            vb.addTriangle(2, 0, 1);\n            vb.addTriangle(3, 0, 2);\n        }\n    }\n    var s_rect_180 = new fgui.Rect();\n    function fillRadial180(vb, vertRect, origin, amount, clockwise) {\n        s_rect_180.copy(vertRect);\n        vertRect = s_rect_180;\n        switch (origin) {\n            case fgui.FillOrigin.Top:\n                if (amount <= 0.5) {\n                    vertRect.width /= 2;\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.TopLeft : fgui.FillOrigin.TopRight, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-4, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.width /= 2;\n                    if (!clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.TopRight : fgui.FillOrigin.TopLeft, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    else\n                        vertRect.x -= vertRect.width;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Bottom:\n                if (amount <= 0.5) {\n                    vertRect.width /= 2;\n                    if (!clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.BottomRight : fgui.FillOrigin.BottomLeft, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-4, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.width /= 2;\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.BottomLeft : fgui.FillOrigin.BottomRight, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.x -= vertRect.width;\n                    else\n                        vertRect.x += vertRect.width;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Left:\n                if (amount <= 0.5) {\n                    vertRect.height /= 2;\n                    if (!clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.BottomLeft : fgui.FillOrigin.TopLeft, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-4, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.height /= 2;\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.TopLeft : fgui.FillOrigin.BottomLeft, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.y -= vertRect.height;\n                    else\n                        vertRect.y += vertRect.height;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Right:\n                if (amount <= 0.5) {\n                    vertRect.height /= 2;\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.TopRight : fgui.FillOrigin.BottomRight, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-4, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.height /= 2;\n                    if (!clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial90(vb, vertRect, clockwise ? fgui.FillOrigin.BottomRight : fgui.FillOrigin.TopRight, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    else\n                        vertRect.y -= vertRect.height;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n        }\n    }\n    var s_rect_360 = new fgui.Rect();\n    function fillRadial360(vb, vertRect, origin, amount, clockwise) {\n        s_rect_360.copy(vertRect);\n        vertRect = s_rect_360;\n        switch (origin) {\n            case fgui.FillOrigin.Top:\n                if (amount < 0.5) {\n                    vertRect.width /= 2;\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Left : fgui.FillOrigin.Right, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-8, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.width /= 2;\n                    if (!clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Right : fgui.FillOrigin.Left, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    else\n                        vertRect.x -= vertRect.width;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Bottom:\n                if (amount < 0.5) {\n                    vertRect.width /= 2;\n                    if (!clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Right : fgui.FillOrigin.Left, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-8, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.width /= 2;\n                    if (clockwise)\n                        vertRect.x += vertRect.width;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Left : fgui.FillOrigin.Right, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.x -= vertRect.width;\n                    else\n                        vertRect.x += vertRect.width;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Left:\n                if (amount < 0.5) {\n                    vertRect.height /= 2;\n                    if (!clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Bottom : fgui.FillOrigin.Top, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-8, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.height /= 2;\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Top : fgui.FillOrigin.Bottom, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.y -= vertRect.height;\n                    else\n                        vertRect.y += vertRect.height;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n            case fgui.FillOrigin.Right:\n                if (amount < 0.5) {\n                    vertRect.height /= 2;\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Top : fgui.FillOrigin.Bottom, amount / 0.5, clockwise);\n                    let vec = vb.getPosition(-8, s_vec3);\n                    s_rect.set(vec.x, vec.y, 0, 0);\n                    vb.addQuad(s_rect);\n                    vb.addTriangles(-4);\n                }\n                else {\n                    vertRect.height /= 2;\n                    if (!clockwise)\n                        vertRect.y += vertRect.height;\n                    fillRadial180(vb, vertRect, clockwise ? fgui.FillOrigin.Bottom : fgui.FillOrigin.Top, (amount - 0.5) / 0.5, clockwise);\n                    if (clockwise)\n                        vertRect.y += vertRect.height;\n                    else\n                        vertRect.y -= vertRect.height;\n                    vb.addQuad(vertRect);\n                    vb.addTriangles(-4);\n                }\n                break;\n        }\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var sRestIndices = [];\n    var a = new THREE.Vector2();\n    var b = new THREE.Vector2();\n    var c = new THREE.Vector2();\n    var p = new THREE.Vector2();\n    var p0 = new THREE.Vector3();\n    var p1 = new THREE.Vector3();\n    var p3 = new THREE.Vector3();\n    var lineVector = new THREE.Vector3();\n    var widthVector = new THREE.Vector3();\n    class PolygonMesh {\n        constructor() {\n            this.points = new Array();\n            this.texcoords = new Array();\n        }\n        add(x, y, uv_x, uv_y) {\n            this.points.push(x, y);\n            if (uv_x != null)\n                this.texcoords.push(uv_x, uv_y);\n        }\n        onPopulateMesh(vb) {\n            let numVertices = this.points.length / 2;\n            if (numVertices < 3)\n                return;\n            let restIndexPos, numRestIndices;\n            let color = this.fillColor != null ? this.fillColor : vb.vertexColor;\n            let w = vb.contentRect.width;\n            let h = vb.contentRect.height;\n            let useTexcoords = this.texcoords.length >= this.points.length;\n            for (let i = 0; i < numVertices; i++) {\n                let j = i * 2;\n                let vx = this.points[j];\n                let vy = this.points[j + 1];\n                if (this.usePercentPositions) {\n                    vx *= w;\n                    vy *= h;\n                }\n                if (useTexcoords) {\n                    let ux = this.texcoords[j];\n                    let uy = this.texcoords[j + 1];\n                    ux = fgui.lerp(vb.uvRect.x, vb.uvRect.xMax, ux);\n                    uy = fgui.lerp(vb.uvRect.y, vb.uvRect.yMax, uy);\n                    vb.addVert(vx, vy, 0, ux, uy, color);\n                }\n                else\n                    vb.addVert(vx, vy, 0, color);\n            }\n            sRestIndices.length = 0;\n            for (let i = 0; i < numVertices; ++i)\n                sRestIndices.push(i);\n            restIndexPos = 0;\n            numRestIndices = numVertices;\n            let otherIndex;\n            let earFound;\n            let i0, i1, i2;\n            while (numRestIndices > 3) {\n                earFound = false;\n                i0 = sRestIndices[restIndexPos % numRestIndices];\n                i1 = sRestIndices[(restIndexPos + 1) % numRestIndices];\n                i2 = sRestIndices[(restIndexPos + 2) % numRestIndices];\n                a.set(this.points[i0 * 2], this.points[i0 * 2 + 1]);\n                b.set(this.points[i1 * 2], this.points[i1 * 2 + 1]);\n                c.set(this.points[i2 * 2], this.points[i2 * 2 + 1]);\n                if ((a.y - b.y) * (c.x - b.x) + (b.x - a.x) * (c.y - b.y) >= 0) {\n                    earFound = true;\n                    for (let i = 3; i < numRestIndices; ++i) {\n                        otherIndex = sRestIndices[(restIndexPos + i) % numRestIndices];\n                        p.set(this.points[otherIndex * 2], this.points[otherIndex * 2 + 1]);\n                        if (this.isPointInTriangle(p, a, b, c)) {\n                            earFound = false;\n                            break;\n                        }\n                    }\n                }\n                if (earFound) {\n                    vb.addTriangle(i0, i2, i1);\n                    sRestIndices.splice((restIndexPos + 1) % numRestIndices, 1);\n                    numRestIndices--;\n                    restIndexPos = 0;\n                }\n                else {\n                    restIndexPos++;\n                    if (restIndexPos == numRestIndices)\n                        break;\n                }\n            }\n            vb.addTriangle(sRestIndices[0], sRestIndices[2], sRestIndices[1]);\n            if (this.lineWidth > 0)\n                this.drawOutline(vb);\n        }\n        drawOutline(vb) {\n            let numVertices = this.points.length / 2;\n            let start = vb.currentVertCount - numVertices;\n            let k = vb.currentVertCount;\n            for (let i = 0; i < numVertices; i++) {\n                vb.getPosition(start + i, p0);\n                if (i < numVertices - 1)\n                    vb.getPosition(start + i + 1, p1);\n                else\n                    vb.getPosition(vb.vertices[start], p1);\n                lineVector.copy(p1);\n                lineVector.sub(p0);\n                widthVector.copy(lineVector);\n                widthVector.cross(new THREE.Vector3(0, 0, 1));\n                widthVector.normalize();\n                widthVector.multiplyScalar(this.lineWidth * 0.5);\n                p3.copy(p0);\n                p3.sub(widthVector);\n                vb.addVert(p3.x, p3.y, p3.z, this.lineColor);\n                p3.copy(p0);\n                p3.add(widthVector);\n                vb.addVert(p3.x, p3.y, p3.z, this.lineColor);\n                p3.copy(p1);\n                p3.sub(widthVector);\n                vb.addVert(p3.x, p3.y, p3.z, this.lineColor);\n                p3.copy(p1);\n                p3.add(widthVector);\n                vb.addVert(p3.x, p3.y, p3.z, this.lineColor);\n                k += 4;\n                vb.addTriangle(k - 4, k - 1, k - 3);\n                vb.addTriangle(k - 4, k - 2, k - 1);\n                if (i != 0) {\n                    vb.addTriangle(k - 6, k - 3, k - 5);\n                    vb.addTriangle(k - 6, k - 4, k - 3);\n                }\n                if (i == numVertices - 1) {\n                    start += numVertices;\n                    vb.addTriangle(k - 2, start + 1, k - 1);\n                    vb.addTriangle(k - 2, start, start + 1);\n                }\n            }\n        }\n        isPointInTriangle(p, a, b, c) {\n            let v0x = c.x - a.x;\n            let v0y = c.y - a.y;\n            let v1x = b.x - a.x;\n            let v1y = b.y - a.y;\n            let v2x = p.x - a.x;\n            let v2y = p.y - a.y;\n            let dot00 = v0x * v0x + v0y * v0y;\n            let dot01 = v0x * v1x + v0y * v1y;\n            let dot02 = v0x * v2x + v0y * v2y;\n            let dot11 = v1x * v1x + v1y * v1y;\n            let dot12 = v1x * v2x + v1y * v2y;\n            let invDen = 1.0 / (dot00 * dot11 - dot01 * dot01);\n            let u = (dot11 * dot02 - dot01 * dot12) * invDen;\n            let v = (dot00 * dot12 - dot01 * dot02) * invDen;\n            return (u >= 0) && (v >= 0) && (u + v < 1);\n        }\n        hitTest(contentRect, x, y) {\n            if (!contentRect.contains(x, y))\n                return false;\n            let len = this.points.length / 2;\n            let i;\n            let j = len - 1;\n            let oddNodes = false;\n            let w = contentRect.width;\n            let h = contentRect.height;\n            for (i = 0; i < len; ++i) {\n                let ix = this.points[i * 2];\n                let iy = this.points[i * 2 + 1];\n                let jx = this.points[j * 2];\n                let jy = this.points[j * 2 + 1];\n                if (this.usePercentPositions) {\n                    ix *= w;\n                    iy *= h;\n                    ix *= w;\n                    iy *= h;\n                }\n                if ((iy < y && jy >= y || jy < y && iy >= y) && (ix <= x || jx <= x)) {\n                    if (ix + (y - iy) / (jy - iy) * (jx - ix) < x)\n                        oddNodes = !oddNodes;\n                }\n                j = i;\n            }\n            return oddNodes;\n        }\n    }\n    fgui.PolygonMesh = PolygonMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_rect = new fgui.Rect();\n    class RectMesh {\n        constructor() {\n            this.lineWidth = 1;\n        }\n        onPopulateMesh(vb) {\n            let rect = this.drawRect ? this.drawRect : vb.contentRect;\n            let color = this.fillColor ? this.fillColor : vb.vertexColor;\n            let lineColor = this.lineColor ? this.lineColor : vb.vertexColor;\n            if (this.lineWidth == 0) {\n                if (color.a != 0)\n                    vb.addQuad(rect, null, color);\n            }\n            else {\n                let part = s_rect;\n                part.set(rect.x, rect.y, this.lineWidth, rect.height);\n                vb.addQuad(part, null, lineColor);\n                part.set(rect.xMax - this.lineWidth, rect.y, this.lineWidth, rect.height);\n                vb.addQuad(part, null, lineColor);\n                part.set(rect.x + this.lineWidth, rect.y, rect.width - this.lineWidth * 2, this.lineWidth);\n                vb.addQuad(part, null, lineColor);\n                part.set(rect.x + this.lineWidth, rect.yMax - this.lineWidth, rect.width - this.lineWidth * 2, this.lineWidth);\n                vb.addQuad(part, null, lineColor);\n                if (color.a != 0) {\n                    part.setMinMax(rect.x + this.lineWidth, rect.y + this.lineWidth, rect.xMax - this.lineWidth, rect.yMax - this.lineWidth);\n                    if (part.width > 0 && part.height > 0)\n                        vb.addQuad(part, null, color);\n                }\n            }\n            vb.addTriangles();\n        }\n    }\n    fgui.RectMesh = RectMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class RegularPolygonMesh {\n        constructor() {\n            this.sides = 3;\n            this.lineWidth = 1;\n            this.lineColor = new fgui.Color4();\n        }\n        onPopulateMesh(vb) {\n            if (this.distances != null && this.distances.length < this.sides) {\n                console.error(\"distances.Length<sides\");\n                return;\n            }\n            let rect = this.drawRect != null ? this.drawRect : vb.contentRect;\n            let color = this.fillColor != null ? this.fillColor : vb.vertexColor;\n            let angleDelta = 2 * Math.PI / this.sides;\n            let angle = this.rotation * Math.PI / 180;\n            let radius = Math.min(rect.width / 2, rect.height / 2);\n            let centerX = radius + rect.x;\n            let centerY = radius + rect.y;\n            vb.addVert(centerX, centerY, 0, this.centerColor ? this.centerColor : color);\n            for (let i = 0; i < this.sides; i++) {\n                let r = radius;\n                if (this.distances != null)\n                    r *= this.distances[i];\n                let xv = Math.cos(angle) * (r - this.lineWidth);\n                let yv = Math.sin(angle) * (r - this.lineWidth);\n                vb.addVert(xv + centerX, yv + centerY, 0, color);\n                if (this.lineWidth > 0) {\n                    vb.addVert(xv + centerX, yv + centerY, 0, this.lineColor);\n                    xv = Math.cos(angle) * r + centerX;\n                    yv = Math.sin(angle) * r + centerY;\n                    vb.addVert(xv, yv, 0, this.lineColor);\n                }\n                angle += angleDelta;\n            }\n            if (this.lineWidth > 0) {\n                let tmp = this.sides * 3;\n                for (let i = 0; i < tmp; i += 3) {\n                    if (i != tmp - 3) {\n                        vb.addTriangle(0, i + 4, i + 1);\n                        vb.addTriangle(i + 5, i + 3, i + 2);\n                        vb.addTriangle(i + 3, i + 5, i + 6);\n                    }\n                    else {\n                        vb.addTriangle(0, 1, i + 1);\n                        vb.addTriangle(2, i + 3, i + 2);\n                        vb.addTriangle(i + 3, 2, 3);\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < this.sides; i++)\n                    vb.addTriangle(0, (i == this.sides - 1) ? 1 : i + 2, i + 1);\n            }\n        }\n        hitTest(contentRect, x, y) {\n            if (this.drawRect)\n                return this.drawRect.contains(x, y);\n            else\n                return contentRect.contains(x, y);\n        }\n    }\n    fgui.RegularPolygonMesh = RegularPolygonMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class RoundedRectMesh {\n        constructor() {\n            this.topLeftRadius = 0;\n            this.topRightRadius = 0;\n            this.bottomLeftRadius = 0;\n            this.bottomRightRadius = 0;\n            this.lineWidth = 1;\n            this.lineColor = new fgui.Color4();\n        }\n        onPopulateMesh(vb) {\n            let rect = this.drawRect ? this.drawRect : vb.contentRect;\n            let color = this.fillColor ? this.fillColor : vb.vertexColor;\n            let lineColor = this.lineColor;\n            let radiusX = rect.width / 2;\n            let radiusY = rect.height / 2;\n            let cornerMaxRadius = Math.min(radiusX, radiusY);\n            let centerX = radiusX + rect.x;\n            let centerY = radiusY + rect.y;\n            vb.addVert(centerX, centerY, 0, color);\n            let cnt = vb.currentVertCount;\n            for (let i = 0; i < 4; i++) {\n                let radius = 0;\n                switch (i) {\n                    case 0:\n                        radius = this.bottomRightRadius;\n                        break;\n                    case 1:\n                        radius = this.bottomLeftRadius;\n                        break;\n                    case 2:\n                        radius = this.topLeftRadius;\n                        break;\n                    case 3:\n                        radius = this.topRightRadius;\n                        break;\n                }\n                radius = Math.min(cornerMaxRadius, radius);\n                let offsetX = rect.x;\n                let offsetY = rect.y;\n                if (i == 0 || i == 3)\n                    offsetX = rect.xMax - radius * 2;\n                if (i == 0 || i == 1)\n                    offsetY = rect.yMax - radius * 2;\n                if (radius != 0) {\n                    let partNumSides = Math.max(1, Math.ceil(Math.PI * radius / 8)) + 1;\n                    let angleDelta = Math.PI / 2 / partNumSides;\n                    let angle = Math.PI / 2 * i;\n                    let startAngle = angle;\n                    for (let j = 1; j <= partNumSides; j++) {\n                        if (j == partNumSides)\n                            angle = startAngle + Math.PI / 2;\n                        let vx = offsetX + Math.cos(angle) * (radius - this.lineWidth) + radius;\n                        let vy = offsetY + Math.sin(angle) * (radius - this.lineWidth) + radius;\n                        vb.addVert(vx, vy, 0, color);\n                        if (this.lineWidth != 0) {\n                            vb.addVert(vx, vy, 0, lineColor);\n                            vb.addVert(offsetX + Math.cos(angle) * radius + radius, offsetY + Math.sin(angle) * radius + radius, 0, lineColor);\n                        }\n                        angle += angleDelta;\n                    }\n                }\n                else {\n                    let vx = offsetX;\n                    let vy = offsetY;\n                    if (this.lineWidth != 0) {\n                        if (i == 0 || i == 3)\n                            offsetX -= this.lineWidth;\n                        else\n                            offsetX += this.lineWidth;\n                        if (i == 0 || i == 1)\n                            offsetY -= this.lineWidth;\n                        else\n                            offsetY += this.lineWidth;\n                        vb.addVert(offsetX, offsetY, 0, color);\n                        vb.addVert(offsetX, offsetY, 0, lineColor);\n                        vb.addVert(vx, vy, 0, lineColor);\n                    }\n                    else\n                        vb.addVert(vx, vy, 0, color);\n                }\n            }\n            cnt = vb.currentVertCount - cnt;\n            if (this.lineWidth > 0) {\n                for (let i = 0; i < cnt; i += 3) {\n                    if (i != cnt - 3) {\n                        vb.addTriangle(0, i + 4, i + 1);\n                        vb.addTriangle(i + 5, i + 3, i + 2);\n                        vb.addTriangle(i + 3, i + 5, i + 6);\n                    }\n                    else {\n                        vb.addTriangle(0, 1, i + 1);\n                        vb.addTriangle(2, i + 3, i + 2);\n                        vb.addTriangle(i + 3, 2, 3);\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < cnt; i++)\n                    vb.addTriangle(0, (i == cnt - 1) ? 1 : i + 2, i + 1);\n            }\n        }\n        hitTest(contentRect, x, y) {\n            if (this.drawRect)\n                return this.drawRect.contains(x, y);\n            else\n                return contentRect.contains(x, y);\n        }\n    }\n    fgui.RoundedRectMesh = RoundedRectMesh;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Pool {\n        constructor(type, init, reset) {\n            this.pool = [];\n            this._init = init;\n            this._reset = reset;\n            this._ct = type;\n        }\n        borrow(...argArray) {\n            let ret;\n            if (this.pool.length > 0)\n                ret = this.pool.pop();\n            else\n                ret = new this._ct();\n            if (this._init)\n                this._init(ret, ...argArray);\n            return ret;\n        }\n        returns(element) {\n            if (Array.isArray(element)) {\n                let count = element.length;\n                for (let i = 0; i < count; i++) {\n                    let element2 = element[i];\n                    if (this._reset)\n                        this._reset(element2);\n                    this.pool.push(element2);\n                }\n                element.length = 0;\n            }\n            else {\n                if (this._reset)\n                    this._reset(element);\n                this.pool.push(element);\n            }\n        }\n    }\n    fgui.Pool = Pool;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class VertexBuffer {\n        constructor() {\n            this.vertices = new Array();\n            this.uvs = new Array();\n            this.colors = new Array();\n            this.triangles = new Array();\n            this.contentRect = new fgui.Rect();\n            this.uvRect = new fgui.Rect();\n            this.textureSize = new THREE.Vector2();\n            this.vertexColor = new fgui.Color4();\n        }\n        static begin(source) {\n            let inst = pool.borrow();\n            if (source) {\n                inst.contentRect = source.contentRect;\n                inst.uvRect = source.uvRect;\n                inst.vertexColor = source.vertexColor;\n                inst.textureSize = source.textureSize;\n            }\n            return inst;\n        }\n        end() {\n            this.clear();\n            pool.returns(this);\n        }\n        clear() {\n            this.vertices.length = 0;\n            this.colors.length = 0;\n            this.uvs.length = 0;\n            this.triangles.length = 0;\n        }\n        get currentVertCount() {\n            return this.vertices.length / 3;\n        }\n        addVert(x, y, z, uv_x, uv_y, color) {\n            y = -y;\n            this.vertices.push(x, y, z ? z : 0);\n            if (typeof uv_x === 'number')\n                this.uvs.push(uv_x, uv_y);\n            else {\n                this.uvs.push(fgui.lerp(this.uvRect.x, this.uvRect.xMax, (x - this.contentRect.x) / this.contentRect.width), fgui.lerp(this.uvRect.yMax, this.uvRect.y, (-y - this.contentRect.y) / this.contentRect.height));\n                if (uv_x instanceof fgui.Color4)\n                    color = uv_x;\n            }\n            if (color == null)\n                color = this.vertexColor;\n            this.colors.push(color.r, color.g, color.b, color.a);\n        }\n        addQuad(vertRect, uvRect, color) {\n            uvBuf.length = 0;\n            if (uvRect) {\n                if (Array.isArray(uvRect)) {\n                    for (let i = 0; i < 4; i++)\n                        uvBuf.push(uvRect[i].x, uvRect[i].y);\n                }\n                else\n                    uvBuf.push(uvRect.x, uvRect.y, uvRect.x, uvRect.yMax, uvRect.xMax, uvRect.yMax, uvRect.xMax, uvRect.y);\n            }\n            this.addVert(vertRect.x, vertRect.yMax, 0, uvBuf[0], uvBuf[1], color);\n            this.addVert(vertRect.x, vertRect.y, 0, uvBuf[2], uvBuf[3], color);\n            this.addVert(vertRect.xMax, vertRect.y, 0, uvBuf[4], uvBuf[5], color);\n            this.addVert(vertRect.xMax, vertRect.yMax, 0, uvBuf[6], uvBuf[7], color);\n        }\n        repeatColors(value, startIndex, count) {\n            let len = Math.min(startIndex + count, this.vertices.length / 3);\n            let colorCount = value.length;\n            let k = 0;\n            for (let i = startIndex; i < len; i++) {\n                let c = value[(k++) % colorCount];\n                this.colors[i] = c;\n            }\n        }\n        addTriangle(idx0, idx1, idx2) {\n            this.triangles.push(idx0);\n            this.triangles.push(idx1);\n            this.triangles.push(idx2);\n        }\n        addTriangles(startVertexIndex, idxList) {\n            if (idxList != null) {\n                if (startVertexIndex != 0) {\n                    if (startVertexIndex < 0)\n                        startVertexIndex = this.vertices.length / 3 + startVertexIndex;\n                    let cnt = idxList.length;\n                    for (let i = 0; i < cnt; i++)\n                        this.triangles.push(idxList[i] + startVertexIndex);\n                }\n                else\n                    this.triangles.push.apply(this.triangles, idxList);\n            }\n            else {\n                let cnt = this.vertices.length / 3;\n                if (startVertexIndex == null)\n                    startVertexIndex = 0;\n                else if (startVertexIndex < 0)\n                    startVertexIndex = cnt + startVertexIndex;\n                let idxList = this.triangles;\n                for (let i = startVertexIndex; i < cnt; i += 4) {\n                    idxList.push(i);\n                    idxList.push(i + 2);\n                    idxList.push(i + 1);\n                    idxList.push(i + 3);\n                    idxList.push(i + 2);\n                    idxList.push(i);\n                }\n            }\n        }\n        getPosition(index, ret) {\n            if (index < 0)\n                index = this.vertices.length / 3 + index;\n            let vec = ret ? ret : new THREE.Vector3();\n            vec.x = this.vertices[index * 3];\n            vec.y = -this.vertices[index * 3 + 1];\n            vec.z = this.vertices[index * 3 + 2];\n            return vec;\n        }\n        append(vb) {\n            this.vertices.push.apply(this.vertices, vb.vertices);\n            this.uvs.push.apply(this.uvs, vb.uvs);\n            this.colors.push.apply(this.colors, vb.colors);\n            this.triangles.push.apply(this.triangles, vb.triangles);\n        }\n    }\n    fgui.VertexBuffer = VertexBuffer;\n    var pool = new fgui.Pool(VertexBuffer);\n    var uvBuf = new Array(8);\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_rect = new fgui.Rect();\n    var c_white = new fgui.Color4(0xFFFFFF, 1);\n    class BitmapFont {\n        constructor() {\n            this.version = 0;\n            this.size = 0;\n            this.glyphs = {};\n            this._color = new fgui.Color4();\n        }\n        setFormat(format, fontSizeScale) {\n            if (this.resizable)\n                this._scale = format.size / this.size * fontSizeScale;\n            else\n                this._scale = fontSizeScale;\n            this._color.setHex(format.color);\n        }\n        prepareCharacters(text) {\n        }\n        getGlyph(ch, ret) {\n            if (ch == ' ') {\n                ret.width = Math.round(this.size * this._scale / 2);\n                ret.height = Math.round(this.size * this._scale);\n                ret.baseline = ret.height;\n                this._glyph = null;\n                return true;\n            }\n            else if (this._glyph = this.glyphs[ch]) {\n                ret.width = Math.round(this._glyph.advance * this._scale);\n                ret.height = Math.round(this._glyph.lineHeight * this._scale);\n                ret.baseline = ret.height;\n                return true;\n            }\n            else {\n                ret.width = 0;\n                ret.height = 0;\n                ret.baseline = 0;\n                return false;\n            }\n        }\n        drawGlyph(x, y, vb) {\n            if (!this._glyph)\n                return 0;\n            let tx = x + this._glyph.x * this._scale;\n            let ty = -y - this._glyph.y * this._scale;\n            let bx = x + (this._glyph.x + this._glyph.width) * this._scale;\n            let by = -y - (this._glyph.y + this._glyph.height) * this._scale;\n            s_rect.setMinMax(tx, by, bx, ty);\n            vb.addQuad(s_rect, this._glyph.uv, this.tint ? this._color : c_white);\n            vb.addTriangles(-4);\n            return 4;\n        }\n        drawLine(x, y, width, fontSize, type, vb) {\n            return 0;\n        }\n        getLineHeight(size) {\n            for (var key in this.glyphs) {\n                let glyph = this.glyphs[key];\n                if (this.resizable)\n                    return Math.round(glyph.lineHeight * size / this.size);\n                else\n                    return glyph.lineHeight;\n            }\n            return 0;\n        }\n    }\n    fgui.BitmapFont = BitmapFont;\n    class BMGlyph {\n        constructor() {\n            this.x = 0;\n            this.y = 0;\n            this.width = 0;\n            this.height = 0;\n            this.advance = 0;\n            this.lineHeight = 0;\n            this.channel = 0;\n            this.uv = [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()];\n        }\n    }\n    fgui.BMGlyph = BMGlyph;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_rect = new fgui.Rect();\n    var s_scale = 1;\n    class DynamicFont {\n        constructor() {\n            this.version = 0;\n            this.isDynamic = true;\n            this.keepCrisp = true;\n            this._glyphs = {};\n            this._color = new fgui.Color4();\n            this._outlineColor = new fgui.Color4();\n            this._packers = [new BinPacker(), new BinPacker(), new BinPacker()];\n            this._canvas = document.createElement(\"canvas\");\n            this._context = this._canvas.getContext(\"2d\");\n            this._context.globalCompositeOperation = \"lighter\";\n            this.createTexture(512);\n            s_scale = fgui.Stage.devicePixelRatio;\n        }\n        get name() {\n            return this._name;\n        }\n        set name(value) {\n            this._name = value;\n            this._canvas.id = value;\n        }\n        createTexture(size) {\n            this._canvas.width = this._canvas.height = size;\n            if (!this.mainTexture) {\n                this._texture = new THREE.Texture(this._canvas);\n                this._texture.generateMipmaps = false;\n                this._texture.magFilter = THREE.LinearFilter;\n                this._texture.minFilter = THREE.LinearFilter;\n                this.mainTexture = new fgui.NTexture(this._texture);\n            }\n            else {\n                this._texture.needsUpdate = true;\n                this.mainTexture.reload(this._texture);\n            }\n            this.clearTexture();\n        }\n        clearTexture() {\n            this._context.fillStyle = 'black';\n            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);\n            this._context.globalCompositeOperation = \"lighter\";\n            for (let i = 0; i < 3; i++)\n                this._packers[i].init(this._canvas.width, this._canvas.height);\n        }\n        rebuild() {\n            if (this._canvas.width < 2048)\n                this.createTexture(this._canvas.width * 2);\n            else\n                this.clearTexture();\n            this.version++;\n            fgui.Stage.fontRebuilt = true;\n            console.log(\"font atlas rebuilt : %s (%d)\", this.name, this._canvas.width);\n        }\n        setFormat(format, fontSizeScale) {\n            this._format = format;\n            let size = format.size * fontSizeScale;\n            this._size = Math.floor(size);\n            if (this._size == 0)\n                this._size = 1;\n            this._color.setHex(format.color);\n            this._outlineColor.setHex(format.outlineColor);\n        }\n        prepareCharacters(text) {\n            let len = text.length;\n            for (let i = 0; i < len; i++) {\n                let ch = text[i];\n                let glyph = this.prepareChar(ch, this._size);\n                if (!glyph)\n                    break;\n                if (this._format.outline > 0)\n                    this.prepareOutline(ch, glyph, this._size, this._format.outline);\n            }\n        }\n        prepareChar(ch, size) {\n            let key = (size << 16) + ch.charCodeAt(0);\n            let glyph = this._glyphs[key];\n            if (glyph && glyph.ver == this.version)\n                return glyph;\n            if (this.keepCrisp)\n                size *= s_scale;\n            this._context.font = size + \"px \" + this._name;\n            if (!glyph) {\n                glyph = this.measureChar(ch, size);\n                this._glyphs[key] = glyph;\n            }\n            glyph.ver = this.version;\n            let w = glyph.sourceRect.width;\n            let h = glyph.sourceRect.height;\n            if (w == 0)\n                return glyph;\n            let node = this.addNode(w + 2, h + 2);\n            if (!node) {\n                this.rebuild();\n                return null;\n            }\n            this._context.textBaseline = \"alphabetic\";\n            this._context.fillStyle = node.z == 0 ? \"#FF0000\" : (node.z == 1 ? \"#00FF00\" : \"#0000FF\");\n            this._context.fillText(ch, node.x + glyph.sourceRect.x, node.y + glyph.baseline);\n            this._texture.needsUpdate = true;\n            glyph.chl = node.z / 3;\n            glyph.uvRect.set(node.x / this.mainTexture.width, 1 - (node.y + h) / this.mainTexture.height, w / this.mainTexture.width, h / this.mainTexture.height);\n            return glyph;\n        }\n        prepareOutline(ch, glyph, size, outline) {\n            if (!glyph.outlines)\n                glyph.outlines = {};\n            let outlineGlyph = glyph.outlines[outline];\n            if (outlineGlyph && outlineGlyph.ver == this.version || glyph.sourceRect.width == 0)\n                return;\n            if (!outlineGlyph) {\n                outlineGlyph = { vertRect: new fgui.Rect(), uvRect: new fgui.Rect(), ver: this.version };\n                glyph.outlines[outline] = outlineGlyph;\n            }\n            else\n                outlineGlyph.ver = this.version;\n            let outline2 = outline;\n            if (this.keepCrisp)\n                outline2 *= s_scale;\n            let w = glyph.sourceRect.width + outline2 * 2;\n            let h = glyph.sourceRect.height + outline2 * 2;\n            let node = this.addNode(w + 2, h + 2);\n            if (!node) {\n                this.rebuild();\n                return null;\n            }\n            if (this.keepCrisp)\n                size *= s_scale;\n            this._context.font = size + \"px \" + this._name;\n            this._context.textBaseline = \"alphabetic\";\n            this._context.strokeStyle = node.z == 0 ? \"#FF0000\" : (node.z == 1 ? \"#00FF00\" : \"#0000FF\");\n            this._context.lineWidth = outline2;\n            this._context.strokeText(ch, node.x + glyph.sourceRect.x + outline2, node.y + glyph.baseline + outline2);\n            this._texture.needsUpdate = true;\n            outlineGlyph.chl = node.z / 3;\n            outlineGlyph.vertRect.copy(glyph.vertRect);\n            outlineGlyph.vertRect.extend(outline, outline);\n            outlineGlyph.uvRect.set(node.x / this.mainTexture.width, 1 - (node.y + h) / this.mainTexture.height, w / this.mainTexture.width, h / this.mainTexture.height);\n        }\n        measureChar(ch, size) {\n            let left, top, w, h, baseline;\n            this._context.textBaseline = \"alphabetic\";\n            let met = this._context.measureText(ch);\n            if ('actualBoundingBoxLeft' in met) {\n                this._context.textBaseline = \"top\";\n                let met1 = this._context.measureText(ch);\n                left = met.actualBoundingBoxLeft > 0 ? Math.ceil(met.actualBoundingBoxLeft) : 0;\n                top = Math.ceil(met1.actualBoundingBoxAscent) + 1;\n                w = Math.ceil(left + met.actualBoundingBoxRight) + 1;\n                h = Math.ceil(met.actualBoundingBoxAscent + met.actualBoundingBoxDescent) + 2;\n                baseline = Math.ceil(met.actualBoundingBoxAscent);\n            }\n            else {\n                baseline = getBaseline(ch, this._name, size);\n                left = 0;\n                if (ch == 'j')\n                    left = Math.ceil(size / 20);\n                top = 0;\n                w = met[\"width\"];\n                h = size * 1.25 + 2;\n            }\n            let glyph;\n            if (w == 0) {\n                glyph = { ver: this.version };\n            }\n            else {\n                glyph = {\n                    uvRect: new fgui.Rect(),\n                    vertRect: new fgui.Rect(-left, -baseline, w, h),\n                    advance: met.width,\n                    sourceRect: new fgui.Rect(left, top, w, h),\n                    baseline: baseline,\n                    ver: this.version\n                };\n                if (this.keepCrisp) {\n                    glyph.vertRect.x /= s_scale;\n                    glyph.vertRect.y /= s_scale;\n                    glyph.vertRect.width /= s_scale;\n                    glyph.vertRect.height /= s_scale;\n                    glyph.advance /= s_scale;\n                }\n            }\n            return glyph;\n        }\n        addNode(w, h) {\n            let node;\n            for (let i = 0; i < 3; i++) {\n                let packer = this._packers[i];\n                if (!packer.full && (node = packer.add(w, h))) {\n                    node.z = i;\n                    break;\n                }\n            }\n            return node;\n        }\n        getGlyph(ch, ret) {\n            let key = (this._size << 16) + ch.charCodeAt(0);\n            this._glyph = this._glyphs[key];\n            if (!this._glyph)\n                return false;\n            ret.width = this._glyph.advance;\n            ret.height = Math.round(this._size * 1.25);\n            ret.baseline = Math.round(this._size);\n            return true;\n        }\n        drawGlyph(x, y, vb) {\n            if (!this._glyph.vertRect)\n                return 0;\n            if (this._format.outline > 0) {\n                let outlineGlyph = this._glyph.outlines[this._format.outline];\n                s_rect.copy(outlineGlyph.vertRect);\n                s_rect.x += x;\n                s_rect.y -= y;\n                this._outlineColor.a = outlineGlyph.chl;\n                vb.addQuad(s_rect, outlineGlyph.uvRect, this._outlineColor);\n                vb.addTriangles(-4);\n            }\n            s_rect.copy(this._glyph.vertRect);\n            s_rect.x += x;\n            s_rect.y -= y;\n            this._color.a = this._glyph.chl;\n            vb.addQuad(s_rect, this._glyph.uvRect, this._color);\n            vb.addTriangles(-4);\n            return 4;\n        }\n        drawLine(x, y, width, fontSize, type, vb) {\n            return 0;\n        }\n        getLineHeight(size) {\n            return Math.round(size * 1.25);\n        }\n    }\n    fgui.DynamicFont = DynamicFont;\n    class BinPacker {\n        init(w, h) {\n            this._root = { x: 0, y: 0, w: w, h: h };\n            delete this.full;\n        }\n        add(w, h) {\n            let node;\n            if (node = this.findNode(this._root, w, h))\n                node = this.splitNode(node, w, h);\n            if (!node)\n                this.full = true;\n            return node;\n        }\n        findNode(root, w, h) {\n            if (root.used)\n                return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);\n            else if ((w <= root.w) && (h <= root.h))\n                return root;\n            else\n                return null;\n        }\n        splitNode(node, w, h) {\n            node.used = true;\n            node.down = { x: node.x, y: node.y + h, w: node.w, h: node.h - h };\n            node.right = { x: node.x + w, y: node.y, w: node.w - w, h: h };\n            return node;\n        }\n    }\n    let eSpan;\n    let eBlock;\n    function getBaseline(ch, font, size) {\n        if (!eSpan) {\n            eSpan = document.createElement('span');\n            eBlock = document.createElement(\"div\");\n            eBlock.style.display = 'inline-block';\n            eBlock.style.width = '1px';\n            eBlock.style.height = '0px';\n            var div = document.createElement('div');\n            div.id = 'measureText';\n            div.style.position = 'absolute';\n            div.style.visibility = 'hidden';\n            div.style.left = div.style.top = '0px';\n            div.appendChild(eSpan);\n            div.appendChild(eBlock);\n            document.body.appendChild(div);\n        }\n        eSpan.innerHTML = ch;\n        eSpan.style.fontFamily = font;\n        eSpan.style.fontSize = size + \"px\";\n        let ascent, height;\n        let offset = eSpan.offsetTop;\n        eBlock.style['vertical-align'] = 'baseline';\n        ascent = eBlock.offsetTop - offset;\n        eBlock.style['vertical-align'] = 'bottom';\n        height = eBlock.offsetTop - offset;\n        return ascent + Math.floor((size * 1.25 - height) / 2);\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class FontManager {\n        static registerFont(font) {\n            this.fonts[font.name] = font;\n        }\n        static unregisterFont(font) {\n            this.fonts[font.name] = undefined;\n        }\n        static getFont(name) {\n            if (this.packageFontGetter && name.startsWith(\"ui://\")) {\n                let font = this.packageFontGetter(name);\n                if (font)\n                    return font;\n            }\n            let font = this.fonts[name];\n            if (!font) {\n                font = new fgui.DynamicFont();\n                font.name = name;\n                this.fonts[name] = font;\n            }\n            return font;\n        }\n    }\n    FontManager.fonts = {};\n    fgui.FontManager = FontManager;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class TextField extends fgui.DisplayObject {\n        constructor() {\n            super();\n            this._touchDisabled = true;\n            this._graphics = new fgui.NGraphics(this.obj3D);\n            this._graphics.meshFactory = this;\n            this._textFormat = new fgui.TextFormat();\n            this._fontSizeScale = 1;\n            this._wordWrap = false;\n            this._text = \"\";\n            this._parsedText = \"\";\n            this._elements = new Array();\n            this._lines = new Array();\n        }\n        get textFormat() {\n            return this._textFormat;\n        }\n        applyFormat() {\n            let fontName = this._textFormat.font;\n            if (!fontName)\n                fontName = fgui.UIConfig.defaultFont;\n            let newFont = fgui.FontManager.getFont(fontName);\n            if (this._font != newFont) {\n                this._font = newFont;\n                this._fontVersion = this._font.version;\n                this._graphics.texture = this._font.mainTexture;\n                this._graphics.setKeyword(\"TEXT\", this._font.isDynamic);\n            }\n            if (this._text)\n                this._textChanged = true;\n        }\n        get align() {\n            return this._textFormat.align;\n        }\n        set align(value) {\n            if (this._textFormat.align != value) {\n                this._textFormat.align = value;\n                if (this._text)\n                    this._textChanged = true;\n            }\n        }\n        get verticalAlign() {\n            return this._verticalAlign;\n        }\n        set verticalAlign(value) {\n            if (this._verticalAlign != value) {\n                this._verticalAlign = value;\n                if (!this._textChanged)\n                    this.applyVertAlign();\n            }\n        }\n        get text() {\n            return this._text;\n        }\n        set text(value) {\n            if (this._text == value && !this._html)\n                return;\n            this._text = value;\n            this._textChanged = true;\n            this._html = false;\n        }\n        get htmlText() {\n            return this._text;\n        }\n        set htmlText(value) {\n            if (this._text == value && this._html)\n                return;\n            this._text = value;\n            this._textChanged = true;\n            this._html = true;\n        }\n        get parsedText() {\n            return this._parsedText;\n        }\n        get autoSize() {\n            return this._autoSize;\n        }\n        set autoSize(value) {\n            if (this._autoSize != value) {\n                this._autoSize = value;\n                this._textChanged = true;\n            }\n        }\n        get wordWrap() {\n            return this._wordWrap;\n        }\n        set wordWrap(value) {\n            if (this._wordWrap != value) {\n                this._wordWrap = value;\n                this._textChanged = true;\n            }\n        }\n        get singleLine() {\n            return this._singleLine;\n        }\n        set singleLine(value) {\n            if (this._singleLine != value) {\n                this._singleLine = value;\n                this._textChanged = true;\n            }\n        }\n        get textWidth() {\n            if (this._textChanged)\n                this.buildLines();\n            return this._textWidth;\n        }\n        get textHeight() {\n            if (this._textChanged)\n                this.buildLines();\n            return this._textHeight;\n        }\n        get maxWidth() {\n            return this._maxWidth;\n        }\n        set maxWidth(value) {\n            if (this._maxWidth != value) {\n                this._maxWidth = value;\n                this._textChanged = true;\n            }\n        }\n        get htmlElements() {\n            if (this._textChanged)\n                this.buildLines();\n            return this._elements;\n        }\n        get lines() {\n            if (this._textChanged)\n                this.buildLines();\n            return this._lines;\n        }\n        get charPositions() {\n            if (this._textChanged)\n                this.buildLines();\n            this._graphics.updateMesh();\n            return this._charPositions;\n        }\n        redraw() {\n            if (!this._font)\n                this.applyFormat();\n            if (this._font.version != this._fontVersion) {\n                this._fontVersion = this._font.version;\n                this._graphics.texture = this._font.mainTexture;\n                this._textChanged = true;\n            }\n            if (this._textChanged)\n                this.buildLines();\n            return this._graphics.updateMesh();\n        }\n        getLinesShape(startLine, startCharX, endLine, endCharX, clipped, result) {\n            let line1 = this._lines[startLine];\n            let line2 = this._lines[endLine];\n            if (startLine == endLine) {\n                let r = new fgui.Rect();\n                r.setMinMax(startCharX, line1.y, endCharX, line1.y + line1.height);\n                if (clipped)\n                    result.push(r.intersection(this._contentRect));\n                else\n                    result.push(r);\n            }\n            else if (startLine == endLine - 1) {\n                let r = new fgui.Rect();\n                r.setMinMax(startCharX, line1.y, fgui.GUTTER_X + line1.width, line1.y + line1.height);\n                if (clipped)\n                    result.push(r.intersection(this._contentRect));\n                else\n                    result.push(r);\n                r = new fgui.Rect();\n                r.setMinMax(fgui.GUTTER_X, line1.y + line1.height, endCharX, line2.y + line2.height);\n                if (clipped)\n                    result.push(r.intersection(this._contentRect));\n                else\n                    result.push(r);\n            }\n            else {\n                let r = new fgui.Rect();\n                r.setMinMax(startCharX, line1.y, fgui.GUTTER_X + line1.width, line1.y + line1.height);\n                if (clipped)\n                    result.push(r.intersection(this._contentRect));\n                else\n                    result.push(r);\n                for (let i = startLine + 1; i < endLine; i++) {\n                    let line = this._lines[i];\n                    r = new fgui.Rect();\n                    r.setMinMax(fgui.GUTTER_X, r.yMax, fgui.GUTTER_X + line.width, line.y + line.height);\n                    if (clipped)\n                        result.push(r.intersection(this._contentRect));\n                    else\n                        result.push(r);\n                }\n                r = new fgui.Rect();\n                r.setMinMax(fgui.GUTTER_X, r.yMax, endCharX, line2.y + line2.height);\n                if (clipped)\n                    result.push(r.intersection(this._contentRect));\n                else\n                    result.push(r);\n            }\n        }\n        onSizeChanged() {\n            if (!this._updatingSize) {\n                if (this._autoSize == fgui.AutoSizeType.Shrink || this._wordWrap)\n                    this._textChanged = true;\n                else if (this._autoSize != fgui.AutoSizeType.None)\n                    this._graphics.setMeshDirty();\n                if (this._verticalAlign != \"top\")\n                    this.applyVertAlign();\n            }\n            super.onSizeChanged();\n        }\n        ensureSizeCorrect() {\n            if (this._textChanged && this._autoSize != fgui.AutoSizeType.None)\n                this.buildLines();\n        }\n        update(clippingPlanes, alpha) {\n            this.redraw();\n            super.update(clippingPlanes, alpha);\n        }\n        requestText() {\n            if (!this._html) {\n                this._font.setFormat(this._textFormat, this._fontSizeScale);\n                this._font.prepareCharacters(this._parsedText);\n            }\n            else {\n                let count = this._elements.length;\n                for (let i = 0; i < count; i++) {\n                    let element = this._elements[i];\n                    if (element.type == fgui.HtmlElementType.Text) {\n                        this._font.setFormat(element.format, this._fontSizeScale);\n                        this._font.prepareCharacters(element.text);\n                    }\n                }\n            }\n        }\n        buildLines() {\n            if (!this._font)\n                this.applyFormat();\n            this._textChanged = false;\n            this._graphics.setMeshDirty();\n            this._fontSizeScale = 1;\n            this.cleanup();\n            if (this._text.length == 0) {\n                let emptyLine = lineInfoPool.borrow();\n                emptyLine.width = 0;\n                emptyLine.height = this._font.getLineHeight(this._textFormat.size);\n                emptyLine.charIndex = emptyLine.charCount = 0;\n                emptyLine.y = emptyLine.y2 = fgui.GUTTER_Y;\n                this._lines.push(emptyLine);\n                this._textWidth = this._textHeight = 0;\n            }\n            else {\n                this.parseText();\n                this.buildLines2();\n                if (this._autoSize == fgui.AutoSizeType.Shrink)\n                    this.doShrink();\n            }\n            if (this._autoSize == fgui.AutoSizeType.Both) {\n                this._updatingSize = true;\n                if (this.isInput) {\n                    let w = Math.max(this._textFormat.size, this._textWidth);\n                    let h = Math.max(this._font.getLineHeight(this._textFormat.size) + fgui.GUTTER_Y * 2, this._textHeight);\n                    this.setSize(w, h);\n                }\n                else\n                    this.setSize(this._textWidth, this._textHeight);\n                this._updatingSize = false;\n            }\n            else if (this._autoSize == fgui.AutoSizeType.Height) {\n                this._updatingSize = true;\n                if (this.isInput)\n                    this.height = Math.max(this._font.getLineHeight(this._textFormat.size) + fgui.GUTTER_Y * 2, this._textHeight);\n                else\n                    this.height = this._textHeight;\n                this._updatingSize = false;\n            }\n            this._yOffset = 0;\n            this.applyVertAlign();\n        }\n        parseText() {\n            if (this._html) {\n                fgui.htmldefaultParser.parse(this._text, this._textFormat, this._elements, this.isRich ? this.htmlParseOptions : null);\n                this._parsedText = \"\";\n            }\n            else\n                this._parsedText = this._text;\n            let elementCount = this._elements.length;\n            if (elementCount == 0) {\n                if (this.isInput)\n                    this._parsedText = this._parsedText.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n            }\n            else {\n                let i = 0;\n                while (i < elementCount) {\n                    let element = this._elements[i];\n                    element.charIndex = this._parsedText.length;\n                    if (element.type == fgui.HtmlElementType.Text) {\n                        if (this.isInput)\n                            this._parsedText += element.text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                        else\n                            this._parsedText += element.text;\n                    }\n                    else if (element.isEntity)\n                        this._parsedText += ' ';\n                    i++;\n                }\n            }\n        }\n        buildLines2() {\n            let letterSpacing = this._textFormat.letterSpacing * this._fontSizeScale;\n            let lineSpacing = (this._textFormat.lineSpacing - 1) * this._fontSizeScale;\n            let rectWidth = this._contentRect.width - fgui.GUTTER_X * 2;\n            let wordLen = 0;\n            let wordPossible = false;\n            let posx = 0;\n            let format = this._textFormat;\n            this._font.setFormat(format, this._fontSizeScale);\n            let wrap = this._wordWrap && !this._singleLine;\n            if (this._maxWidth > 0) {\n                wrap = true;\n                rectWidth = this._maxWidth - fgui.GUTTER_X * 2;\n            }\n            this._textWidth = this._textHeight = 0;\n            this.requestText();\n            let elementCount = this._elements.length;\n            let elementIndex = 0;\n            let element = null;\n            if (elementCount > 0)\n                element = this._elements[elementIndex];\n            let textLength = this._parsedText.length;\n            let line = lineInfoPool.borrow();\n            this._lines.push(line);\n            line.y = line.y2 = fgui.GUTTER_Y;\n            let lineChars = sLineCharInfo;\n            lineChars.length = 0;\n            let glyph = { width: 0, height: 0, baseline: 0 };\n            for (let charIndex = 0; charIndex < textLength; charIndex++) {\n                let ch = this._parsedText[charIndex];\n                glyph.width = glyph.height = glyph.baseline = 0;\n                while (element && element.charIndex == charIndex) {\n                    if (element.type == fgui.HtmlElementType.Text) {\n                        format = element.format;\n                        this._font.setFormat(format, this._fontSizeScale);\n                    }\n                    else {\n                        let htmlObject = element.htmlObject;\n                        if (this.isRich && !htmlObject) {\n                            element.space = rectWidth - line.width - 4;\n                            htmlObject = this.htmlPageContext.createObject(this, element);\n                            element.htmlObject = htmlObject;\n                        }\n                        if (htmlObject) {\n                            glyph.width = htmlObject.width + 2;\n                            glyph.height = htmlObject.height;\n                            glyph.baseline = glyph.height * IMAGE_BASELINE;\n                        }\n                        if (element.isEntity)\n                            ch = \"\";\n                    }\n                    elementIndex++;\n                    if (elementIndex < elementCount)\n                        element = this._elements[elementIndex];\n                    else\n                        element = null;\n                }\n                if (ch.length == 0 || ch == '\\n') {\n                    wordPossible = false;\n                }\n                else if (this._font.getGlyph(ch == '\\t' ? ' ' : ch, glyph)) {\n                    if (ch == '\\t')\n                        glyph.width *= 4;\n                    if (wordPossible) {\n                        if (' \\t\\n\\r\\v'.indexOf(ch) != -1) {\n                            wordLen = 0;\n                        }\n                        else if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z'\n                            || ch >= '0' && ch <= '9'\n                            || ch == '.' || ch == '\"' || ch == '\\'') {\n                            wordLen++;\n                        }\n                        else\n                            wordPossible = false;\n                    }\n                    else if (' \\t\\n\\r\\v'.indexOf(ch) != -1) {\n                        wordLen = 0;\n                        wordPossible = true;\n                    }\n                    else\n                        wordPossible = false;\n                }\n                else\n                    wordPossible = false;\n                lineChars.push(glyph.width, glyph.height, glyph.baseline);\n                if (glyph.width != 0) {\n                    if (posx != 0)\n                        posx += letterSpacing;\n                    posx += glyph.width;\n                }\n                if (ch == '\\n' && !this._singleLine) {\n                    this.updateLineInfo(line, letterSpacing, lineChars.length / 3);\n                    let newLine = lineInfoPool.borrow();\n                    this._lines.push(newLine);\n                    newLine.y = line.y + (line.height + lineSpacing);\n                    if (newLine.y < fgui.GUTTER_Y)\n                        newLine.y = fgui.GUTTER_Y;\n                    newLine.y2 = newLine.y;\n                    newLine.charIndex = line.charIndex + line.charCount;\n                    lineChars.length = 0;\n                    wordPossible = false;\n                    posx = 0;\n                    line = newLine;\n                }\n                else if (wrap && posx > rectWidth) {\n                    let lineCharCount = lineChars.length / 3;\n                    let toMoveChars;\n                    if (wordPossible && wordLen < 20 && lineCharCount > 2)\n                        toMoveChars = wordLen;\n                    else if (lineCharCount != 1)\n                        toMoveChars = 1;\n                    else\n                        toMoveChars = 0;\n                    this.updateLineInfo(line, letterSpacing, lineCharCount - toMoveChars);\n                    let newLine = lineInfoPool.borrow();\n                    this._lines.push(newLine);\n                    newLine.y = line.y + (line.height + lineSpacing);\n                    if (newLine.y < fgui.GUTTER_Y)\n                        newLine.y = fgui.GUTTER_Y;\n                    newLine.y2 = newLine.y;\n                    newLine.charIndex = line.charIndex + line.charCount;\n                    posx = 0;\n                    if (toMoveChars != 0) {\n                        for (let i = line.charCount; i < lineCharCount; i++) {\n                            if (posx != 0)\n                                posx += letterSpacing;\n                            posx += lineChars[i * 3];\n                        }\n                        for (let i = 0; i < line.charCount * 3; i++)\n                            lineChars.shift();\n                    }\n                    else\n                        lineChars.length = 0;\n                    wordPossible = false;\n                    line = newLine;\n                }\n            }\n            this.updateLineInfo(line, letterSpacing, lineChars.length / 3);\n            if (this._textWidth > 0)\n                this._textWidth += fgui.GUTTER_X * 2;\n            this._textHeight = line.y + line.height + fgui.GUTTER_Y;\n            this._textWidth = Math.round(this._textWidth);\n            this._textHeight = Math.round(this._textHeight);\n        }\n        updateLineInfo(line, letterSpacing, cnt) {\n            let lineChars = sLineCharInfo;\n            for (let i = 0; i < cnt * 3; i += 3) {\n                let width = lineChars[i];\n                let height = lineChars[i + 1];\n                let baseline = lineChars[i + 2];\n                if (baseline > line.baseline) {\n                    line.height += (baseline - line.baseline);\n                    line.baseline = baseline;\n                }\n                if (height - baseline > line.height - line.baseline)\n                    line.height += (height - baseline - (line.height - line.baseline));\n                if (width > 0) {\n                    if (line.width != 0)\n                        line.width += letterSpacing;\n                    line.width += width;\n                }\n            }\n            if (line.height == 0) {\n                if (this._lines.length == 1)\n                    line.height = this._textFormat.size;\n                else\n                    line.height = this._lines[this._lines.length - 2].height;\n            }\n            if (line.width > this._textWidth)\n                this._textWidth = line.width;\n            line.charCount = cnt;\n        }\n        doShrink() {\n            if (this._lines.length > 1 && this._textHeight > this._contentRect.height) {\n                let low = 0;\n                let high = this._textFormat.size;\n                this._fontSizeScale = Math.sqrt(this._contentRect.height / this._textHeight);\n                let cur = Math.floor(this._fontSizeScale * this._textFormat.size);\n                while (true) {\n                    lineInfoPool.returns(this._lines);\n                    this.buildLines2();\n                    if (this._textWidth > this._contentRect.width || this._textHeight > this._contentRect.height)\n                        high = cur;\n                    else\n                        low = cur;\n                    if (high - low > 1 || high != low && cur == high) {\n                        cur = low + (high - low) / 2;\n                        this._fontSizeScale = cur / this._textFormat.size;\n                    }\n                    else\n                        break;\n                }\n            }\n            else if (this._textWidth > this._contentRect.width) {\n                this._fontSizeScale = this._contentRect.width / this._textWidth;\n                lineInfoPool.returns(this._lines);\n                this.buildLines2();\n                if (this._textWidth > this._contentRect.width) {\n                    let size = Math.floor(this._textFormat.size * this._fontSizeScale);\n                    size--;\n                    this._fontSizeScale = size / this._textFormat.size;\n                    lineInfoPool.returns(this._lines);\n                    this.buildLines2();\n                }\n            }\n        }\n        onPopulateMesh(vb) {\n            if (this._textWidth == 0 && this._lines.length == 1) {\n                if (this._charPositions) {\n                    charPosPool.returns(this._charPositions);\n                    this._charPositions.push(charPosPool.borrow());\n                }\n                this.refreshObjects();\n                return;\n            }\n            let letterSpacing = this._textFormat.letterSpacing * this._fontSizeScale;\n            let format = this._textFormat;\n            this._font.setFormat(format, this._fontSizeScale);\n            let rectWidth = this._contentRect.width > 0 ? (this._contentRect.width - fgui.GUTTER_X * 2) : 0;\n            let rectHeight = this._contentRect.height > 0 ? Math.max(this._contentRect.height, this._font.getLineHeight(format.size)) : 0;\n            if (this._charPositions)\n                charPosPool.returns(this._charPositions);\n            let currentLink = null;\n            let linkStartX = 0;\n            let linkStartLine = 0;\n            let posx = 0;\n            let indent_x;\n            let clipping = !this.isInput && this._autoSize == fgui.AutoSizeType.None;\n            let lineClipped;\n            let lineAlign;\n            let vertCount;\n            let underlineStart;\n            let strikethroughStart;\n            let minFontSize;\n            let maxFontSize;\n            let elementIndex = 0;\n            let elementCount = this._elements.length;\n            let element = null;\n            if (elementCount > 0)\n                element = this._elements[elementIndex];\n            let glyph = { width: 0, height: 0, baseline: 0 };\n            let lineCount = this._lines.length;\n            for (let i = 0; i < lineCount; ++i) {\n                let line = this._lines[i];\n                if (line.charCount == 0)\n                    continue;\n                lineClipped = clipping && i != 0 && line.y + line.height > rectHeight;\n                lineAlign = format.align;\n                if (element && element.charIndex == line.charIndex)\n                    lineAlign = element.format.align;\n                else\n                    lineAlign = format.align;\n                if (lineAlign == \"center\")\n                    indent_x = Math.floor((rectWidth - line.width) / 2);\n                else if (lineAlign == \"right\")\n                    indent_x = rectWidth - line.width;\n                else\n                    indent_x = 0;\n                if (indent_x < 0)\n                    indent_x = 0;\n                posx = fgui.GUTTER_X + indent_x;\n                let lineCharCount = line.charCount;\n                underlineStart = posx;\n                strikethroughStart = posx;\n                minFontSize = maxFontSize = format.size;\n                for (let j = 0; j < lineCharCount; j++) {\n                    let charIndex = line.charIndex + j;\n                    let ch = this._parsedText[charIndex];\n                    while (element && charIndex == element.charIndex) {\n                        if (element.type == fgui.HtmlElementType.Text) {\n                            vertCount = 0;\n                            if (format.underline != element.format.underline) {\n                                if (format.underline) {\n                                    if (!lineClipped) {\n                                        let lineWidth = underlineStart - (clipping ? fgui.clamp(posx, fgui.GUTTER_X, fgui.GUTTER_X + rectWidth) : posx);\n                                        if (lineWidth > 0)\n                                            vertCount += this._font.drawLine(underlineStart < posx ? underlineStart : posx, -(line.y + line.baseline), lineWidth, maxFontSize, 0, vb);\n                                    }\n                                    maxFontSize = 0;\n                                }\n                                else\n                                    underlineStart = posx;\n                            }\n                            if (format.strikethrough != element.format.strikethrough) {\n                                if (format.strikethrough) {\n                                    if (!lineClipped) {\n                                        let lineWidth = strikethroughStart - (clipping ? fgui.clamp(posx, fgui.GUTTER_X, fgui.GUTTER_X + rectWidth) : posx);\n                                        if (lineWidth > 0)\n                                            vertCount += this._font.drawLine(strikethroughStart < posx ? strikethroughStart : posx, -(line.y + line.baseline), lineWidth, minFontSize, 1, vb);\n                                    }\n                                    minFontSize = Number.POSITIVE_INFINITY;\n                                }\n                                else\n                                    strikethroughStart = posx;\n                            }\n                            if (vertCount > 0 && this._charPositions) {\n                                let cp = this._charPositions[this._charPositions.length - 1];\n                                cp.vertCount += vertCount;\n                                this._charPositions[this._charPositions.length - 1] = cp;\n                            }\n                            format = element.format;\n                            minFontSize = Math.min(minFontSize, format.size);\n                            maxFontSize = Math.max(maxFontSize, format.size);\n                            this._font.setFormat(format, this._fontSizeScale);\n                        }\n                        else if (element.type == fgui.HtmlElementType.Link) {\n                            currentLink = element.htmlObject;\n                            if (currentLink) {\n                                element.position.set(0, 0);\n                                currentLink.setPosition(0, 0);\n                                linkStartX = posx;\n                                linkStartLine = i;\n                            }\n                        }\n                        else if (element.type == fgui.HtmlElementType.LinkEnd) {\n                            if (currentLink) {\n                                currentLink.setArea(linkStartLine, linkStartX, i, posx);\n                                currentLink = null;\n                            }\n                        }\n                        else {\n                            let htmlObj = element.htmlObject;\n                            if (htmlObj) {\n                                if (this._charPositions) {\n                                    let cp = charPosPool.borrow();\n                                    cp.lineIndex = i;\n                                    cp.charIndex = this._charPositions.length;\n                                    cp.imgIndex = elementIndex + 1;\n                                    cp.offsetX = posx;\n                                    cp.width = htmlObj.width;\n                                    this._charPositions.push(cp);\n                                }\n                                if (lineClipped || clipping && (posx < fgui.GUTTER_X || posx > fgui.GUTTER_X && posx + htmlObj.width > this._contentRect.width - fgui.GUTTER_X))\n                                    element.status |= 1;\n                                else\n                                    element.status &= 254;\n                                element.position = new THREE.Vector2(posx + 1, line.y + line.baseline - htmlObj.height * IMAGE_BASELINE);\n                                htmlObj.setPosition(element.position.x, element.position.y);\n                                posx += htmlObj.width + letterSpacing + 2;\n                            }\n                        }\n                        if (element.isEntity)\n                            ch = '\\0';\n                        elementIndex++;\n                        if (elementIndex < elementCount)\n                            element = this._elements[elementIndex];\n                        else\n                            element = null;\n                    }\n                    if (ch == '\\0')\n                        continue;\n                    if (this._font.getGlyph(ch == '\\t' ? ' ' : ch, glyph)) {\n                        if (ch == '\\t')\n                            glyph.width *= 4;\n                        if (lineClipped || clipping && (rectWidth < 7 || posx != (fgui.GUTTER_X + indent_x)) && posx + glyph.width > this._contentRect.width - fgui.GUTTER_X + 0.5) {\n                            posx += letterSpacing + glyph.width;\n                            continue;\n                        }\n                        vertCount = this._font.drawGlyph(posx, -(line.y + line.baseline), vb);\n                        if (this._charPositions) {\n                            let cp = charPosPool.borrow();\n                            cp.lineIndex = i;\n                            cp.charIndex = this._charPositions.length;\n                            cp.vertCount = vertCount;\n                            cp.offsetX = posx;\n                            cp.width = glyph.width;\n                            this._charPositions.push(cp);\n                        }\n                        posx += letterSpacing + glyph.width;\n                    }\n                    else {\n                        if (this._charPositions) {\n                            let cp = charPosPool.borrow();\n                            cp.lineIndex = i;\n                            cp.charIndex = this._charPositions.length;\n                            cp.offsetX = posx;\n                            this._charPositions.push(cp);\n                        }\n                        posx += letterSpacing;\n                    }\n                }\n                if (!lineClipped) {\n                    vertCount = 0;\n                    if (format.underline) {\n                        let lineWidth = underlineStart - (clipping ? fgui.clamp(posx, fgui.GUTTER_X, fgui.GUTTER_X + rectWidth) : posx);\n                        if (lineWidth > 0)\n                            vertCount += this._font.drawLine(underlineStart < posx ? underlineStart : posx, -(line.y + line.baseline), lineWidth, maxFontSize, 0, vb);\n                    }\n                    if (format.strikethrough) {\n                        let lineWidth = strikethroughStart - (clipping ? fgui.clamp(posx, fgui.GUTTER_X, fgui.GUTTER_X + rectWidth) : posx);\n                        if (lineWidth > 0)\n                            vertCount += this._font.drawLine(strikethroughStart < posx ? strikethroughStart : posx, -(line.y + line.baseline), lineWidth, minFontSize, 1, vb);\n                    }\n                    if (vertCount > 0 && this._charPositions) {\n                        let cp = this._charPositions[this._charPositions.length - 1];\n                        cp.vertCount += vertCount;\n                    }\n                }\n            }\n            if (element && element.type == fgui.HtmlElementType.LinkEnd && currentLink)\n                currentLink.setArea(linkStartLine, linkStartX, lineCount - 1, posx);\n            if (this._charPositions) {\n                let cp = charPosPool.borrow();\n                cp.lineIndex = lineCount - 1;\n                cp.charIndex = this._charPositions.length;\n                cp.offsetX = posx;\n                this._charPositions.push(cp);\n            }\n            this.refreshObjects();\n        }\n        cleanup() {\n            this.cleanupObjects();\n            fgui.elementPool.returns(this._elements);\n            lineInfoPool.returns(this._lines);\n            this._textWidth = 0;\n            this._textHeight = 0;\n            this._parsedText = \"\";\n            if (this._charPositions)\n                charPosPool.returns(this._charPositions);\n        }\n        applyVertAlign() {\n            let oldOffset = this._yOffset;\n            if (this._autoSize == fgui.AutoSizeType.Both || this._autoSize == fgui.AutoSizeType.Height\n                || this._verticalAlign == \"top\")\n                this._yOffset = 0;\n            else {\n                let dh;\n                if (this._textHeight == 0 && this._lines.length > 0)\n                    dh = this._contentRect.height - this._lines[0].height;\n                else\n                    dh = this._contentRect.height - this._textHeight;\n                if (dh < 0)\n                    dh = 0;\n                if (this._verticalAlign == \"middle\")\n                    this._yOffset = Math.floor(dh / 2);\n                else\n                    this._yOffset = dh;\n            }\n            if (oldOffset != this._yOffset) {\n                let cnt = this._lines.length;\n                for (let i = 0; i < cnt; i++)\n                    this._lines[i].y = this._lines[i].y2 + this._yOffset;\n                this._graphics.setMeshDirty();\n            }\n        }\n        refreshObjects() {\n        }\n        cleanupObjects() {\n        }\n    }\n    fgui.TextField = TextField;\n    fgui.GUTTER_X = 2;\n    fgui.GUTTER_Y = 2;\n    const IMAGE_BASELINE = 0.8;\n    var sLineCharInfo = new Array();\n    class LineInfo {\n    }\n    fgui.LineInfo = LineInfo;\n    var lineInfoPool = new fgui.Pool(LineInfo, ele => {\n        ele.width = ele.height = ele.baseline = ele.y = ele.y2 = ele.charIndex = ele.charCount = 0;\n    });\n    class CharPosition {\n    }\n    fgui.CharPosition = CharPosition;\n    var charPosPool = new fgui.Pool(CharPosition);\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class InputTextField extends fgui.TextField {\n        constructor() {\n            super();\n            this._touchDisabled = false;\n            this.opaque = true;\n            this.isInput = true;\n            this._text2 = '';\n            this.maxLength = 0;\n            this.editable = true;\n            this._borderColor = new fgui.Color4();\n            this._backgroundColor = new fgui.Color4(0xFFFFFF, 0);\n            this.on(fgui.TextEvent.FocusIn, this.__focusIn, this, true);\n            this.on(fgui.TextEvent.FocusOut, this.__focusOut, this, true);\n            this.on(fgui.StageEvent.RemoveFromStage, this.__removed, this);\n        }\n        get text() {\n            if (this._editing)\n                this._text2 = this._element.value;\n            return this._text2;\n        }\n        set text(value) {\n            this._text2 = value;\n            this.updateText();\n        }\n        get promptText() {\n            return this._promptText;\n        }\n        set promptText(value) {\n            this._promptText = value;\n            this._decodedPromptText = fgui.defaultParser.parse(value);\n            this.updateText();\n        }\n        get password() {\n            return this._password;\n        }\n        set password(value) {\n            this._password = value;\n        }\n        updateText() {\n            if (this._editing)\n                this._element.value = this._text2;\n            else if (this._text2.length == 0 && this._promptText)\n                super.htmlText = this._decodedPromptText;\n            else if (this._password)\n                super.text = \"*\".repeat(this._text2.length);\n            else\n                super.text = this._text2;\n        }\n        onSizeChanged() {\n            super.onSizeChanged();\n            if (!this._clipRect)\n                this._clipRect = new fgui.Rect();\n            this._clipRect.copy(this._contentRect);\n            this._clipRect.x += fgui.GUTTER_X;\n            this._clipRect.y += fgui.GUTTER_Y;\n            this._clipRect.width -= fgui.GUTTER_X * 2;\n            this._clipRect.height -= fgui.GUTTER_Y * 2;\n        }\n        applyFormat() {\n            super.applyFormat();\n            if (this._element)\n                this.setFormat();\n        }\n        createElement() {\n            let e;\n            if (this.singleLine) {\n                e = this._element = document.createElement(\"input\");\n            }\n            else {\n                e = this._element = document.createElement(\"textarea\");\n                e.style.resize = \"none\";\n                e.style.overflow = \"scroll\";\n            }\n            e.id = 'InputText';\n            e.style.outline = \"none\";\n            e.style.borderWidth = \"0px\";\n            e.style.padding = \"0px\";\n            e.style.margin = \"0px\";\n            e.style.position = \"absolute\";\n            e.style.display = \"none\";\n            e.style.background = 'transparent';\n            e.style.transformOrigin = e.style[\"WebkitTransformOrigin\"] = \"0 0 0\";\n            fgui.Stage.domElement.parentNode.appendChild(e);\n            this.setFormat();\n        }\n        setFormat() {\n            let e = this._element;\n            e.style.font = this._textFormat.size + \"px \" + this._font.name;\n            e.style.color = fgui.convertToHtmlColor(this._textFormat.color);\n            e.style.webkitTextStroke = this._textFormat.outline + \"px \" + fgui.convertToHtmlColor(this._textFormat.outlineColor);\n            e.style.textAlign = this._textFormat.align;\n        }\n        dispose() {\n            super.dispose();\n            if (this._element) {\n                this._element.style.display = 'none';\n                if (this._element.parentNode)\n                    this._element.parentNode.removeChild(this._element);\n                this._element = null;\n            }\n        }\n        __focusIn() {\n            if (!this.editable || this._editing)\n                return;\n            if (!this._font)\n                this.applyFormat();\n            if (!this._element)\n                this.createElement();\n            this.localToGlobal(0, 0, s_v2);\n            this.localToGlobal(1, 1, s_v2_2);\n            s_v2_2.sub(s_v2);\n            let e = this._element;\n            e.style.width = this.width.toFixed(2) + \"px\";\n            e.style.height = this.height.toFixed(2) + \"px\";\n            e.style.display = \"inline-block\";\n            e.style.left = (s_v2.x + 2) + \"px\";\n            e.style.top = s_v2.y + \"px\";\n            e.style.transform = \"scale(\" + s_v2_2.x.toFixed(3) + \",\" + s_v2_2.y.toFixed(3) + \")\";\n            e.value = this._text2;\n            e.focus();\n            this._editing = true;\n            this._graphics.material.visible = false;\n            this.dispatchEvent(fgui.TextEvent.FocusIn);\n        }\n        __focusOut() {\n            if (!this._editing)\n                return;\n            this._element.style.display = \"none\";\n            this._element.blur();\n            this._text2 = this._element.value;\n            this._editing = false;\n            this.updateText();\n            this._graphics.material.visible = true;\n            if (this.stage)\n                this.dispatchEvent(\"focus_out\");\n        }\n        __removed() {\n            if (this._editing)\n                fgui.Stage.setFocus(null);\n        }\n    }\n    fgui.InputTextField = InputTextField;\n    var s_v2 = new THREE.Vector2();\n    var s_v2_2 = new THREE.Vector2();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class RichTextField extends fgui.TextField {\n        constructor() {\n            super();\n            this._touchDisabled = false;\n            this.opaque = true;\n            this.isRich = true;\n            this.htmlPageContext = fgui.defaultContext;\n            this.htmlParseOptions = new fgui.HtmlParseOptions();\n        }\n        getHtmlElement(name) {\n            let elements = this.htmlElements;\n            let count = elements.length;\n            for (let i = 0; i < count; i++) {\n                let element = elements[i];\n                if (name == element.name)\n                    return element;\n            }\n            return null;\n        }\n        showHtmlObject(index, show) {\n            let element = this.htmlElements[index];\n            if (element.htmlObject && element.type != fgui.HtmlElementType.Link) {\n                if (show)\n                    element.status &= 253;\n                else\n                    element.status |= 2;\n                if ((element.status & 3) == 0) {\n                    if ((element.status & 4) == 0) {\n                        element.status |= 4;\n                        element.htmlObject.add();\n                    }\n                }\n                else {\n                    if ((element.status & 4) != 0) {\n                        element.status &= 251;\n                        element.htmlObject.remove();\n                    }\n                }\n            }\n        }\n        dispose() {\n            this.cleanupObjects();\n            super.dispose();\n        }\n        cleanupObjects() {\n            let elements = this.htmlElements;\n            let count = elements.length;\n            for (let i = 0; i < count; i++) {\n                let element = elements[i];\n                if (element.htmlObject) {\n                    element.htmlObject.remove();\n                    this.htmlPageContext.freeObject(element.htmlObject);\n                }\n            }\n        }\n        refreshObjects() {\n            let elements = this.htmlElements;\n            let count = elements.length;\n            for (let i = 0; i < count; i++) {\n                let element = elements[i];\n                if (element.htmlObject) {\n                    if ((element.status & 3) == 0) {\n                        if ((element.status & 4) == 0) {\n                            element.status |= 4;\n                            element.htmlObject.add();\n                        }\n                    }\n                    else {\n                        if ((element.status & 4) != 0) {\n                            element.status &= 251;\n                            element.htmlObject.remove();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    fgui.RichTextField = RichTextField;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_rect = new fgui.Rect();\n    class SelectionShape extends fgui.DisplayObject {\n        constructor() {\n            super();\n            this.rects = new Array();\n            this._graphics = new fgui.NGraphics(this._obj3D);\n            this._graphics.texture = fgui.EmptyTexture;\n        }\n        refresh() {\n            let count = this.rects.length;\n            if (count > 0) {\n                s_rect.copy(this.rects[0]);\n                for (let i = 1; i < count; i++)\n                    s_rect.union(this.rects[i]);\n                this.setSize(s_rect.xMax, s_rect.yMax);\n            }\n            else\n                this.setSize(0, 0);\n            this.graphics.setMeshDirty();\n        }\n        clear() {\n            this.rects.length = 0;\n            this.graphics.setMeshDirty();\n        }\n        onPopulateMesh(vb) {\n            let count = this.rects.length;\n            if (count == 0)\n                return;\n            for (let i = 0; i < count; i++)\n                vb.addQuad(this.rects[i]);\n            vb.addTriangles();\n        }\n        hitTest(context) {\n            let pt = context.getLocal(this);\n            if (this._contentRect.contains(pt)) {\n                let count = this.rects.length;\n                for (let i = 0; i < count; i++) {\n                    if (this.rects[i].contains(pt))\n                        return this;\n                }\n            }\n            return null;\n        }\n    }\n    fgui.SelectionShape = SelectionShape;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class TextFormat {\n        constructor() {\n            this.size = 0;\n            this.color = 0;\n            this.lineSpacing = 0;\n            this.letterSpacing = 0;\n            this.outline = 0;\n            this.outlineColor = 0;\n            this.shadowOffset = new THREE.Vector2();\n            this.shadowColor = 0;\n        }\n        copy(source) {\n            this.size = source.size;\n            this.font = source.font;\n            this.color = source.color;\n            this.lineSpacing = source.lineSpacing;\n            this.letterSpacing = source.letterSpacing;\n            this.bold = source.bold;\n            this.underline = source.underline;\n            this.italic = source.italic;\n            this.strikethrough = source.strikethrough;\n            this.align = source.align;\n        }\n        equalStyle(aFormat) {\n            return this.size == aFormat.size && this.color == aFormat.color\n                && this.bold == aFormat.bold && this.underline == aFormat.underline\n                && this.italic == aFormat.italic\n                && this.strikethrough == aFormat.strikethrough\n                && this.align == aFormat.align;\n        }\n    }\n    fgui.TextFormat = TextFormat;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    fgui.lastInput = {\n        x: 0,\n        y: 0,\n        mouseWheelDelta: 0,\n        touchId: 0,\n        button: 0,\n        clickCount: 0,\n        holdTime: 0,\n    };\n    class Event {\n        constructor() {\n            this.data = null;\n            this._callChain = [];\n        }\n        get type() {\n            return this._type;\n        }\n        get sender() {\n            return this._sender;\n        }\n        get initiator() {\n            return this._initiator;\n        }\n        get input() {\n            return fgui.lastInput;\n        }\n        stopPropagation() {\n            this._stopsPropagation = true;\n        }\n        preventDefault() {\n            this._defaultPrevented = true;\n        }\n        captureTouch() {\n            this._touchCapture = true;\n        }\n        get isDefaultPrevented() {\n            return this._defaultPrevented;\n        }\n    }\n    fgui.Event = Event;\n    fgui.EventPool = new fgui.Pool(Event, obj => {\n        obj._stopsPropagation = false;\n        obj._defaultPrevented = false;\n        obj._touchCapture = false;\n    }, obj => {\n        obj.data = null;\n    });\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let DisplayObjectEvent;\n    (function (DisplayObjectEvent) {\n        DisplayObjectEvent[\"XY_CHANGED\"] = \"pos_changed\";\n        DisplayObjectEvent[\"SIZE_CHANGED\"] = \"size_changed\";\n        DisplayObjectEvent[\"MOUSE_WHEEL\"] = \"mouse_wheel\";\n    })(DisplayObjectEvent = fgui.DisplayObjectEvent || (fgui.DisplayObjectEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let DragEvent;\n    (function (DragEvent) {\n        DragEvent[\"START\"] = \"drag_start\";\n        DragEvent[\"END\"] = \"drag_end\";\n        DragEvent[\"MOVING\"] = \"drag_move\";\n        DragEvent[\"DROP\"] = \"drop\";\n        DragEvent[\"CANCEL\"] = \"drag_cancel\";\n    })(DragEvent = fgui.DragEvent || (fgui.DragEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let FocusEvent;\n    (function (FocusEvent) {\n        FocusEvent[\"CHANGED\"] = \"focus_changed\";\n    })(FocusEvent = fgui.FocusEvent || (fgui.FocusEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let GearEvent;\n    (function (GearEvent) {\n        GearEvent[\"GEAR_STOP\"] = \"gear_stop\";\n    })(GearEvent = fgui.GearEvent || (fgui.GearEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class InteractiveEvents {\n    }\n    InteractiveEvents.Down = \"touch_begin\";\n    InteractiveEvents.Up = \"touch_end\";\n    InteractiveEvents.Click = \"click\";\n    InteractiveEvents.Move = \"touch_move\";\n    InteractiveEvents.RightDown = \"rightdown\";\n    InteractiveEvents.RightUp = \"rightup\";\n    InteractiveEvents.RightClick = \"right_click\";\n    fgui.InteractiveEvents = InteractiveEvents;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let ListEvent;\n    (function (ListEvent) {\n        ListEvent[\"ItemClick\"] = \"click_item\";\n    })(ListEvent = fgui.ListEvent || (fgui.ListEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let PlayEvent;\n    (function (PlayEvent) {\n        PlayEvent[\"PlayEnd\"] = \"play_end\";\n    })(PlayEvent = fgui.PlayEvent || (fgui.PlayEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let RollEvent;\n    (function (RollEvent) {\n        RollEvent[\"RollOut\"] = \"roll_out\";\n        RollEvent[\"RollOver\"] = \"roll_over\";\n    })(RollEvent = fgui.RollEvent || (fgui.RollEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let ScrollEvent;\n    (function (ScrollEvent) {\n        ScrollEvent[\"SCROLL\"] = \"scroll\";\n        ScrollEvent[\"SCROLL_END\"] = \"scroll_end\";\n        ScrollEvent[\"PULL_DOWN_RELEASE\"] = \"pull_down_release\";\n        ScrollEvent[\"PULL_UP_RELEASE\"] = \"pull_up_release\";\n    })(ScrollEvent = fgui.ScrollEvent || (fgui.ScrollEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let StageEvent;\n    (function (StageEvent) {\n        StageEvent[\"AddtoStage\"] = \"added_to_stage\";\n        StageEvent[\"RemoveFromStage\"] = \"removed_from_stage\";\n        StageEvent[\"ContentScaleChanged\"] = \"content_scale_factor_changed\";\n    })(StageEvent = fgui.StageEvent || (fgui.StageEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let StateChangeEvent;\n    (function (StateChangeEvent) {\n        StateChangeEvent[\"CHANGED\"] = \"status_changed\";\n    })(StateChangeEvent = fgui.StateChangeEvent || (fgui.StateChangeEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let TextEvent;\n    (function (TextEvent) {\n        TextEvent[\"LinkClick\"] = \"click_link\";\n        TextEvent[\"Change\"] = \"textChange\";\n        TextEvent[\"FocusIn\"] = \"FocusIn\";\n        TextEvent[\"FocusOut\"] = \"FocusOut\";\n    })(TextEvent = fgui.TextEvent || (fgui.TextEvent = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearBase {\n        dispose() {\n            if (this._tweenConfig && this._tweenConfig._tweener) {\n                this._tweenConfig._tweener.kill();\n                this._tweenConfig._tweener = null;\n            }\n        }\n        get controller() {\n            return this._controller;\n        }\n        set controller(val) {\n            if (val != this._controller) {\n                this._controller = val;\n                if (this._controller)\n                    this.init();\n            }\n        }\n        get tweenConfig() {\n            if (!this._tweenConfig)\n                this._tweenConfig = new GearTweenConfig();\n            return this._tweenConfig;\n        }\n        get allowTween() {\n            return this._tweenConfig && this._tweenConfig.tween && fgui.constructingDepth.n == 0 && !GearBase.disableAllTweenEffect;\n        }\n        setup(buffer) {\n            this._controller = this._owner.parent.getControllerAt(buffer.readShort());\n            this.init();\n            var i;\n            var page;\n            var cnt = buffer.readShort();\n            if (\"pages\" in this) {\n                this.pages = buffer.readSArray(cnt);\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    page = buffer.readS();\n                    if (page == null)\n                        continue;\n                    this.addStatus(page, buffer);\n                }\n                if (buffer.readBool())\n                    this.addStatus(null, buffer);\n            }\n            if (buffer.readBool()) {\n                this._tweenConfig = new GearTweenConfig();\n                this._tweenConfig.easeType = buffer.readByte();\n                this._tweenConfig.duration = buffer.readFloat();\n                this._tweenConfig.delay = buffer.readFloat();\n            }\n            if (buffer.version >= 2) {\n                if (\"positionsInPercent\" in this) {\n                    if (buffer.readBool()) {\n                        this.positionsInPercent = true;\n                        for (i = 0; i < cnt; i++) {\n                            page = buffer.readS();\n                            if (page == null)\n                                continue;\n                            this.addExtStatus(page, buffer);\n                        }\n                        if (buffer.readBool())\n                            this.addExtStatus(null, buffer);\n                    }\n                }\n                else if (\"condition\" in this)\n                    this.condition = buffer.readByte();\n            }\n        }\n        updateFromRelations(dx, dy) {\n        }\n        addStatus(pageId, buffer) {\n        }\n        init() {\n        }\n        apply() {\n        }\n        updateState() {\n        }\n    }\n    fgui.GearBase = GearBase;\n    class GearTweenConfig {\n        constructor() {\n            this.tween = true;\n            this.easeType = fgui.EaseType.QuadOut;\n            this.duration = 0.3;\n            this.delay = 0;\n        }\n    }\n    fgui.GearTweenConfig = GearTweenConfig;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearAnimation extends fgui.GearBase {\n        init() {\n            this._default = {\n                playing: this._owner.getProp(fgui.ObjectPropID.Playing),\n                frame: this._owner.getProp(fgui.ObjectPropID.Frame)\n            };\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else {\n                gv = {};\n                this._storage[pageId] = gv;\n            }\n            gv.playing = buffer.readBool();\n            gv.frame = buffer.readInt();\n        }\n        apply() {\n            this._owner._gearLocked = true;\n            var gv = this._storage[this._controller.selectedPageId] || this._default;\n            this._owner.setProp(fgui.ObjectPropID.Playing, gv.playing);\n            this._owner.setProp(fgui.ObjectPropID.Frame, gv.frame);\n            this._owner._gearLocked = false;\n        }\n        updateState() {\n            var gv = this._storage[this._controller.selectedPageId];\n            if (!gv) {\n                gv = {};\n                this._storage[this._controller.selectedPageId] = gv;\n            }\n            gv.playing = this._owner.getProp(fgui.ObjectPropID.Playing);\n            gv.frame = this._owner.getProp(fgui.ObjectPropID.Frame);\n        }\n    }\n    fgui.GearAnimation = GearAnimation;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearColor extends fgui.GearBase {\n        init() {\n            this._default = {\n                color: this._owner.getProp(fgui.ObjectPropID.Color),\n                strokeColor: this._owner.getProp(fgui.ObjectPropID.OutlineColor)\n            };\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else {\n                gv = {};\n                this._storage[pageId] = gv;\n            }\n            gv.color = buffer.readColor();\n            gv.strokeColor = buffer.readColor();\n        }\n        apply() {\n            this._owner._gearLocked = true;\n            var gv = this._storage[this._controller.selectedPageId] || this._default;\n            this._owner.setProp(fgui.ObjectPropID.Color, gv.color);\n            this._owner.setProp(fgui.ObjectPropID.OutlineColor, gv.strokeColor);\n            this._owner._gearLocked = false;\n        }\n        updateState() {\n            var gv = this._storage[this._controller.selectedPageId];\n            if (!gv) {\n                gv = {};\n                this._storage[this._controller.selectedPageId] = gv;\n            }\n            gv.color = this._owner.getProp(fgui.ObjectPropID.Color);\n            gv.strokeColor = this._owner.getProp(fgui.ObjectPropID.OutlineColor);\n        }\n    }\n    fgui.GearColor = GearColor;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearDisplay extends fgui.GearBase {\n        constructor() {\n            super(...arguments);\n            this._visible = 0;\n            this._displayLockToken = 1;\n        }\n        init() {\n            this.pages = null;\n        }\n        addLock() {\n            this._visible++;\n            return this._displayLockToken;\n        }\n        releaseLock(token) {\n            if (token == this._displayLockToken)\n                this._visible--;\n        }\n        get connected() {\n            return this._controller == null || this._visible > 0;\n        }\n        apply() {\n            this._displayLockToken++;\n            if (this._displayLockToken <= 0)\n                this._displayLockToken = 1;\n            if (this.pages == null || this.pages.length == 0\n                || this.pages.indexOf(this._controller.selectedPageId) != -1)\n                this._visible = 1;\n            else\n                this._visible = 0;\n        }\n    }\n    fgui.GearDisplay = GearDisplay;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearDisplay2 extends fgui.GearBase {\n        constructor() {\n            super(...arguments);\n            this._visible = 0;\n        }\n        init() {\n            this.pages = null;\n        }\n        apply() {\n            if (this.pages == null || this.pages.length == 0\n                || this.pages.indexOf(this._controller.selectedPageId) != -1)\n                this._visible = 1;\n            else\n                this._visible = 0;\n        }\n        evaluate(connected) {\n            var v = this._controller == null || this._visible > 0;\n            if (this.condition == 0)\n                v = v && connected;\n            else\n                v = v || connected;\n            return v;\n        }\n    }\n    fgui.GearDisplay2 = GearDisplay2;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearFontSize extends fgui.GearBase {\n        constructor() {\n            super(...arguments);\n            this._default = 0;\n        }\n        init() {\n            this._default = this._owner.getProp(fgui.ObjectPropID.FontSize);\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            if (!pageId)\n                this._default = buffer.readInt();\n            else\n                this._storage[pageId] = buffer.readInt();\n        }\n        apply() {\n            this._owner._gearLocked = true;\n            var data = this._storage[this._controller.selectedPageId];\n            if (data !== undefined)\n                this._owner.setProp(fgui.ObjectPropID.FontSize, data);\n            else\n                this._owner.setProp(fgui.ObjectPropID.FontSize, this._default);\n            this._owner._gearLocked = false;\n        }\n        updateState() {\n            this._storage[this._controller.selectedPageId] = this._owner.getProp(fgui.ObjectPropID.FontSize);\n        }\n    }\n    fgui.GearFontSize = GearFontSize;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearIcon extends fgui.GearBase {\n        init() {\n            this._default = this._owner.icon;\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            if (!pageId)\n                this._default = buffer.readS();\n            else\n                this._storage[pageId] = buffer.readS();\n        }\n        apply() {\n            this._owner._gearLocked = true;\n            var data = this._storage[this._controller.selectedPageId];\n            if (data !== undefined)\n                this._owner.icon = data;\n            else\n                this._owner.icon = this._default;\n            this._owner._gearLocked = false;\n        }\n        updateState() {\n            this._storage[this._controller.selectedPageId] = this._owner.icon;\n        }\n    }\n    fgui.GearIcon = GearIcon;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearLook extends fgui.GearBase {\n        init() {\n            this._default = {\n                alpha: this._owner.alpha,\n                rotation: this._owner.rotation,\n                grayed: this._owner.grayed,\n                touchable: this._owner.touchable\n            };\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else {\n                gv = {};\n                this._storage[pageId] = gv;\n            }\n            gv.alpha = buffer.readFloat();\n            gv.rotation = buffer.readFloat();\n            gv.grayed = buffer.readBool();\n            gv.touchable = buffer.readBool();\n        }\n        apply() {\n            var gv = this._storage[this._controller.selectedPageId] || this._default;\n            if (this.allowTween) {\n                this._owner._gearLocked = true;\n                this._owner.grayed = gv.grayed;\n                this._owner.touchable = gv.touchable;\n                this._owner._gearLocked = false;\n                if (this._tweenConfig._tweener) {\n                    if (this._tweenConfig._tweener.endValue.x != gv.alpha || this._tweenConfig._tweener.endValue.y != gv.rotation) {\n                        this._tweenConfig._tweener.kill(true);\n                        this._tweenConfig._tweener = null;\n                    }\n                    else\n                        return;\n                }\n                var a = gv.alpha != this._owner.alpha;\n                var b = gv.rotation != this._owner.rotation;\n                if (a || b) {\n                    if (this._owner.checkGearController(0, this._controller))\n                        this._tweenConfig._displayLockToken = this._owner.addDisplayLock();\n                    this._tweenConfig._tweener = fgui.GTween.to2(this._owner.alpha, this._owner.rotation, gv.alpha, gv.rotation, this._tweenConfig.duration)\n                        .setDelay(this._tweenConfig.delay)\n                        .setEase(this._tweenConfig.easeType)\n                        .setUserData((a ? 1 : 0) + (b ? 2 : 0))\n                        .setTarget(this)\n                        .onUpdate(this.__tweenUpdate, this)\n                        .onComplete(this.__tweenComplete, this);\n                }\n            }\n            else {\n                this._owner._gearLocked = true;\n                this._owner.grayed = gv.grayed;\n                this._owner.alpha = gv.alpha;\n                this._owner.rotation = gv.rotation;\n                this._owner.touchable = gv.touchable;\n                this._owner._gearLocked = false;\n            }\n        }\n        __tweenUpdate(tweener) {\n            var flag = tweener.userData;\n            this._owner._gearLocked = true;\n            if ((flag & 1) != 0)\n                this._owner.alpha = tweener.value.x;\n            if ((flag & 2) != 0)\n                this._owner.rotation = tweener.value.y;\n            this._owner._gearLocked = false;\n        }\n        __tweenComplete() {\n            if (this._tweenConfig._displayLockToken != 0) {\n                this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);\n                this._tweenConfig._displayLockToken = 0;\n            }\n            this._tweenConfig._tweener = null;\n        }\n        updateState() {\n            var gv = this._storage[this._controller.selectedPageId];\n            if (!gv) {\n                gv = {};\n                this._storage[this._controller.selectedPageId] = gv;\n            }\n            gv.alpha = this._owner.alpha;\n            gv.rotation = this._owner.rotation;\n            gv.grayed = this._owner.grayed;\n            gv.touchable = this._owner.touchable;\n        }\n    }\n    fgui.GearLook = GearLook;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearSize extends fgui.GearBase {\n        init() {\n            this._default = {\n                width: this._owner.width,\n                height: this._owner.height,\n                scaleX: this._owner.scaleX,\n                scaleY: this._owner.scaleY\n            };\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else {\n                gv = {};\n                this._storage[pageId] = gv;\n            }\n            gv.width = buffer.readInt();\n            gv.height = buffer.readInt();\n            gv.scaleX = buffer.readFloat();\n            gv.scaleY = buffer.readFloat();\n        }\n        apply() {\n            var gv = this._storage[this._controller.selectedPageId] || this._default;\n            if (this.allowTween) {\n                if (this._tweenConfig._tweener) {\n                    if (this._tweenConfig._tweener.endValue.x != gv.width || this._tweenConfig._tweener.endValue.y != gv.height\n                        || this._tweenConfig._tweener.endValue.z != gv.scaleX || this._tweenConfig._tweener.endValue.w != gv.scaleY) {\n                        this._tweenConfig._tweener.kill(true);\n                        this._tweenConfig._tweener = null;\n                    }\n                    else\n                        return;\n                }\n                var a = gv.width != this._owner.width || gv.height != this._owner.height;\n                var b = gv.scaleX != this._owner.scaleX || gv.scaleY != this._owner.scaleY;\n                if (a || b) {\n                    if (this._owner.checkGearController(0, this._controller))\n                        this._tweenConfig._displayLockToken = this._owner.addDisplayLock();\n                    this._tweenConfig._tweener = fgui.GTween.to4(this._owner.width, this._owner.height, this._owner.scaleX, this._owner.scaleY, gv.width, gv.height, gv.scaleX, gv.scaleY, this._tweenConfig.duration)\n                        .setDelay(this._tweenConfig.delay)\n                        .setEase(this._tweenConfig.easeType)\n                        .setUserData((a ? 1 : 0) + (b ? 2 : 0))\n                        .setTarget(this)\n                        .onUpdate(this.__tweenUpdate, this)\n                        .onComplete(this.__tweenComplete, this);\n                }\n            }\n            else {\n                this._owner._gearLocked = true;\n                this._owner.setSize(gv.width, gv.height, this._owner.checkGearController(1, this._controller));\n                this._owner.setScale(gv.scaleX, gv.scaleY);\n                this._owner._gearLocked = false;\n            }\n        }\n        __tweenUpdate(tweener) {\n            var flag = tweener.userData;\n            this._owner._gearLocked = true;\n            if ((flag & 1) != 0)\n                this._owner.setSize(tweener.value.x, tweener.value.y, this._owner.checkGearController(1, this._controller));\n            if ((flag & 2) != 0)\n                this._owner.setScale(tweener.value.z, tweener.value.w);\n            this._owner._gearLocked = false;\n        }\n        __tweenComplete() {\n            if (this._tweenConfig._displayLockToken != 0) {\n                this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);\n                this._tweenConfig._displayLockToken = 0;\n            }\n            this._tweenConfig._tweener = null;\n        }\n        updateState() {\n            var gv = this._storage[this._controller.selectedPageId];\n            if (!gv) {\n                gv = {};\n                this._storage[this._controller.selectedPageId] = gv;\n            }\n            gv.width = this._owner.width;\n            gv.height = this._owner.height;\n            gv.scaleX = this._owner.scaleX;\n            gv.scaleY = this._owner.scaleY;\n        }\n        updateFromRelations(dx, dy) {\n            if (this._controller == null || this._storage == null)\n                return;\n            for (var key in this._storage) {\n                var gv = this._storage[key];\n                gv.width += dx;\n                gv.height += dy;\n            }\n            this._default.width += dx;\n            this._default.height += dy;\n            this.updateState();\n        }\n    }\n    fgui.GearSize = GearSize;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearText extends fgui.GearBase {\n        init() {\n            this._default = this._owner.text;\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            if (pageId == null)\n                this._default = buffer.readS();\n            else\n                this._storage[pageId] = buffer.readS();\n        }\n        apply() {\n            this._owner._gearLocked = true;\n            var data = this._storage[this._controller.selectedPageId];\n            if (data !== undefined)\n                this._owner.text = data;\n            else\n                this._owner.text = this._default;\n            this._owner._gearLocked = false;\n        }\n        updateState() {\n            this._storage[this._controller.selectedPageId] = this._owner.text;\n        }\n    }\n    fgui.GearText = GearText;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GearXY extends fgui.GearBase {\n        init() {\n            this._default = {\n                x: this._owner.x,\n                y: this._owner.y,\n                px: this._owner.x / this._owner.parent.width,\n                py: this._owner.y / this._owner.parent.height\n            };\n            this._storage = {};\n        }\n        addStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else {\n                gv = {};\n                this._storage[pageId] = gv;\n            }\n            gv.x = buffer.readInt();\n            gv.y = buffer.readInt();\n        }\n        addExtStatus(pageId, buffer) {\n            var gv;\n            if (!pageId)\n                gv = this._default;\n            else\n                gv = this._storage[pageId];\n            gv.px = buffer.readFloat();\n            gv.py = buffer.readFloat();\n        }\n        apply() {\n            var pt = this._storage[this._controller.selectedPageId] || this._default;\n            var ex;\n            var ey;\n            if (this.positionsInPercent && this._owner.parent) {\n                ex = pt.px * this._owner.parent.width;\n                ey = pt.py * this._owner.parent.height;\n            }\n            else {\n                ex = pt.x;\n                ey = pt.y;\n            }\n            if (this.allowTween) {\n                if (this._tweenConfig._tweener) {\n                    if (this._tweenConfig._tweener.endValue.x != ex || this._tweenConfig._tweener.endValue.y != ey) {\n                        this._tweenConfig._tweener.kill(true);\n                        this._tweenConfig._tweener = null;\n                    }\n                    else\n                        return;\n                }\n                var ox = this._owner.x;\n                var oy = this._owner.y;\n                if (ox != ex || oy != ey) {\n                    if (this._owner.checkGearController(0, this._controller))\n                        this._tweenConfig._displayLockToken = this._owner.addDisplayLock();\n                    this._tweenConfig._tweener = fgui.GTween.to2(ox, oy, ex, ey, this._tweenConfig.duration)\n                        .setDelay(this._tweenConfig.delay)\n                        .setEase(this._tweenConfig.easeType)\n                        .setTarget(this)\n                        .onUpdate(this.__tweenUpdate, this)\n                        .onComplete(this.__tweenComplete, this);\n                }\n            }\n            else {\n                this._owner._gearLocked = true;\n                this._owner.setPosition(ex, ey);\n                this._owner._gearLocked = false;\n            }\n        }\n        __tweenUpdate(tweener) {\n            this._owner._gearLocked = true;\n            this._owner.setPosition(tweener.value.x, tweener.value.y);\n            this._owner._gearLocked = false;\n        }\n        __tweenComplete() {\n            if (this._tweenConfig._displayLockToken != 0) {\n                this._owner.releaseDisplayLock(this._tweenConfig._displayLockToken);\n                this._tweenConfig._displayLockToken = 0;\n            }\n            this._tweenConfig._tweener = null;\n        }\n        updateState() {\n            var pt = this._storage[this._controller.selectedPageId];\n            if (!pt) {\n                pt = {};\n                this._storage[this._controller.selectedPageId] = pt;\n            }\n            pt.x = this._owner.x;\n            pt.y = this._owner.y;\n            pt.px = this._owner.x / this._owner.parent.width;\n            pt.py = this._owner.y / this._owner.parent.height;\n        }\n        updateFromRelations(dx, dy) {\n            if (this._controller == null || this._storage == null || this.positionsInPercent)\n                return;\n            for (var key in this._storage) {\n                var pt = this._storage[key];\n                pt.x += dx;\n                pt.y += dy;\n            }\n            this._default.x += dx;\n            this._default.y += dy;\n            this.updateState();\n        }\n    }\n    fgui.GearXY = GearXY;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    const _PiOver2 = Math.PI * 0.5;\n    const _TwoPi = Math.PI * 2;\n    function evaluateEase(easeType, time, duration, overshootOrAmplitude, period) {\n        switch (easeType) {\n            case fgui.EaseType.Linear:\n                return time / duration;\n            case fgui.EaseType.SineIn:\n                return -Math.cos(time / duration * _PiOver2) + 1;\n            case fgui.EaseType.SineOut:\n                return Math.sin(time / duration * _PiOver2);\n            case fgui.EaseType.SineInOut:\n                return -0.5 * (Math.cos(Math.PI * time / duration) - 1);\n            case fgui.EaseType.QuadIn:\n                return (time /= duration) * time;\n            case fgui.EaseType.QuadOut:\n                return -(time /= duration) * (time - 2);\n            case fgui.EaseType.QuadInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * time * time;\n                return -0.5 * ((--time) * (time - 2) - 1);\n            case fgui.EaseType.CubicIn:\n                return (time /= duration) * time * time;\n            case fgui.EaseType.CubicOut:\n                return ((time = time / duration - 1) * time * time + 1);\n            case fgui.EaseType.CubicInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * time * time * time;\n                return 0.5 * ((time -= 2) * time * time + 2);\n            case fgui.EaseType.QuartIn:\n                return (time /= duration) * time * time * time;\n            case fgui.EaseType.QuartOut:\n                return -((time = time / duration - 1) * time * time * time - 1);\n            case fgui.EaseType.QuartInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * time * time * time * time;\n                return -0.5 * ((time -= 2) * time * time * time - 2);\n            case fgui.EaseType.QuintIn:\n                return (time /= duration) * time * time * time * time;\n            case fgui.EaseType.QuintOut:\n                return ((time = time / duration - 1) * time * time * time * time + 1);\n            case fgui.EaseType.QuintInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * time * time * time * time * time;\n                return 0.5 * ((time -= 2) * time * time * time * time + 2);\n            case fgui.EaseType.ExpoIn:\n                return (time == 0) ? 0 : Math.pow(2, 10 * (time / duration - 1));\n            case fgui.EaseType.ExpoOut:\n                if (time == duration)\n                    return 1;\n                return (-Math.pow(2, -10 * time / duration) + 1);\n            case fgui.EaseType.ExpoInOut:\n                if (time == 0)\n                    return 0;\n                if (time == duration)\n                    return 1;\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * Math.pow(2, 10 * (time - 1));\n                return 0.5 * (-Math.pow(2, -10 * --time) + 2);\n            case fgui.EaseType.CircIn:\n                return -(Math.sqrt(1 - (time /= duration) * time) - 1);\n            case fgui.EaseType.CircOut:\n                return Math.sqrt(1 - (time = time / duration - 1) * time);\n            case fgui.EaseType.CircInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return -0.5 * (Math.sqrt(1 - time * time) - 1);\n                return 0.5 * (Math.sqrt(1 - (time -= 2) * time) + 1);\n            case fgui.EaseType.ElasticIn:\n                var s0;\n                if (time == 0)\n                    return 0;\n                if ((time /= duration) == 1)\n                    return 1;\n                if (period == 0)\n                    period = duration * 0.3;\n                if (overshootOrAmplitude < 1) {\n                    overshootOrAmplitude = 1;\n                    s0 = period / 4;\n                }\n                else\n                    s0 = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);\n                return -(overshootOrAmplitude * Math.pow(2, 10 * (time -= 1)) * Math.sin((time * duration - s0) * _TwoPi / period));\n            case fgui.EaseType.ElasticOut:\n                var s1;\n                if (time == 0)\n                    return 0;\n                if ((time /= duration) == 1)\n                    return 1;\n                if (period == 0)\n                    period = duration * 0.3;\n                if (overshootOrAmplitude < 1) {\n                    overshootOrAmplitude = 1;\n                    s1 = period / 4;\n                }\n                else\n                    s1 = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);\n                return (overshootOrAmplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s1) * _TwoPi / period) + 1);\n            case fgui.EaseType.ElasticInOut:\n                var s;\n                if (time == 0)\n                    return 0;\n                if ((time /= duration * 0.5) == 2)\n                    return 1;\n                if (period == 0)\n                    period = duration * (0.3 * 1.5);\n                if (overshootOrAmplitude < 1) {\n                    overshootOrAmplitude = 1;\n                    s = period / 4;\n                }\n                else\n                    s = period / _TwoPi * Math.asin(1 / overshootOrAmplitude);\n                if (time < 1)\n                    return -0.5 * (overshootOrAmplitude * Math.pow(2, 10 * (time -= 1)) * Math.sin((time * duration - s) * _TwoPi / period));\n                return overshootOrAmplitude * Math.pow(2, -10 * (time -= 1)) * Math.sin((time * duration - s) * _TwoPi / period) * 0.5 + 1;\n            case fgui.EaseType.BackIn:\n                return (time /= duration) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude);\n            case fgui.EaseType.BackOut:\n                return ((time = time / duration - 1) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1);\n            case fgui.EaseType.BackInOut:\n                if ((time /= duration * 0.5) < 1)\n                    return 0.5 * (time * time * (((overshootOrAmplitude *= (1.525)) + 1) * time - overshootOrAmplitude));\n                return 0.5 * ((time -= 2) * time * (((overshootOrAmplitude *= (1.525)) + 1) * time + overshootOrAmplitude) + 2);\n            case fgui.EaseType.BounceIn:\n                return bounce_easeIn(time, duration);\n            case fgui.EaseType.BounceOut:\n                return bounce_easeOut(time, duration);\n            case fgui.EaseType.BounceInOut:\n                return bounce_easeInOut(time, duration);\n            default:\n                return -(time /= duration) * (time - 2);\n        }\n    }\n    fgui.evaluateEase = evaluateEase;\n    function bounce_easeIn(time, duration) {\n        return 1 - bounce_easeOut(duration - time, duration);\n    }\n    function bounce_easeOut(time, duration) {\n        if ((time /= duration) < (1 / 2.75)) {\n            return (7.5625 * time * time);\n        }\n        if (time < (2 / 2.75)) {\n            return (7.5625 * (time -= (1.5 / 2.75)) * time + 0.75);\n        }\n        if (time < (2.5 / 2.75)) {\n            return (7.5625 * (time -= (2.25 / 2.75)) * time + 0.9375);\n        }\n        return (7.5625 * (time -= (2.625 / 2.75)) * time + 0.984375);\n    }\n    function bounce_easeInOut(time, duration) {\n        if (time < duration * 0.5) {\n            return bounce_easeIn(time * 2, duration) * 0.5;\n        }\n        return bounce_easeOut(time * 2 - duration, duration) * 0.5 + 0.5;\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let EaseType;\n    (function (EaseType) {\n        EaseType[EaseType[\"Linear\"] = 0] = \"Linear\";\n        EaseType[EaseType[\"SineIn\"] = 1] = \"SineIn\";\n        EaseType[EaseType[\"SineOut\"] = 2] = \"SineOut\";\n        EaseType[EaseType[\"SineInOut\"] = 3] = \"SineInOut\";\n        EaseType[EaseType[\"QuadIn\"] = 4] = \"QuadIn\";\n        EaseType[EaseType[\"QuadOut\"] = 5] = \"QuadOut\";\n        EaseType[EaseType[\"QuadInOut\"] = 6] = \"QuadInOut\";\n        EaseType[EaseType[\"CubicIn\"] = 7] = \"CubicIn\";\n        EaseType[EaseType[\"CubicOut\"] = 8] = \"CubicOut\";\n        EaseType[EaseType[\"CubicInOut\"] = 9] = \"CubicInOut\";\n        EaseType[EaseType[\"QuartIn\"] = 10] = \"QuartIn\";\n        EaseType[EaseType[\"QuartOut\"] = 11] = \"QuartOut\";\n        EaseType[EaseType[\"QuartInOut\"] = 12] = \"QuartInOut\";\n        EaseType[EaseType[\"QuintIn\"] = 13] = \"QuintIn\";\n        EaseType[EaseType[\"QuintOut\"] = 14] = \"QuintOut\";\n        EaseType[EaseType[\"QuintInOut\"] = 15] = \"QuintInOut\";\n        EaseType[EaseType[\"ExpoIn\"] = 16] = \"ExpoIn\";\n        EaseType[EaseType[\"ExpoOut\"] = 17] = \"ExpoOut\";\n        EaseType[EaseType[\"ExpoInOut\"] = 18] = \"ExpoInOut\";\n        EaseType[EaseType[\"CircIn\"] = 19] = \"CircIn\";\n        EaseType[EaseType[\"CircOut\"] = 20] = \"CircOut\";\n        EaseType[EaseType[\"CircInOut\"] = 21] = \"CircInOut\";\n        EaseType[EaseType[\"ElasticIn\"] = 22] = \"ElasticIn\";\n        EaseType[EaseType[\"ElasticOut\"] = 23] = \"ElasticOut\";\n        EaseType[EaseType[\"ElasticInOut\"] = 24] = \"ElasticInOut\";\n        EaseType[EaseType[\"BackIn\"] = 25] = \"BackIn\";\n        EaseType[EaseType[\"BackOut\"] = 26] = \"BackOut\";\n        EaseType[EaseType[\"BackInOut\"] = 27] = \"BackInOut\";\n        EaseType[EaseType[\"BounceIn\"] = 28] = \"BounceIn\";\n        EaseType[EaseType[\"BounceOut\"] = 29] = \"BounceOut\";\n        EaseType[EaseType[\"BounceInOut\"] = 30] = \"BounceInOut\";\n        EaseType[EaseType[\"Custom\"] = 31] = \"Custom\";\n    })(EaseType = fgui.EaseType || (fgui.EaseType = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GPath {\n        constructor() {\n            this._segments = new Array();\n            this._points = new Array();\n        }\n        get length() {\n            return this._fullLength;\n        }\n        create2(pt1, pt2, pt3, pt4) {\n            var points = new Array();\n            points.push(pt1);\n            points.push(pt2);\n            if (pt3)\n                points.push(pt3);\n            if (pt4)\n                points.push(pt4);\n            this.create(points);\n        }\n        create(points) {\n            this._segments.length = 0;\n            this._points.length = 0;\n            this._fullLength = 0;\n            var cnt = points.length;\n            if (cnt == 0)\n                return;\n            var splinePoints = [];\n            var prev = points[0];\n            if (prev.curveType == fgui.CurveType.CRSpline)\n                splinePoints.push(new THREE.Vector2(prev.x, prev.y));\n            for (var i = 1; i < cnt; i++) {\n                var current = points[i];\n                if (prev.curveType != fgui.CurveType.CRSpline) {\n                    var seg = new Segment();\n                    seg.type = prev.curveType;\n                    seg.ptStart = this._points.length;\n                    if (prev.curveType == fgui.CurveType.Straight) {\n                        seg.ptCount = 2;\n                        this._points.push(new THREE.Vector2(prev.x, prev.y));\n                        this._points.push(new THREE.Vector2(current.x, current.y));\n                    }\n                    else if (prev.curveType == fgui.CurveType.Bezier) {\n                        seg.ptCount = 3;\n                        this._points.push(new THREE.Vector2(prev.x, prev.y));\n                        this._points.push(new THREE.Vector2(current.x, current.y));\n                        this._points.push(new THREE.Vector2(prev.control1_x, prev.control1_y));\n                    }\n                    else if (prev.curveType == fgui.CurveType.CubicBezier) {\n                        seg.ptCount = 4;\n                        this._points.push(new THREE.Vector2(prev.x, prev.y));\n                        this._points.push(new THREE.Vector2(current.x, current.y));\n                        this._points.push(new THREE.Vector2(prev.control1_x, prev.control1_y));\n                        this._points.push(new THREE.Vector2(prev.control2_x, prev.control2_y));\n                    }\n                    seg.length = fgui.distance(prev.x, prev.y, current.x, current.y);\n                    this._fullLength += seg.length;\n                    this._segments.push(seg);\n                }\n                if (current.curveType != fgui.CurveType.CRSpline) {\n                    if (splinePoints.length > 0) {\n                        splinePoints.push(new THREE.Vector2(current.x, current.y));\n                        this.createSplineSegment(splinePoints);\n                    }\n                }\n                else\n                    splinePoints.push(new THREE.Vector2(current.x, current.y));\n                prev = current;\n            }\n            if (splinePoints.length > 1)\n                this.createSplineSegment(splinePoints);\n        }\n        createSplineSegment(splinePoints) {\n            var cnt = splinePoints.length;\n            splinePoints.splice(0, 0, splinePoints[0]);\n            splinePoints.push(splinePoints[cnt]);\n            splinePoints.push(splinePoints[cnt]);\n            cnt += 3;\n            var seg = new Segment();\n            seg.type = fgui.CurveType.CRSpline;\n            seg.ptStart = this._points.length;\n            seg.ptCount = cnt;\n            this._points = this._points.concat(splinePoints);\n            seg.length = 0;\n            for (var i = 1; i < cnt; i++) {\n                seg.length += fgui.distance(splinePoints[i - 1].x, splinePoints[i - 1].y, splinePoints[i].x, splinePoints[i].y);\n            }\n            this._fullLength += seg.length;\n            this._segments.push(seg);\n            splinePoints.length = 0;\n        }\n        clear() {\n            this._segments.length = 0;\n            this._points.length = 0;\n        }\n        getPointAt(t, result) {\n            if (!result)\n                result = new THREE.Vector2();\n            else\n                result.set(0, 0);\n            t = fgui.clamp01(t);\n            var cnt = this._segments.length;\n            if (cnt == 0) {\n                return result;\n            }\n            var seg;\n            if (t == 1) {\n                seg = this._segments[cnt - 1];\n                if (seg.type == fgui.CurveType.Straight) {\n                    result.x = fgui.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t);\n                    result.y = fgui.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t);\n                    return result;\n                }\n                else if (seg.type == fgui.CurveType.Bezier || seg.type == fgui.CurveType.CubicBezier)\n                    return this.onBezierCurve(seg.ptStart, seg.ptCount, t, result);\n                else\n                    return this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, result);\n            }\n            var len = t * this._fullLength;\n            for (var i = 0; i < cnt; i++) {\n                seg = this._segments[i];\n                len -= seg.length;\n                if (len < 0) {\n                    t = 1 + len / seg.length;\n                    if (seg.type == fgui.CurveType.Straight) {\n                        result.x = fgui.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t);\n                        result.y = fgui.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t);\n                    }\n                    else if (seg.type == fgui.CurveType.Bezier || seg.type == fgui.CurveType.CubicBezier)\n                        result = this.onBezierCurve(seg.ptStart, seg.ptCount, t, result);\n                    else\n                        result = this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, result);\n                    break;\n                }\n            }\n            return result;\n        }\n        get segmentCount() {\n            return this._segments.length;\n        }\n        getAnchorsInSegment(segmentIndex, points) {\n            if (points == null)\n                points = new Array();\n            var seg = this._segments[segmentIndex];\n            for (var i = 0; i < seg.ptCount; i++)\n                points.push(new THREE.Vector2(this._points[seg.ptStart + i].x, this._points[seg.ptStart + i].y));\n            return points;\n        }\n        getPointsInSegment(segmentIndex, t0, t1, points, ts, pointDensity) {\n            if (points == null)\n                points = new Array();\n            if (!pointDensity || isNaN(pointDensity))\n                pointDensity = 0.1;\n            if (ts)\n                ts.push(t0);\n            var seg = this._segments[segmentIndex];\n            if (seg.type == fgui.CurveType.Straight) {\n                points.push(new THREE.Vector2(fgui.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t0), fgui.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t0)));\n                points.push(new THREE.Vector2(fgui.lerp(this._points[seg.ptStart].x, this._points[seg.ptStart + 1].x, t1), fgui.lerp(this._points[seg.ptStart].y, this._points[seg.ptStart + 1].y, t1)));\n            }\n            else {\n                var func;\n                if (seg.type == fgui.CurveType.Bezier || seg.type == fgui.CurveType.CubicBezier)\n                    func = this.onBezierCurve;\n                else\n                    func = this.onCRSplineCurve;\n                points.push(func.call(this, seg.ptStart, seg.ptCount, t0, new THREE.Vector2()));\n                var SmoothAmount = Math.min(seg.length * pointDensity, 50);\n                for (var j = 0; j <= SmoothAmount; j++) {\n                    var t = j / SmoothAmount;\n                    if (t > t0 && t < t1) {\n                        points.push(func.call(this, seg.ptStart, seg.ptCount, t, new THREE.Vector2()));\n                        if (ts)\n                            ts.push(t);\n                    }\n                }\n                points.push(func.call(this, seg.ptStart, seg.ptCount, t1, new THREE.Vector2()));\n            }\n            if (ts)\n                ts.push(t1);\n            return points;\n        }\n        getAllPoints(points, ts, pointDensity) {\n            if (points == null)\n                points = new Array();\n            if (!pointDensity || isNaN(pointDensity))\n                pointDensity = 0.1;\n            var cnt = this._segments.length;\n            for (var i = 0; i < cnt; i++)\n                this.getPointsInSegment(i, 0, 1, points, ts, pointDensity);\n            return points;\n        }\n        onCRSplineCurve(ptStart, ptCount, t, result) {\n            var adjustedIndex = Math.floor(t * (ptCount - 4)) + ptStart;\n            var p0x = this._points[adjustedIndex].x;\n            var p0y = this._points[adjustedIndex].y;\n            var p1x = this._points[adjustedIndex + 1].x;\n            var p1y = this._points[adjustedIndex + 1].y;\n            var p2x = this._points[adjustedIndex + 2].x;\n            var p2y = this._points[adjustedIndex + 2].y;\n            var p3x = this._points[adjustedIndex + 3].x;\n            var p3y = this._points[adjustedIndex + 3].y;\n            var adjustedT = (t == 1) ? 1 : fgui.repeat(t * (ptCount - 4), 1);\n            var t0 = ((-adjustedT + 2) * adjustedT - 1) * adjustedT * 0.5;\n            var t1 = (((3 * adjustedT - 5) * adjustedT) * adjustedT + 2) * 0.5;\n            var t2 = ((-3 * adjustedT + 4) * adjustedT + 1) * adjustedT * 0.5;\n            var t3 = ((adjustedT - 1) * adjustedT * adjustedT) * 0.5;\n            result.x = p0x * t0 + p1x * t1 + p2x * t2 + p3x * t3;\n            result.y = p0y * t0 + p1y * t1 + p2y * t2 + p3y * t3;\n            return result;\n        }\n        onBezierCurve(ptStart, ptCount, t, result) {\n            var t2 = 1 - t;\n            var p0x = this._points[ptStart].x;\n            var p0y = this._points[ptStart].y;\n            var p1x = this._points[ptStart + 1].x;\n            var p1y = this._points[ptStart + 1].y;\n            var cp0x = this._points[ptStart + 2].x;\n            var cp0y = this._points[ptStart + 2].y;\n            if (ptCount == 4) {\n                var cp1x = this._points[ptStart + 3].x;\n                var cp1y = this._points[ptStart + 3].y;\n                result.x = t2 * t2 * t2 * p0x + 3 * t2 * t2 * t * cp0x + 3 * t2 * t * t * cp1x + t * t * t * p1x;\n                result.y = t2 * t2 * t2 * p0y + 3 * t2 * t2 * t * cp0y + 3 * t2 * t * t * cp1y + t * t * t * p1y;\n            }\n            else {\n                result.x = t2 * t2 * p0x + 2 * t2 * t * cp0x + t * t * p1x;\n                result.y = t2 * t2 * p0y + 2 * t2 * t * cp0y + t * t * p1y;\n            }\n            return result;\n        }\n    }\n    fgui.GPath = GPath;\n    class Segment {\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let CurveType;\n    (function (CurveType) {\n        CurveType[CurveType[\"CRSpline\"] = 0] = \"CRSpline\";\n        CurveType[CurveType[\"Bezier\"] = 1] = \"Bezier\";\n        CurveType[CurveType[\"CubicBezier\"] = 2] = \"CubicBezier\";\n        CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\n    })(CurveType = fgui.CurveType || (fgui.CurveType = {}));\n    class GPathPoint {\n        constructor() {\n            this.x = 0;\n            this.y = 0;\n            this.control1_x = 0;\n            this.control1_y = 0;\n            this.control2_x = 0;\n            this.control2_y = 0;\n            this.curveType = 0;\n        }\n        static newPoint(x, y, curveType) {\n            var pt = new GPathPoint();\n            pt.x = x || 0;\n            pt.y = y || 0;\n            pt.control1_x = 0;\n            pt.control1_y = 0;\n            pt.control2_x = 0;\n            pt.control2_y = 0;\n            pt.curveType = curveType || CurveType.CRSpline;\n            return pt;\n        }\n        static newBezierPoint(x, y, control1_x, control1_y) {\n            var pt = new GPathPoint();\n            pt.x = x || 0;\n            pt.y = y || 0;\n            pt.control1_x = control1_x || 0;\n            pt.control1_y = control1_y || 0;\n            pt.control2_x = 0;\n            pt.control2_y = 0;\n            pt.curveType = CurveType.Bezier;\n            return pt;\n        }\n        static newCubicBezierPoint(x, y, control1_x, control1_y, control2_x, control2_y) {\n            var pt = new GPathPoint();\n            pt.x = x || 0;\n            pt.y = y || 0;\n            pt.control1_x = control1_x || 0;\n            pt.control1_y = control1_y || 0;\n            pt.control2_x = control2_x || 0;\n            pt.control2_y = control2_y || 0;\n            pt.curveType = CurveType.CubicBezier;\n            return pt;\n        }\n        clone() {\n            var ret = new GPathPoint();\n            ret.x = this.x;\n            ret.y = this.y;\n            ret.control1_x = this.control1_x;\n            ret.control1_y = this.control1_y;\n            ret.control2_x = this.control2_x;\n            ret.control2_y = this.control2_y;\n            ret.curveType = this.curveType;\n            return ret;\n        }\n    }\n    fgui.GPathPoint = GPathPoint;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GTween {\n        static to(start, end, duration) {\n            return fgui.TweenManager.createTween()._to(start, end, duration);\n        }\n        static to2(start, start2, end, end2, duration) {\n            return fgui.TweenManager.createTween()._to2(start, start2, end, end2, duration);\n        }\n        static to3(start, start2, start3, end, end2, end3, duration) {\n            return fgui.TweenManager.createTween()._to3(start, start2, start3, end, end2, end3, duration);\n        }\n        static to4(start, start2, start3, start4, end, end2, end3, end4, duration) {\n            return fgui.TweenManager.createTween()._to4(start, start2, start3, start4, end, end2, end3, end4, duration);\n        }\n        static toColor(start, end, duration) {\n            return fgui.TweenManager.createTween()._toColor(start, end, duration);\n        }\n        static delayedCall(delay) {\n            return fgui.TweenManager.createTween().setDelay(delay);\n        }\n        static shake(startX, startY, amplitude, duration) {\n            return fgui.TweenManager.createTween()._shake(startX, startY, amplitude, duration);\n        }\n        static isTweening(target, propType) {\n            return fgui.TweenManager.isTweening(target, propType);\n        }\n        static kill(target, complete, propType) {\n            fgui.TweenManager.killTweens(target, complete, propType);\n        }\n        static getTween(target, propType) {\n            return fgui.TweenManager.getTween(target, propType);\n        }\n    }\n    GTween.catchCallbackExceptions = true;\n    fgui.GTween = GTween;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_vec2 = new THREE.Vector2();\n    class GTweener {\n        constructor() {\n            this._startValue = new fgui.TweenValue();\n            this._endValue = new fgui.TweenValue();\n            this._value = new fgui.TweenValue();\n            this._deltaValue = new fgui.TweenValue();\n            this._reset();\n        }\n        setDelay(value) {\n            this._delay = value;\n            return this;\n        }\n        get delay() {\n            return this._delay;\n        }\n        setDuration(value) {\n            this._duration = value;\n            return this;\n        }\n        get duration() {\n            return this._duration;\n        }\n        setBreakpoint(value) {\n            this._breakpoint = value;\n            return this;\n        }\n        setEase(value) {\n            this._easeType = value;\n            return this;\n        }\n        setEasePeriod(value) {\n            this._easePeriod = value;\n            return this;\n        }\n        setEaseOvershootOrAmplitude(value) {\n            this._easeOvershootOrAmplitude = value;\n            return this;\n        }\n        setRepeat(repeat, yoyo) {\n            this._repeat = repeat;\n            this._yoyo = yoyo;\n            return this;\n        }\n        get repeat() {\n            return this._repeat;\n        }\n        setTimeScale(value) {\n            this._timeScale = value;\n            return this;\n        }\n        setSnapping(value) {\n            this._snapping = value;\n            return this;\n        }\n        setTarget(value, propType) {\n            this._target = value;\n            this._propType = propType;\n            return this;\n        }\n        get target() {\n            return this._target;\n        }\n        setPath(value) {\n            this._path = value;\n            return this;\n        }\n        setUserData(value) {\n            this._userData = value;\n            return this;\n        }\n        get userData() {\n            return this._userData;\n        }\n        onUpdate(callback, caller) {\n            this._onUpdate = callback;\n            this._onUpdateCaller = caller;\n            return this;\n        }\n        onStart(callback, caller) {\n            this._onStart = callback;\n            this._onStartCaller = caller;\n            return this;\n        }\n        onComplete(callback, caller) {\n            this._onComplete = callback;\n            this._onCompleteCaller = caller;\n            return this;\n        }\n        get startValue() {\n            return this._startValue;\n        }\n        get endValue() {\n            return this._endValue;\n        }\n        get value() {\n            return this._value;\n        }\n        get deltaValue() {\n            return this._deltaValue;\n        }\n        get normalizedTime() {\n            return this._normalizedTime;\n        }\n        get completed() {\n            return this._ended != 0;\n        }\n        get allCompleted() {\n            return this._ended == 1;\n        }\n        setPaused(paused) {\n            this._paused = paused;\n            return this;\n        }\n        seek(time) {\n            if (this._killed)\n                return;\n            this._elapsedTime = time;\n            if (this._elapsedTime < this._delay) {\n                if (this._started)\n                    this._elapsedTime = this._delay;\n                else\n                    return;\n            }\n            this.update();\n        }\n        kill(complete) {\n            if (this._killed)\n                return;\n            if (complete) {\n                if (this._ended == 0) {\n                    if (this._breakpoint >= 0)\n                        this._elapsedTime = this._delay + this._breakpoint;\n                    else if (this._repeat >= 0)\n                        this._elapsedTime = this._delay + this._duration * (this._repeat + 1);\n                    else\n                        this._elapsedTime = this._delay + this._duration * 2;\n                    this.update();\n                }\n                this.callCompleteCallback();\n            }\n            this._killed = true;\n        }\n        _to(start, end, duration) {\n            this._valueSize = 1;\n            this._startValue.x = start;\n            this._endValue.x = end;\n            this._value.x = start;\n            this._duration = duration;\n            return this;\n        }\n        _to2(start, start2, end, end2, duration) {\n            this._valueSize = 2;\n            this._startValue.x = start;\n            this._endValue.x = end;\n            this._startValue.y = start2;\n            this._endValue.y = end2;\n            this._value.x = start;\n            this._value.y = start2;\n            this._duration = duration;\n            return this;\n        }\n        _to3(start, start2, start3, end, end2, end3, duration) {\n            this._valueSize = 3;\n            this._startValue.x = start;\n            this._endValue.x = end;\n            this._startValue.y = start2;\n            this._endValue.y = end2;\n            this._startValue.z = start3;\n            this._endValue.z = end3;\n            this._value.x = start;\n            this._value.y = start2;\n            this._value.z = start3;\n            this._duration = duration;\n            return this;\n        }\n        _to4(start, start2, start3, start4, end, end2, end3, end4, duration) {\n            this._valueSize = 4;\n            this._startValue.x = start;\n            this._endValue.x = end;\n            this._startValue.y = start2;\n            this._endValue.y = end2;\n            this._startValue.z = start3;\n            this._endValue.z = end3;\n            this._startValue.w = start4;\n            this._endValue.w = end4;\n            this._value.x = start;\n            this._value.y = start2;\n            this._value.z = start3;\n            this._value.w = start4;\n            this._duration = duration;\n            return this;\n        }\n        _toColor(start, end, duration) {\n            this._valueSize = 4;\n            this._startValue.color = start;\n            this._endValue.color = end;\n            this._value.color = start;\n            this._duration = duration;\n            return this;\n        }\n        _shake(startX, startY, amplitude, duration) {\n            this._valueSize = 5;\n            this._startValue.x = startX;\n            this._startValue.y = startY;\n            this._startValue.w = amplitude;\n            this._duration = duration;\n            return this;\n        }\n        _init() {\n            this._delay = 0;\n            this._duration = 0;\n            this._breakpoint = -1;\n            this._easeType = fgui.EaseType.QuadOut;\n            this._timeScale = 1;\n            this._easePeriod = 0;\n            this._easeOvershootOrAmplitude = 1.70158;\n            this._snapping = false;\n            this._repeat = 0;\n            this._yoyo = false;\n            this._valueSize = 0;\n            this._started = false;\n            this._paused = false;\n            this._killed = false;\n            this._elapsedTime = 0;\n            this._normalizedTime = 0;\n            this._ended = 0;\n        }\n        _reset() {\n            this._target = null;\n            this._propType = null;\n            this._userData = null;\n            this._path = null;\n            this._onStart = this._onUpdate = this._onComplete = null;\n            this._onStartCaller = this._onUpdateCaller = this._onCompleteCaller = null;\n        }\n        _update(dt) {\n            if (this._timeScale != 1)\n                dt *= this._timeScale;\n            if (dt == 0)\n                return;\n            if (this._ended != 0) {\n                this.callCompleteCallback();\n                this._killed = true;\n                return;\n            }\n            this._elapsedTime += dt;\n            this.update();\n            if (this._ended != 0) {\n                if (!this._killed) {\n                    this.callCompleteCallback();\n                    this._killed = true;\n                }\n            }\n        }\n        update() {\n            this._ended = 0;\n            if (this._valueSize == 0) {\n                if (this._elapsedTime >= this._delay + this._duration)\n                    this._ended = 1;\n                return;\n            }\n            if (!this._started) {\n                if (this._elapsedTime < this._delay)\n                    return;\n                this._started = true;\n                this.callStartCallback();\n                if (this._killed)\n                    return;\n            }\n            var reversed = false;\n            var tt = this._elapsedTime - this._delay;\n            if (this._breakpoint >= 0 && tt >= this._breakpoint) {\n                tt = this._breakpoint;\n                this._ended = 2;\n            }\n            if (this._repeat != 0) {\n                var round = Math.floor(tt / this._duration);\n                tt -= this._duration * round;\n                if (this._yoyo)\n                    reversed = round % 2 == 1;\n                if (this._repeat > 0 && this._repeat - round < 0) {\n                    if (this._yoyo)\n                        reversed = this._repeat % 2 == 1;\n                    tt = this._duration;\n                    this._ended = 1;\n                }\n            }\n            else if (tt >= this._duration) {\n                tt = this._duration;\n                this._ended = 1;\n            }\n            this._normalizedTime = fgui.evaluateEase(this._easeType, reversed ? (this._duration - tt) : tt, this._duration, this._easeOvershootOrAmplitude, this._easePeriod);\n            this._value.setZero();\n            this._deltaValue.setZero();\n            if (this._valueSize == 5) {\n                if (this._ended == 0) {\n                    var r = this._startValue.w * (1 - this._normalizedTime);\n                    var rx = r * (Math.random() > 0.5 ? 1 : -1);\n                    var ry = r * (Math.random() > 0.5 ? 1 : -1);\n                    this._deltaValue.x = rx;\n                    this._deltaValue.y = ry;\n                    this._value.x = this._startValue.x + rx;\n                    this._value.y = this._startValue.y + ry;\n                }\n                else {\n                    this._value.x = this._startValue.x;\n                    this._value.y = this._startValue.y;\n                }\n            }\n            else if (this._path) {\n                let pt = this._path.getPointAt(this._normalizedTime, s_vec2);\n                if (this._snapping) {\n                    pt.x = Math.round(pt.x);\n                    pt.y = Math.round(pt.y);\n                }\n                this._deltaValue.x = pt.x - this._value.x;\n                this._deltaValue.y = pt.y - this._value.y;\n                this._value.x = pt.x;\n                this._value.y = pt.y;\n            }\n            else {\n                for (var i = 0; i < this._valueSize; i++) {\n                    var n1 = this._startValue.getField(i);\n                    var n2 = this._endValue.getField(i);\n                    var f = n1 + (n2 - n1) * this._normalizedTime;\n                    if (this._snapping)\n                        f = Math.round(f);\n                    this._deltaValue.setField(i, f - this._value.getField(i));\n                    this._value.setField(i, f);\n                }\n            }\n            if (this._target && this._propType) {\n                if (this._propType instanceof Function) {\n                    switch (this._valueSize) {\n                        case 1:\n                            this._propType.call(this._target, this._value.x);\n                            break;\n                        case 2:\n                            this._propType.call(this._target, this._value.x, this._value.y);\n                            break;\n                        case 3:\n                            this._propType.call(this._target, this._value.x, this._value.y, this._value.z);\n                            break;\n                        case 4:\n                            this._propType.call(this._target, this._value.x, this._value.y, this._value.z, this._value.w);\n                            break;\n                        case 5:\n                            this._propType.call(this._target, this._value.color);\n                            break;\n                        case 6:\n                            this._propType.call(this._target, this._value.x, this._value.y);\n                            break;\n                    }\n                }\n                else {\n                    if (this._valueSize == 5)\n                        this._target[this._propType] = this._value.color;\n                    else\n                        this._target[this._propType] = this._value.x;\n                }\n            }\n            this.callUpdateCallback();\n        }\n        callStartCallback() {\n            if (this._onStart) {\n                try {\n                    this._onStart.call(this._onStartCaller, this);\n                }\n                catch (err) {\n                    console.log(\"error in start callback > \" + err);\n                }\n            }\n        }\n        callUpdateCallback() {\n            if (this._onUpdate) {\n                try {\n                    this._onUpdate.call(this._onUpdateCaller, this);\n                }\n                catch (err) {\n                    console.log(\"error in update callback > \" + err);\n                }\n            }\n        }\n        callCompleteCallback() {\n            if (this._onComplete) {\n                try {\n                    this._onComplete.call(this._onCompleteCaller, this);\n                }\n                catch (err) {\n                    console.log(\"error in complete callback > \" + err);\n                }\n            }\n        }\n    }\n    fgui.GTweener = GTweener;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class TweenManager {\n        static createTween() {\n            if (!_inited) {\n                fgui.Timers.addUpdate(TweenManager.update);\n                _inited = true;\n            }\n            var tweener = _tweenerPool.borrow();\n            _activeTweens[_totalActiveTweens++] = tweener;\n            return tweener;\n        }\n        static isTweening(target, propType) {\n            if (target == null)\n                return false;\n            var anyType = !propType;\n            for (var i = 0; i < _totalActiveTweens; i++) {\n                var tweener = _activeTweens[i];\n                if (tweener && tweener.target == target && !tweener._killed\n                    && (anyType || tweener._propType == propType))\n                    return true;\n            }\n            return false;\n        }\n        static killTweens(target, completed, propType) {\n            if (target == null)\n                return false;\n            var flag = false;\n            var cnt = _totalActiveTweens;\n            var anyType = !propType;\n            for (var i = 0; i < cnt; i++) {\n                var tweener = _activeTweens[i];\n                if (tweener && tweener.target == target && !tweener._killed\n                    && (anyType || tweener._propType == propType)) {\n                    tweener.kill(completed);\n                    flag = true;\n                }\n            }\n            return flag;\n        }\n        static getTween(target, propType) {\n            if (target == null)\n                return null;\n            var cnt = _totalActiveTweens;\n            var anyType = !propType;\n            for (var i = 0; i < cnt; i++) {\n                var tweener = _activeTweens[i];\n                if (tweener && tweener.target == target && !tweener._killed\n                    && (anyType || tweener._propType == propType)) {\n                    return tweener;\n                }\n            }\n            return null;\n        }\n        static update() {\n            var dt = fgui.Timers.deltaTime / 1000;\n            var cnt = _totalActiveTweens;\n            var freePosStart = -1;\n            for (var i = 0; i < cnt; i++) {\n                var tweener = _activeTweens[i];\n                if (tweener == null) {\n                    if (freePosStart == -1)\n                        freePosStart = i;\n                }\n                else if (tweener._killed) {\n                    _tweenerPool.returns(tweener);\n                    _activeTweens[i] = null;\n                    if (freePosStart == -1)\n                        freePosStart = i;\n                }\n                else {\n                    if (('isDisposed' in tweener._target) && tweener._target.isDisposed)\n                        tweener._killed = true;\n                    else if (!tweener._paused)\n                        tweener._update(dt);\n                    if (freePosStart != -1) {\n                        _activeTweens[freePosStart] = tweener;\n                        _activeTweens[i] = null;\n                        freePosStart++;\n                    }\n                }\n            }\n            if (freePosStart >= 0) {\n                if (_totalActiveTweens != cnt) {\n                    var j = cnt;\n                    cnt = _totalActiveTweens - cnt;\n                    for (i = 0; i < cnt; i++)\n                        _activeTweens[freePosStart++] = _activeTweens[j++];\n                }\n                _totalActiveTweens = freePosStart;\n            }\n        }\n    }\n    fgui.TweenManager = TweenManager;\n    var _activeTweens = new Array();\n    var _tweenerPool = new fgui.Pool(fgui.GTweener, e => e._init(), e => e._reset());\n    var _totalActiveTweens = 0;\n    var _inited = false;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class TweenValue {\n        constructor() {\n            this.x = this.y = this.z = this.w = 0;\n        }\n        get color() {\n            return (this.w << 24) + (this.x << 16) + (this.y << 8) + this.z;\n        }\n        set color(value) {\n            this.x = (value & 0xFF0000) >> 16;\n            this.y = (value & 0x00FF00) >> 8;\n            this.z = (value & 0x0000FF);\n            this.w = (value & 0xFF000000) >> 24;\n        }\n        getField(index) {\n            switch (index) {\n                case 0:\n                    return this.x;\n                case 1:\n                    return this.y;\n                case 2:\n                    return this.z;\n                case 3:\n                    return this.w;\n                default:\n                    throw new Error(\"Index out of bounds: \" + index);\n            }\n        }\n        setField(index, value) {\n            switch (index) {\n                case 0:\n                    this.x = value;\n                    break;\n                case 1:\n                    this.y = value;\n                    break;\n                case 2:\n                    this.z = value;\n                    break;\n                case 3:\n                    this.w = value;\n                    break;\n                default:\n                    throw new Error(\"Index out of bounds: \" + index);\n            }\n        }\n        setZero() {\n            this.x = this.y = this.z = this.w = 0;\n        }\n    }\n    fgui.TweenValue = TweenValue;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class AsyncOperation {\n        constructor() {\n            this._itemList = new Array();\n            this._objectPool = [];\n        }\n        createObject(pkgName, resName) {\n            var pkg = fgui.UIPackage.getByName(pkgName);\n            if (pkg) {\n                var pi = pkg.getItemByName(resName);\n                if (!pi)\n                    throw new Error(\"resource not found: \" + resName);\n                this.internalCreateObject(pi);\n            }\n            else\n                throw new Error(\"package not found: \" + pkgName);\n        }\n        createObjectFromURL(url) {\n            var pi = fgui.UIPackage.getItemByURL(url);\n            if (pi)\n                this.internalCreateObject(pi);\n            else\n                throw new Error(\"resource not found: \" + url);\n        }\n        cancel() {\n            fgui.Timers.remove(this.run, this);\n            this._itemList.length = 0;\n            if (this._objectPool.length > 0) {\n                var cnt = this._objectPool.length;\n                for (var i = 0; i < cnt; i++) {\n                    this._objectPool[i].dispose();\n                }\n                this._objectPool.length = 0;\n            }\n        }\n        internalCreateObject(item) {\n            this._itemList.length = 0;\n            this._objectPool.length = 0;\n            var di = new DisplayListItem(item, fgui.ObjectType.Component);\n            di.childCount = this.collectComponentChildren(item);\n            this._itemList.push(di);\n            this._index = 0;\n            fgui.Timers.addUpdate(this.run, this);\n        }\n        collectComponentChildren(item) {\n            var buffer = item.rawData;\n            buffer.seek(0, 2);\n            var di;\n            var pi;\n            var i;\n            var dataLen;\n            var curPos;\n            var pkg;\n            var dcnt = buffer.readShort();\n            for (i = 0; i < dcnt; i++) {\n                dataLen = buffer.readShort();\n                curPos = buffer.pos;\n                buffer.seek(curPos, 0);\n                var type = buffer.readByte();\n                var src = buffer.readS();\n                var pkgId = buffer.readS();\n                buffer.pos = curPos;\n                if (src != null) {\n                    if (pkgId != null)\n                        pkg = fgui.UIPackage.getById(pkgId);\n                    else\n                        pkg = item.owner;\n                    pi = pkg != null ? pkg.getItemById(src) : null;\n                    di = new DisplayListItem(pi, type);\n                    if (pi != null && pi.type == fgui.PackageItemType.Component)\n                        di.childCount = this.collectComponentChildren(pi);\n                }\n                else {\n                    di = new DisplayListItem(null, type);\n                    if (type == fgui.ObjectType.List)\n                        di.listItemCount = this.collectListChildren(buffer);\n                }\n                this._itemList.push(di);\n                buffer.pos = curPos + dataLen;\n            }\n            return dcnt;\n        }\n        collectListChildren(buffer) {\n            buffer.seek(buffer.pos, 8);\n            var listItemCount = 0;\n            var i;\n            var nextPos;\n            var url;\n            var pi;\n            var di;\n            var defaultItem = buffer.readS();\n            var itemCount = buffer.readShort();\n            for (i = 0; i < itemCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                url = buffer.readS();\n                if (url == null)\n                    url = defaultItem;\n                if (url) {\n                    pi = fgui.UIPackage.getItemByURL(url);\n                    if (pi != null) {\n                        di = new DisplayListItem(pi, pi.objectType);\n                        if (pi.type == fgui.PackageItemType.Component)\n                            di.childCount = this.collectComponentChildren(pi);\n                        this._itemList.push(di);\n                        listItemCount++;\n                    }\n                }\n                buffer.pos = nextPos;\n            }\n            return listItemCount;\n        }\n        run() {\n            var obj;\n            var di;\n            var poolStart;\n            var k;\n            var t = performance.now();\n            var frameTime = fgui.UIConfig.frameTimeForAsyncUIConstruction;\n            var totalItems = this._itemList.length;\n            while (this._index < totalItems) {\n                di = this._itemList[this._index];\n                if (di.packageItem != null) {\n                    obj = fgui.UIObjectFactory.newObject(di.packageItem);\n                    this._objectPool.push(obj);\n                    fgui.constructingDepth.n++;\n                    if (di.packageItem.type == fgui.PackageItemType.Component) {\n                        poolStart = this._objectPool.length - di.childCount - 1;\n                        obj.constructFromResource2(this._objectPool, poolStart);\n                        this._objectPool.splice(poolStart, di.childCount);\n                    }\n                    else {\n                        obj.constructFromResource();\n                    }\n                    fgui.constructingDepth.n--;\n                }\n                else {\n                    obj = fgui.UIObjectFactory.newObject(di.type);\n                    this._objectPool.push(obj);\n                    if (di.type == fgui.ObjectType.List && di.listItemCount > 0) {\n                        poolStart = this._objectPool.length - di.listItemCount - 1;\n                        for (k = 0; k < di.listItemCount; k++)\n                            obj.itemPool.returnObject(this._objectPool[k + poolStart]);\n                        this._objectPool.splice(poolStart, di.listItemCount);\n                    }\n                }\n                this._index++;\n                if ((this._index % 5 == 0) && performance.now() - t >= frameTime)\n                    return;\n            }\n            fgui.Timers.remove(this.run, this);\n            var result = this._objectPool[0];\n            this._itemList.length = 0;\n            this._objectPool.length = 0;\n            if (this.callback != null)\n                this.callback(result);\n        }\n    }\n    fgui.AsyncOperation = AsyncOperation;\n    class DisplayListItem {\n        constructor(packageItem, type) {\n            this.packageItem = packageItem;\n            this.type = type;\n        }\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var _nextPageId = 0;\n    class Controller extends fgui.EventDispatcher {\n        constructor() {\n            super();\n            this._selectedIndex = 0;\n            this._previousIndex = 0;\n            this.changing = false;\n            this._pageIds = [];\n            this._pageNames = [];\n            this._selectedIndex = -1;\n            this._previousIndex = -1;\n        }\n        dispose() {\n            this.offAll();\n        }\n        get selectedIndex() {\n            return this._selectedIndex;\n        }\n        set selectedIndex(value) {\n            if (this._selectedIndex != value) {\n                if (value > this._pageIds.length - 1)\n                    throw \"index out of bounds: \" + value;\n                this.changing = true;\n                this._previousIndex = this._selectedIndex;\n                this._selectedIndex = value;\n                this.parent.applyController(this);\n                this.dispatchEvent(fgui.StateChangeEvent.CHANGED);\n                this.changing = false;\n            }\n        }\n        setSelectedIndex(value) {\n            if (this._selectedIndex != value) {\n                if (value > this._pageIds.length - 1)\n                    throw \"index out of bounds: \" + value;\n                this.changing = true;\n                this._previousIndex = this._selectedIndex;\n                this._selectedIndex = value;\n                this.parent.applyController(this);\n                this.changing = false;\n            }\n        }\n        get previsousIndex() {\n            return this._previousIndex;\n        }\n        get selectedPage() {\n            if (this._selectedIndex == -1)\n                return null;\n            else\n                return this._pageNames[this._selectedIndex];\n        }\n        set selectedPage(val) {\n            var i = this._pageNames.indexOf(val);\n            if (i == -1)\n                i = 0;\n            this.selectedIndex = i;\n        }\n        setSelectedPage(value) {\n            var i = this._pageNames.indexOf(value);\n            if (i == -1)\n                i = 0;\n            this.setSelectedIndex(i);\n        }\n        get previousPage() {\n            if (this._previousIndex == -1)\n                return null;\n            else\n                return this._pageNames[this._previousIndex];\n        }\n        get pageCount() {\n            return this._pageIds.length;\n        }\n        getPageName(index) {\n            return this._pageNames[index];\n        }\n        addPage(name) {\n            name = name || \"\";\n            this.addPageAt(name, this._pageIds.length);\n        }\n        addPageAt(name, index) {\n            name = name || \"\";\n            var nid = \"\" + (_nextPageId++);\n            if (index == null || index == this._pageIds.length) {\n                this._pageIds.push(nid);\n                this._pageNames.push(this.name);\n            }\n            else {\n                this._pageIds.splice(index, 0, nid);\n                this._pageNames.splice(index, 0, this.name);\n            }\n        }\n        removePage(name) {\n            var i = this._pageNames.indexOf(name);\n            if (i != -1) {\n                this._pageIds.splice(i, 1);\n                this._pageNames.splice(i, 1);\n                if (this._selectedIndex >= this._pageIds.length)\n                    this.selectedIndex = this._selectedIndex - 1;\n                else\n                    this.parent.applyController(this);\n            }\n        }\n        removePageAt(index) {\n            this._pageIds.splice(index, 1);\n            this._pageNames.splice(index, 1);\n            if (this._selectedIndex >= this._pageIds.length)\n                this.selectedIndex = this._selectedIndex - 1;\n            else\n                this.parent.applyController(this);\n        }\n        clearPages() {\n            this._pageIds.length = 0;\n            this._pageNames.length = 0;\n            if (this._selectedIndex != -1)\n                this.selectedIndex = -1;\n            else\n                this.parent.applyController(this);\n        }\n        hasPage(aName) {\n            return this._pageNames.indexOf(aName) != -1;\n        }\n        getPageIndexById(aId) {\n            return this._pageIds.indexOf(aId);\n        }\n        getPageIdByName(aName) {\n            var i = this._pageNames.indexOf(aName);\n            if (i != -1)\n                return this._pageIds[i];\n            else\n                return null;\n        }\n        getPageNameById(aId) {\n            var i = this._pageIds.indexOf(aId);\n            if (i != -1)\n                return this._pageNames[i];\n            else\n                return null;\n        }\n        getPageId(index) {\n            return this._pageIds[index];\n        }\n        get selectedPageId() {\n            if (this._selectedIndex == -1)\n                return null;\n            else\n                return this._pageIds[this._selectedIndex];\n        }\n        set selectedPageId(val) {\n            var i = this._pageIds.indexOf(val);\n            this.selectedIndex = i;\n        }\n        set oppositePageId(val) {\n            var i = this._pageIds.indexOf(val);\n            if (i > 0)\n                this.selectedIndex = 0;\n            else if (this._pageIds.length > 1)\n                this.selectedIndex = 1;\n        }\n        get previousPageId() {\n            if (this._previousIndex == -1)\n                return null;\n            else\n                return this._pageIds[this._previousIndex];\n        }\n        runActions() {\n            if (this._actions) {\n                var cnt = this._actions.length;\n                for (var i = 0; i < cnt; i++) {\n                    this._actions[i].run(this, this.previousPageId, this.selectedPageId);\n                }\n            }\n        }\n        setup(buffer) {\n            var beginPos = buffer.pos;\n            buffer.seek(beginPos, 0);\n            this.name = buffer.readS();\n            this.autoRadioGroupDepth = buffer.readBool();\n            buffer.seek(beginPos, 1);\n            var i;\n            var nextPos;\n            var cnt = buffer.readShort();\n            for (i = 0; i < cnt; i++) {\n                this._pageIds.push(buffer.readS());\n                this._pageNames.push(buffer.readS());\n            }\n            var homePageIndex = 0;\n            if (buffer.version >= 2) {\n                var homePageType = buffer.readByte();\n                switch (homePageType) {\n                    case 1:\n                        homePageIndex = buffer.readShort();\n                        break;\n                    case 2:\n                        homePageIndex = this._pageNames.indexOf(fgui.UIPackage.branch);\n                        if (homePageIndex == -1)\n                            homePageIndex = 0;\n                        break;\n                    case 3:\n                        homePageIndex = this._pageNames.indexOf(fgui.UIPackage.getVar(buffer.readS()));\n                        if (homePageIndex == -1)\n                            homePageIndex = 0;\n                        break;\n                }\n            }\n            buffer.seek(beginPos, 2);\n            cnt = buffer.readShort();\n            if (cnt > 0) {\n                if (this._actions == null)\n                    this._actions = [];\n                for (i = 0; i < cnt; i++) {\n                    nextPos = buffer.readShort();\n                    nextPos += buffer.pos;\n                    var action = createAction(buffer.readByte());\n                    action.setup(buffer);\n                    this._actions.push(action);\n                    buffer.pos = nextPos;\n                }\n            }\n            if (this.parent && this._pageIds.length > 0)\n                this._selectedIndex = homePageIndex;\n            else\n                this._selectedIndex = -1;\n        }\n    }\n    fgui.Controller = Controller;\n    function createAction(type) {\n        switch (type) {\n            case 0:\n                return new fgui.PlayTransitionAction();\n            case 1:\n                return new fgui.ChangePageAction();\n        }\n        return null;\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var _inst;\n    class DragDropManager {\n        constructor() {\n            let a = this._agent = new fgui.GLoader();\n            a.draggable = true;\n            a.touchable = false;\n            a.setSize(100, 100);\n            a.setPivot(0.5, 0.5, true);\n            a.align = \"center\";\n            a.verticalAlign = \"middle\";\n            a.sortingOrder = 1000000;\n            a.on(fgui.DragEvent.END, this.__dragEnd, this);\n        }\n        static get inst() {\n            if (!_inst)\n                _inst = new DragDropManager();\n            return _inst;\n        }\n        get dragAgent() {\n            return this._agent;\n        }\n        get dragging() {\n            return this._agent.parent != null;\n        }\n        startDrag(icon, sourceData, touchPointID) {\n            if (this._agent.parent)\n                return;\n            this._sourceData = sourceData;\n            this._agent.url = icon;\n            fgui.GRoot.inst.addChild(this._agent);\n            var pt = fgui.GRoot.inst.globalToLocal(fgui.Stage.touchPos.x, fgui.Stage.touchPos.y);\n            this._agent.setPosition(pt.x, pt.y);\n            this._agent.startDrag(touchPointID != null ? touchPointID : -1);\n        }\n        cancel() {\n            if (this._agent.parent) {\n                this._agent.stopDrag();\n                fgui.GRoot.inst.removeChild(this._agent);\n                this._sourceData = null;\n            }\n        }\n        __dragEnd(evt) {\n            if (this._agent.parent == null)\n                return;\n            fgui.GRoot.inst.removeChild(this._agent);\n            var sourceData = this._sourceData;\n            this._sourceData = null;\n            var obj = fgui.GObject.cast(fgui.Stage.touchTarget);\n            while (obj) {\n                if (obj.hasListener(fgui.DragEvent.DROP)) {\n                    obj.dispatchEvent(fgui.DragEvent.DROP, sourceData);\n                    return;\n                }\n                obj = obj.parent;\n            }\n        }\n    }\n    fgui.DragDropManager = DragDropManager;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let ButtonMode;\n    (function (ButtonMode) {\n        ButtonMode[ButtonMode[\"Common\"] = 0] = \"Common\";\n        ButtonMode[ButtonMode[\"Check\"] = 1] = \"Check\";\n        ButtonMode[ButtonMode[\"Radio\"] = 2] = \"Radio\";\n    })(ButtonMode = fgui.ButtonMode || (fgui.ButtonMode = {}));\n    let AutoSizeType;\n    (function (AutoSizeType) {\n        AutoSizeType[AutoSizeType[\"None\"] = 0] = \"None\";\n        AutoSizeType[AutoSizeType[\"Both\"] = 1] = \"Both\";\n        AutoSizeType[AutoSizeType[\"Height\"] = 2] = \"Height\";\n        AutoSizeType[AutoSizeType[\"Shrink\"] = 3] = \"Shrink\";\n    })(AutoSizeType = fgui.AutoSizeType || (fgui.AutoSizeType = {}));\n    let LoaderFillType;\n    (function (LoaderFillType) {\n        LoaderFillType[LoaderFillType[\"None\"] = 0] = \"None\";\n        LoaderFillType[LoaderFillType[\"Scale\"] = 1] = \"Scale\";\n        LoaderFillType[LoaderFillType[\"ScaleMatchHeight\"] = 2] = \"ScaleMatchHeight\";\n        LoaderFillType[LoaderFillType[\"ScaleMatchWidth\"] = 3] = \"ScaleMatchWidth\";\n        LoaderFillType[LoaderFillType[\"ScaleFree\"] = 4] = \"ScaleFree\";\n        LoaderFillType[LoaderFillType[\"ScaleNoBorder\"] = 5] = \"ScaleNoBorder\";\n    })(LoaderFillType = fgui.LoaderFillType || (fgui.LoaderFillType = {}));\n    let ListLayoutType;\n    (function (ListLayoutType) {\n        ListLayoutType[ListLayoutType[\"SingleColumn\"] = 0] = \"SingleColumn\";\n        ListLayoutType[ListLayoutType[\"SingleRow\"] = 1] = \"SingleRow\";\n        ListLayoutType[ListLayoutType[\"FlowHorizontal\"] = 2] = \"FlowHorizontal\";\n        ListLayoutType[ListLayoutType[\"FlowVertical\"] = 3] = \"FlowVertical\";\n        ListLayoutType[ListLayoutType[\"Pagination\"] = 4] = \"Pagination\";\n    })(ListLayoutType = fgui.ListLayoutType || (fgui.ListLayoutType = {}));\n    let ListSelectionMode;\n    (function (ListSelectionMode) {\n        ListSelectionMode[ListSelectionMode[\"Single\"] = 0] = \"Single\";\n        ListSelectionMode[ListSelectionMode[\"Multiple\"] = 1] = \"Multiple\";\n        ListSelectionMode[ListSelectionMode[\"Multiple_SingleClick\"] = 2] = \"Multiple_SingleClick\";\n        ListSelectionMode[ListSelectionMode[\"None\"] = 3] = \"None\";\n    })(ListSelectionMode = fgui.ListSelectionMode || (fgui.ListSelectionMode = {}));\n    let OverflowType;\n    (function (OverflowType) {\n        OverflowType[OverflowType[\"Visible\"] = 0] = \"Visible\";\n        OverflowType[OverflowType[\"Hidden\"] = 1] = \"Hidden\";\n        OverflowType[OverflowType[\"Scroll\"] = 2] = \"Scroll\";\n    })(OverflowType = fgui.OverflowType || (fgui.OverflowType = {}));\n    let PackageItemType;\n    (function (PackageItemType) {\n        PackageItemType[PackageItemType[\"Image\"] = 0] = \"Image\";\n        PackageItemType[PackageItemType[\"MovieClip\"] = 1] = \"MovieClip\";\n        PackageItemType[PackageItemType[\"Sound\"] = 2] = \"Sound\";\n        PackageItemType[PackageItemType[\"Component\"] = 3] = \"Component\";\n        PackageItemType[PackageItemType[\"Atlas\"] = 4] = \"Atlas\";\n        PackageItemType[PackageItemType[\"Font\"] = 5] = \"Font\";\n        PackageItemType[PackageItemType[\"Swf\"] = 6] = \"Swf\";\n        PackageItemType[PackageItemType[\"Misc\"] = 7] = \"Misc\";\n        PackageItemType[PackageItemType[\"Unknown\"] = 8] = \"Unknown\";\n    })(PackageItemType = fgui.PackageItemType || (fgui.PackageItemType = {}));\n    let ObjectType;\n    (function (ObjectType) {\n        ObjectType[ObjectType[\"Image\"] = 0] = \"Image\";\n        ObjectType[ObjectType[\"MovieClip\"] = 1] = \"MovieClip\";\n        ObjectType[ObjectType[\"Swf\"] = 2] = \"Swf\";\n        ObjectType[ObjectType[\"Graph\"] = 3] = \"Graph\";\n        ObjectType[ObjectType[\"Loader\"] = 4] = \"Loader\";\n        ObjectType[ObjectType[\"Group\"] = 5] = \"Group\";\n        ObjectType[ObjectType[\"Text\"] = 6] = \"Text\";\n        ObjectType[ObjectType[\"RichText\"] = 7] = \"RichText\";\n        ObjectType[ObjectType[\"InputText\"] = 8] = \"InputText\";\n        ObjectType[ObjectType[\"Component\"] = 9] = \"Component\";\n        ObjectType[ObjectType[\"List\"] = 10] = \"List\";\n        ObjectType[ObjectType[\"Label\"] = 11] = \"Label\";\n        ObjectType[ObjectType[\"Button\"] = 12] = \"Button\";\n        ObjectType[ObjectType[\"ComboBox\"] = 13] = \"ComboBox\";\n        ObjectType[ObjectType[\"ProgressBar\"] = 14] = \"ProgressBar\";\n        ObjectType[ObjectType[\"Slider\"] = 15] = \"Slider\";\n        ObjectType[ObjectType[\"ScrollBar\"] = 16] = \"ScrollBar\";\n        ObjectType[ObjectType[\"Tree\"] = 17] = \"Tree\";\n        ObjectType[ObjectType[\"Loader3D\"] = 18] = \"Loader3D\";\n    })(ObjectType = fgui.ObjectType || (fgui.ObjectType = {}));\n    let ProgressTitleType;\n    (function (ProgressTitleType) {\n        ProgressTitleType[ProgressTitleType[\"Percent\"] = 0] = \"Percent\";\n        ProgressTitleType[ProgressTitleType[\"ValueAndMax\"] = 1] = \"ValueAndMax\";\n        ProgressTitleType[ProgressTitleType[\"Value\"] = 2] = \"Value\";\n        ProgressTitleType[ProgressTitleType[\"Max\"] = 3] = \"Max\";\n    })(ProgressTitleType = fgui.ProgressTitleType || (fgui.ProgressTitleType = {}));\n    let ScrollBarDisplayType;\n    (function (ScrollBarDisplayType) {\n        ScrollBarDisplayType[ScrollBarDisplayType[\"Default\"] = 0] = \"Default\";\n        ScrollBarDisplayType[ScrollBarDisplayType[\"Visible\"] = 1] = \"Visible\";\n        ScrollBarDisplayType[ScrollBarDisplayType[\"Auto\"] = 2] = \"Auto\";\n        ScrollBarDisplayType[ScrollBarDisplayType[\"Hidden\"] = 3] = \"Hidden\";\n    })(ScrollBarDisplayType = fgui.ScrollBarDisplayType || (fgui.ScrollBarDisplayType = {}));\n    let ScrollType;\n    (function (ScrollType) {\n        ScrollType[ScrollType[\"Horizontal\"] = 0] = \"Horizontal\";\n        ScrollType[ScrollType[\"Vertical\"] = 1] = \"Vertical\";\n        ScrollType[ScrollType[\"Both\"] = 2] = \"Both\";\n    })(ScrollType = fgui.ScrollType || (fgui.ScrollType = {}));\n    let FlipType;\n    (function (FlipType) {\n        FlipType[FlipType[\"None\"] = 0] = \"None\";\n        FlipType[FlipType[\"Horizontal\"] = 1] = \"Horizontal\";\n        FlipType[FlipType[\"Vertical\"] = 2] = \"Vertical\";\n        FlipType[FlipType[\"Both\"] = 3] = \"Both\";\n    })(FlipType = fgui.FlipType || (fgui.FlipType = {}));\n    let ChildrenRenderOrder;\n    (function (ChildrenRenderOrder) {\n        ChildrenRenderOrder[ChildrenRenderOrder[\"Ascent\"] = 0] = \"Ascent\";\n        ChildrenRenderOrder[ChildrenRenderOrder[\"Descent\"] = 1] = \"Descent\";\n        ChildrenRenderOrder[ChildrenRenderOrder[\"Arch\"] = 2] = \"Arch\";\n    })(ChildrenRenderOrder = fgui.ChildrenRenderOrder || (fgui.ChildrenRenderOrder = {}));\n    let GroupLayoutType;\n    (function (GroupLayoutType) {\n        GroupLayoutType[GroupLayoutType[\"None\"] = 0] = \"None\";\n        GroupLayoutType[GroupLayoutType[\"Horizontal\"] = 1] = \"Horizontal\";\n        GroupLayoutType[GroupLayoutType[\"Vertical\"] = 2] = \"Vertical\";\n    })(GroupLayoutType = fgui.GroupLayoutType || (fgui.GroupLayoutType = {}));\n    let PopupDirection;\n    (function (PopupDirection) {\n        PopupDirection[PopupDirection[\"Auto\"] = 0] = \"Auto\";\n        PopupDirection[PopupDirection[\"Up\"] = 1] = \"Up\";\n        PopupDirection[PopupDirection[\"Down\"] = 2] = \"Down\";\n    })(PopupDirection = fgui.PopupDirection || (fgui.PopupDirection = {}));\n    let RelationType;\n    (function (RelationType) {\n        RelationType[RelationType[\"Left_Left\"] = 0] = \"Left_Left\";\n        RelationType[RelationType[\"Left_Center\"] = 1] = \"Left_Center\";\n        RelationType[RelationType[\"Left_Right\"] = 2] = \"Left_Right\";\n        RelationType[RelationType[\"Center_Center\"] = 3] = \"Center_Center\";\n        RelationType[RelationType[\"Right_Left\"] = 4] = \"Right_Left\";\n        RelationType[RelationType[\"Right_Center\"] = 5] = \"Right_Center\";\n        RelationType[RelationType[\"Right_Right\"] = 6] = \"Right_Right\";\n        RelationType[RelationType[\"Top_Top\"] = 7] = \"Top_Top\";\n        RelationType[RelationType[\"Top_Middle\"] = 8] = \"Top_Middle\";\n        RelationType[RelationType[\"Top_Bottom\"] = 9] = \"Top_Bottom\";\n        RelationType[RelationType[\"Middle_Middle\"] = 10] = \"Middle_Middle\";\n        RelationType[RelationType[\"Bottom_Top\"] = 11] = \"Bottom_Top\";\n        RelationType[RelationType[\"Bottom_Middle\"] = 12] = \"Bottom_Middle\";\n        RelationType[RelationType[\"Bottom_Bottom\"] = 13] = \"Bottom_Bottom\";\n        RelationType[RelationType[\"Width\"] = 14] = \"Width\";\n        RelationType[RelationType[\"Height\"] = 15] = \"Height\";\n        RelationType[RelationType[\"LeftExt_Left\"] = 16] = \"LeftExt_Left\";\n        RelationType[RelationType[\"LeftExt_Right\"] = 17] = \"LeftExt_Right\";\n        RelationType[RelationType[\"RightExt_Left\"] = 18] = \"RightExt_Left\";\n        RelationType[RelationType[\"RightExt_Right\"] = 19] = \"RightExt_Right\";\n        RelationType[RelationType[\"TopExt_Top\"] = 20] = \"TopExt_Top\";\n        RelationType[RelationType[\"TopExt_Bottom\"] = 21] = \"TopExt_Bottom\";\n        RelationType[RelationType[\"BottomExt_Top\"] = 22] = \"BottomExt_Top\";\n        RelationType[RelationType[\"BottomExt_Bottom\"] = 23] = \"BottomExt_Bottom\";\n        RelationType[RelationType[\"Size\"] = 24] = \"Size\";\n    })(RelationType = fgui.RelationType || (fgui.RelationType = {}));\n    let FillMethod;\n    (function (FillMethod) {\n        FillMethod[FillMethod[\"None\"] = 0] = \"None\";\n        FillMethod[FillMethod[\"Horizontal\"] = 1] = \"Horizontal\";\n        FillMethod[FillMethod[\"Vertical\"] = 2] = \"Vertical\";\n        FillMethod[FillMethod[\"Radial90\"] = 3] = \"Radial90\";\n        FillMethod[FillMethod[\"Radial180\"] = 4] = \"Radial180\";\n        FillMethod[FillMethod[\"Radial360\"] = 5] = \"Radial360\";\n    })(FillMethod = fgui.FillMethod || (fgui.FillMethod = {}));\n    let FillOrigin;\n    (function (FillOrigin) {\n        FillOrigin[FillOrigin[\"Top\"] = 0] = \"Top\";\n        FillOrigin[FillOrigin[\"Bottom\"] = 1] = \"Bottom\";\n        FillOrigin[FillOrigin[\"Left\"] = 2] = \"Left\";\n        FillOrigin[FillOrigin[\"Right\"] = 3] = \"Right\";\n        FillOrigin[FillOrigin[\"TopLeft\"] = 0] = \"TopLeft\";\n        FillOrigin[FillOrigin[\"TopRight\"] = 1] = \"TopRight\";\n        FillOrigin[FillOrigin[\"BottomLeft\"] = 2] = \"BottomLeft\";\n        FillOrigin[FillOrigin[\"BottomRight\"] = 3] = \"BottomRight\";\n    })(FillOrigin = fgui.FillOrigin || (fgui.FillOrigin = {}));\n    let FillOrigin90;\n    (function (FillOrigin90) {\n        FillOrigin90[FillOrigin90[\"TopLeft\"] = 0] = \"TopLeft\";\n        FillOrigin90[FillOrigin90[\"TopRight\"] = 1] = \"TopRight\";\n        FillOrigin90[FillOrigin90[\"BottomLeft\"] = 2] = \"BottomLeft\";\n        FillOrigin90[FillOrigin90[\"BottomRight\"] = 3] = \"BottomRight\";\n    })(FillOrigin90 = fgui.FillOrigin90 || (fgui.FillOrigin90 = {}));\n    let ObjectPropID;\n    (function (ObjectPropID) {\n        ObjectPropID[ObjectPropID[\"Text\"] = 0] = \"Text\";\n        ObjectPropID[ObjectPropID[\"Icon\"] = 1] = \"Icon\";\n        ObjectPropID[ObjectPropID[\"Color\"] = 2] = \"Color\";\n        ObjectPropID[ObjectPropID[\"OutlineColor\"] = 3] = \"OutlineColor\";\n        ObjectPropID[ObjectPropID[\"Playing\"] = 4] = \"Playing\";\n        ObjectPropID[ObjectPropID[\"Frame\"] = 5] = \"Frame\";\n        ObjectPropID[ObjectPropID[\"DeltaTime\"] = 6] = \"DeltaTime\";\n        ObjectPropID[ObjectPropID[\"TimeScale\"] = 7] = \"TimeScale\";\n        ObjectPropID[ObjectPropID[\"FontSize\"] = 8] = \"FontSize\";\n        ObjectPropID[ObjectPropID[\"Selected\"] = 9] = \"Selected\";\n    })(ObjectPropID = fgui.ObjectPropID || (fgui.ObjectPropID = {}));\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GObject {\n        constructor() {\n            this._x = 0;\n            this._y = 0;\n            this._z = 0;\n            this._alpha = 1;\n            this._visible = true;\n            this._touchable = true;\n            this._scaleX = 1;\n            this._scaleY = 1;\n            this._skewX = 0;\n            this._skewY = 0;\n            this._pivotX = 0;\n            this._pivotY = 0;\n            this._sortingOrder = 0;\n            this._internalVisible = true;\n            this.minWidth = 0;\n            this.minHeight = 0;\n            this.maxWidth = 0;\n            this.maxHeight = 0;\n            this.sourceWidth = 0;\n            this.sourceHeight = 0;\n            this.initWidth = 0;\n            this.initHeight = 0;\n            this._width = 0;\n            this._height = 0;\n            this._rawWidth = 0;\n            this._rawHeight = 0;\n            this._sizePercentInGroup = 0;\n            this._dragTouchStartPos = new THREE.Vector2();\n            this._dragTesting = false;\n            this._id = \"\" + fgui.gInstanceCounter++;\n            this._name = \"\";\n            this.createDisplayObject();\n            this._displayObject[\"$owner\"] = this;\n            this._relations = new fgui.Relations(this);\n            this._gears = new Array(10);\n        }\n        get id() {\n            return this._id;\n        }\n        get name() {\n            return this._name;\n        }\n        set name(value) {\n            this._name = value;\n        }\n        get x() {\n            return this._x;\n        }\n        set x(value) {\n            this.setPosition(value, this._y);\n        }\n        get y() {\n            return this._y;\n        }\n        set y(value) {\n            this.setPosition(this._x, value);\n        }\n        get z() {\n            return this._z;\n        }\n        set z(value) {\n            this.setPosition(this._x, this._y, value);\n        }\n        setPosition(xv, yv, zv) {\n            if (this._x != xv || this._y != yv) {\n                var dx = xv - this._x;\n                var dy = yv - this._y;\n                this._x = xv;\n                this._y = yv;\n                if (zv != null)\n                    this._z = zv;\n                this.handlePositionChanged();\n                if (this instanceof fgui.GGroup)\n                    (this).moveChildren(dx, dy);\n                this.updateGear(1);\n                if (this._parent && !(\"itemRenderer\" in this._parent)) {\n                    this._parent.setBoundsChangedFlag();\n                    if (this._group)\n                        this._group.setBoundsChangedFlag(true);\n                    this.dispatchEvent(fgui.DisplayObjectEvent.XY_CHANGED);\n                }\n                if (GObject.draggingObject == this && !s_dragging)\n                    this.localToGlobalRect(0, 0, this.width, this.height, sGlobalRect);\n            }\n        }\n        get xMin() {\n            return this._pivotAsAnchor ? (this._x - this._width * this._pivotX) : this._x;\n        }\n        set xMin(value) {\n            if (this._pivotAsAnchor)\n                this.setPosition(value + this._width * this._pivotX, this._y);\n            else\n                this.setPosition(value, this._y);\n        }\n        get yMin() {\n            return this._pivotAsAnchor ? (this._y - this._height * this._pivotY) : this._y;\n        }\n        set yMin(value) {\n            if (this._pivotAsAnchor)\n                this.setPosition(this._x, value + this._height * this._pivotY);\n            else\n                this.setPosition(this._x, value);\n        }\n        center(restraint) {\n            var r;\n            if (this._parent)\n                r = this.parent;\n            else\n                r = fgui.Decls.GRoot.inst;\n            this.setPosition(Math.floor((r.width - this.width) / 2), Math.floor((r.height - this.height) / 2));\n            if (restraint) {\n                this.addRelation(r, fgui.RelationType.Center_Center);\n                this.addRelation(r, fgui.RelationType.Middle_Middle);\n            }\n        }\n        get width() {\n            return this._width;\n        }\n        set width(value) {\n            this.setSize(value, this._rawHeight);\n        }\n        get height() {\n            return this._height;\n        }\n        set height(value) {\n            this.setSize(this._rawWidth, value);\n        }\n        MakeFullScreen() {\n            if (fgui.GRoot.inst) {\n                this.setSize(fgui.GRoot.inst.width, fgui.GRoot.inst.height);\n            }\n        }\n        setSize(wv, hv, ignorePivot) {\n            if (this._rawWidth != wv || this._rawHeight != hv) {\n                this._rawWidth = wv;\n                this._rawHeight = hv;\n                if (wv < this.minWidth)\n                    wv = this.minWidth;\n                if (hv < this.minHeight)\n                    hv = this.minHeight;\n                if (this.maxWidth > 0 && wv > this.maxWidth)\n                    wv = this.maxWidth;\n                if (this.maxHeight > 0 && hv > this.maxHeight)\n                    hv = this.maxHeight;\n                var dWidth = wv - this._width;\n                var dHeight = hv - this._height;\n                this._width = wv;\n                this._height = hv;\n                this.handleSizeChanged();\n                if (this._pivotX != 0 || this._pivotY != 0) {\n                    if (!this._pivotAsAnchor) {\n                        if (!ignorePivot)\n                            this.setPosition(this.x - this._pivotX * dWidth, this.y - this._pivotY * dHeight);\n                        else\n                            this.handlePositionChanged();\n                    }\n                    else\n                        this.handlePositionChanged();\n                }\n                if (this instanceof fgui.GGroup)\n                    (this).resizeChildren(dWidth, dHeight);\n                this.updateGear(2);\n                if (this._parent) {\n                    this._relations.onOwnerSizeChanged(dWidth, dHeight, this._pivotAsAnchor || !ignorePivot);\n                    this._parent.setBoundsChangedFlag();\n                    if (this._group)\n                        this._group.setBoundsChangedFlag();\n                }\n                this.dispatchEvent(fgui.DisplayObjectEvent.SIZE_CHANGED);\n            }\n        }\n        setSizeDirectly(wv, hv) {\n            this._rawWidth = wv;\n            this._rawHeight = hv;\n            if (wv < 0)\n                wv = 0;\n            if (hv < 0)\n                hv = 0;\n            this._width = wv;\n            this._height = hv;\n        }\n        makeFullScreen() {\n            this.setSize(fgui.Decls.GRoot.inst.width, fgui.Decls.GRoot.inst.height);\n        }\n        get actualWidth() {\n            return this.width * Math.abs(this._scaleX);\n        }\n        get actualHeight() {\n            return this.height * Math.abs(this._scaleY);\n        }\n        get scaleX() {\n            return this._scaleX;\n        }\n        set scaleX(value) {\n            this.setScale(value, this._scaleY);\n        }\n        get scaleY() {\n            return this._scaleY;\n        }\n        set scaleY(value) {\n            this.setScale(this._scaleX, value);\n        }\n        setScale(sx, sy) {\n            if (this._scaleX != sx || this._scaleY != sy) {\n                this._scaleX = sx;\n                this._scaleY = sy;\n                this.handleScaleChanged();\n                this.updateGear(2);\n            }\n        }\n        get skewX() {\n            return this._skewX;\n        }\n        set skewX(value) {\n            this.setSkew(value, this._skewY);\n        }\n        get skewY() {\n            return this._skewY;\n        }\n        set skewY(value) {\n            this.setSkew(this._skewX, value);\n        }\n        setSkew(sx, sy) {\n            if (this._skewX != sx || this._skewY != sy) {\n                this._skewX = sx;\n                this._skewY = sy;\n            }\n        }\n        get pivotX() {\n            return this._pivotX;\n        }\n        set pivotX(value) {\n            this.setPivot(value, this._pivotY);\n        }\n        get pivotY() {\n            return this._pivotY;\n        }\n        set pivotY(value) {\n            this.setPivot(this._pivotX, value);\n        }\n        setPivot(xv, yv, asAnchor) {\n            asAnchor = asAnchor || false;\n            if (this._pivotX != xv || this._pivotY != yv || this._pivotAsAnchor != asAnchor) {\n                this._pivotX = xv;\n                this._pivotY = yv;\n                this._pivotAsAnchor = asAnchor;\n                this._displayObject.setPivot(xv, yv);\n                this.handlePositionChanged();\n            }\n        }\n        get pivotAsAnchor() {\n            return this._pivotAsAnchor;\n        }\n        get touchable() {\n            return this._touchable;\n        }\n        set touchable(value) {\n            if (this._touchable != value) {\n                this._touchable = value;\n                this.updateGear(3);\n                this._displayObject.touchable = this._touchable;\n            }\n        }\n        get grayed() {\n            return this._grayed;\n        }\n        set grayed(value) {\n            if (this._grayed != value) {\n                this._grayed = value;\n                this.handleGrayedChanged();\n                this.updateGear(3);\n            }\n        }\n        get enabled() {\n            return !this._grayed && this._touchable;\n        }\n        set enabled(value) {\n            this.grayed = !value;\n            this.touchable = value;\n        }\n        get rotation() {\n            return this._displayObject.rotation;\n        }\n        set rotation(value) {\n            if (this._displayObject.rotation != value) {\n                this._displayObject.rotation = value;\n                this.updateGear(3);\n            }\n        }\n        get rotationX() {\n            return this._displayObject.rotationX;\n        }\n        set rotationX(value) {\n            this._displayObject.rotationX = value;\n        }\n        get rotationY() {\n            return this._displayObject.rotationY;\n        }\n        set rotationY(value) {\n            this._displayObject.rotationY = value;\n        }\n        get alpha() {\n            return this._alpha;\n        }\n        set alpha(value) {\n            if (this._alpha != value) {\n                this._alpha = value;\n                this.handleAlphaChanged();\n                this.updateGear(3);\n            }\n        }\n        get visible() {\n            return this._visible;\n        }\n        set visible(value) {\n            if (this._visible != value) {\n                this._visible = value;\n                this.handleVisibleChanged();\n                if (this._parent)\n                    this._parent.setBoundsChangedFlag();\n                if (this._group && this._group.excludeInvisibles)\n                    this._group.setBoundsChangedFlag();\n            }\n        }\n        get internalVisible() {\n            return this._internalVisible && (!this._group || this._group.internalVisible);\n        }\n        get internalVisible2() {\n            return this._visible && (!this._group || this._group.internalVisible2);\n        }\n        get internalVisible3() {\n            return this._internalVisible && this._visible;\n        }\n        get sortingOrder() {\n            return this._sortingOrder;\n        }\n        set sortingOrder(value) {\n            if (value < 0)\n                value = 0;\n            if (this._sortingOrder != value) {\n                var old = this._sortingOrder;\n                this._sortingOrder = value;\n                if (this._parent)\n                    this._parent.childSortingOrderChanged(this, old, this._sortingOrder);\n            }\n        }\n        get tooltips() {\n            return this._tooltips;\n        }\n        set tooltips(value) {\n            if (this._tooltips) {\n                this.off(fgui.RollEvent.RollOver, this.__rollOver, this);\n                this.off(fgui.RollEvent.RollOut, this.__rollOut, this);\n            }\n            this._tooltips = value;\n            if (this._tooltips) {\n                this.on(fgui.RollEvent.RollOver, this.__rollOver, this);\n                this.on(fgui.RollEvent.RollOut, this.__rollOut, this);\n            }\n        }\n        __rollOver() {\n            fgui.Timers.callDelay(100, this.__doShowTooltips, this);\n        }\n        __doShowTooltips() {\n            fgui.Decls.GRoot.findFor(this).showTooltips(this._tooltips);\n        }\n        __rollOut() {\n            fgui.Timers.remove(this.__doShowTooltips, this);\n            fgui.Decls.GRoot.findFor(this).hideTooltips();\n        }\n        get blendMode() {\n            return this._displayObject.blendMode;\n        }\n        set blendMode(value) {\n            this._displayObject.blendMode = value;\n        }\n        get onStage() {\n            return this._displayObject.stage != null;\n        }\n        get resourceURL() {\n            if (this.packageItem)\n                return \"ui://\" + this.packageItem.owner.id + this.packageItem.id;\n            else\n                return null;\n        }\n        set group(value) {\n            if (this._group != value) {\n                if (this._group)\n                    this._group.setBoundsChangedFlag();\n                this._group = value;\n                if (this._group)\n                    this._group.setBoundsChangedFlag();\n            }\n        }\n        get group() {\n            return this._group;\n        }\n        getGear(index) {\n            var gear = this._gears[index];\n            if (gear == null)\n                this._gears[index] = gear = createGear(this, index);\n            return gear;\n        }\n        updateGear(index) {\n            if (this._underConstruct || this._gearLocked)\n                return;\n            var gear = this._gears[index];\n            if (gear && gear.controller)\n                gear.updateState();\n        }\n        checkGearController(index, c) {\n            return this._gears[index] && this._gears[index].controller == c;\n        }\n        updateGearFromRelations(index, dx, dy) {\n            if (this._gears[index])\n                this._gears[index].updateFromRelations(dx, dy);\n        }\n        addDisplayLock() {\n            var gearDisplay = (this._gears[0]);\n            if (gearDisplay && gearDisplay.controller) {\n                var ret = gearDisplay.addLock();\n                this.checkGearDisplay();\n                return ret;\n            }\n            else\n                return 0;\n        }\n        releaseDisplayLock(token) {\n            var gearDisplay = (this._gears[0]);\n            if (gearDisplay && gearDisplay.controller) {\n                gearDisplay.releaseLock(token);\n                this.checkGearDisplay();\n            }\n        }\n        checkGearDisplay() {\n            if (this._handlingController)\n                return;\n            var connected = this._gears[0] == null || (this._gears[0]).connected;\n            if (this._gears[8])\n                connected = this._gears[8].evaluate(connected);\n            if (connected != this._internalVisible) {\n                this._internalVisible = connected;\n                if (this._parent) {\n                    this._parent.childStateChanged(this);\n                    if (this._group && this._group.excludeInvisibles)\n                        this._group.setBoundsChangedFlag();\n                }\n            }\n        }\n        get relations() {\n            return this._relations;\n        }\n        addRelation(target, relationType, usePercent) {\n            this._relations.add(target, relationType, usePercent);\n        }\n        removeRelation(target, relationType) {\n            this._relations.remove(target, relationType);\n        }\n        get displayObject() {\n            return this._displayObject;\n        }\n        get obj3D() {\n            return this._displayObject.obj3D;\n        }\n        get parent() {\n            return this._parent;\n        }\n        set parent(val) {\n            this._parent = val;\n        }\n        removeFromParent() {\n            if (this._parent)\n                this._parent.removeChild(this);\n        }\n        get asCom() {\n            return this;\n        }\n        get text() {\n            return null;\n        }\n        set text(value) {\n        }\n        get icon() {\n            return null;\n        }\n        set icon(value) {\n        }\n        get treeNode() {\n            return this._treeNode;\n        }\n        get isDisposed() {\n            return this._displayObject == null;\n        }\n        dispose() {\n            this.removeFromParent();\n            this._relations.dispose();\n            this._displayObject.dispose();\n            this._displayObject = null;\n            for (var i = 0; i < 10; i++) {\n                var gear = this._gears[i];\n                if (gear)\n                    gear.dispose();\n            }\n        }\n        on(type, callback, target, capture) {\n            this._displayObject.on(type, callback, target, capture);\n        }\n        off(type, callback, target, capture) {\n            this._displayObject.off(type, callback, target, capture);\n        }\n        offAll(type) {\n            this._displayObject.offAll(type);\n        }\n        hasListener(type, callback, target, capture) {\n            return this._displayObject.hasListener(type, callback, target, capture);\n        }\n        dispatchEvent(type, data) {\n            return this._displayObject.dispatchEvent(type, data);\n        }\n        onClick(listener, target) {\n            this.on(fgui.InteractiveEvents.Click, listener, target);\n        }\n        offClick(listener, target) {\n            this.off(fgui.InteractiveEvents.Click, listener, target);\n        }\n        hasClickListener() {\n            return this.hasListener(fgui.InteractiveEvents.Click);\n        }\n        get draggable() {\n            return this._draggable;\n        }\n        set draggable(value) {\n            if (this._draggable != value) {\n                this._draggable = value;\n                this.initDrag();\n            }\n        }\n        get dragBounds() {\n            return this._dragBounds;\n        }\n        set dragBounds(value) {\n            this._dragBounds = value;\n        }\n        startDrag(touchId) {\n            if (this._displayObject.stage == null)\n                return;\n            if (touchId == null)\n                touchId = -1;\n            this.dragBegin(touchId);\n        }\n        stopDrag() {\n            this.dragEnd();\n        }\n        get dragging() {\n            return GObject.draggingObject == this;\n        }\n        localToGlobal(ax, ay, result) {\n            ax = ax || 0;\n            ay = ay || 0;\n            if (this._pivotAsAnchor) {\n                ax += this._pivotX * this._width;\n                ay += this._pivotY * this._height;\n            }\n            return this._displayObject.localToGlobal(ax, ay, result);\n        }\n        globalToLocal(ax, ay, result) {\n            ax = ax || 0;\n            ay = ay || 0;\n            result = this._displayObject.globalToLocal(ax, ay, result);\n            if (this._pivotAsAnchor) {\n                result.x -= this._pivotX * this._width;\n                result.y -= this._pivotY * this._height;\n            }\n            return result;\n        }\n        localToRoot(ax, ay, result) {\n            let r = fgui.Decls.GRoot.findFor(this);\n            let pt = this.localToGlobal(ax, ay, result);\n            return r.globalToLocal(pt.x, pt.y, pt);\n        }\n        rootToLocal(ax, ay, result) {\n            let r = fgui.Decls.GRoot.findFor(this);\n            let pt = r.localToGlobal(ax, ay, result);\n            return this.globalToLocal(pt.x, pt.y, pt);\n        }\n        localToGlobalRect(ax, ay, aWidth, aHeight, result) {\n            if (!result)\n                result = new fgui.Rect();\n            var pt = this.localToGlobal(ax, ay, s_vec2);\n            result.x = pt.x;\n            result.y = pt.y;\n            pt = this.localToGlobal(ax + aWidth, ay + aHeight, s_vec2);\n            result.width = pt.x - result.x;\n            result.height = pt.y - result.y;\n            return result;\n        }\n        globalToLocalRect(ax, ay, aWidth, aHeight, result) {\n            if (!result)\n                result = new fgui.Rect();\n            var pt = this.globalToLocal(ax, ay, s_vec2);\n            result.x = pt.x;\n            result.y = pt.y;\n            pt = this.globalToLocal(ax + aWidth, ay + aHeight, s_vec2);\n            result.width = pt.x - result.x;\n            result.height = pt.y - result.y;\n            return result;\n        }\n        handleControllerChanged(c) {\n            this._handlingController = true;\n            for (var i = 0; i < 10; i++) {\n                var gear = this._gears[i];\n                if (gear && gear.controller == c)\n                    gear.apply();\n            }\n            this._handlingController = false;\n            this.checkGearDisplay();\n        }\n        createDisplayObject() {\n            this._displayObject = new fgui.DisplayObject();\n        }\n        handlePositionChanged() {\n            var xv = this._x;\n            var yv = this._y;\n            if (!this._pivotAsAnchor) {\n                xv += this._pivotX * this._width;\n                yv += this._pivotY * this._height;\n            }\n            this._displayObject.setPosition(xv, yv, this._z, true);\n        }\n        handleSizeChanged() {\n            this._displayObject.setSize(this._width, this._height);\n        }\n        handleScaleChanged() {\n            this._displayObject.setScale(this._scaleX, this._scaleY);\n        }\n        handleGrayedChanged() {\n            if (this._displayObject.graphics)\n                this._displayObject.graphics.grayed = this._grayed;\n        }\n        handleAlphaChanged() {\n            this._displayObject.alpha = this._alpha;\n        }\n        handleVisibleChanged() {\n            this._displayObject.visible = this.internalVisible2;\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Text:\n                    return this.text;\n                case fgui.ObjectPropID.Icon:\n                    return this.icon;\n                case fgui.ObjectPropID.Color:\n                    return null;\n                case fgui.ObjectPropID.OutlineColor:\n                    return null;\n                case fgui.ObjectPropID.Playing:\n                    return false;\n                case fgui.ObjectPropID.Frame:\n                    return 0;\n                case fgui.ObjectPropID.DeltaTime:\n                    return 0;\n                case fgui.ObjectPropID.TimeScale:\n                    return 1;\n                case fgui.ObjectPropID.FontSize:\n                    return 0;\n                case fgui.ObjectPropID.Selected:\n                    return false;\n                default:\n                    return undefined;\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Text:\n                    this.text = value;\n                    break;\n                case fgui.ObjectPropID.Icon:\n                    this.icon = value;\n                    break;\n            }\n        }\n        constructFromResource() {\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            buffer.seek(beginPos, 0);\n            buffer.skip(5);\n            var f1;\n            var f2;\n            this._id = buffer.readS();\n            this._name = buffer.readS();\n            f1 = buffer.readInt();\n            f2 = buffer.readInt();\n            this.setPosition(f1, f2);\n            if (buffer.readBool()) {\n                this.initWidth = buffer.readInt();\n                this.initHeight = buffer.readInt();\n                this.setSize(this.initWidth, this.initHeight, true);\n            }\n            if (buffer.readBool()) {\n                this.minWidth = buffer.readInt();\n                this.maxWidth = buffer.readInt();\n                this.minHeight = buffer.readInt();\n                this.maxHeight = buffer.readInt();\n            }\n            if (buffer.readBool()) {\n                f1 = buffer.readFloat();\n                f2 = buffer.readFloat();\n                this.setScale(f1, f2);\n            }\n            if (buffer.readBool()) {\n                f1 = buffer.readFloat();\n                f2 = buffer.readFloat();\n                this.setSkew(f1, f2);\n            }\n            if (buffer.readBool()) {\n                f1 = buffer.readFloat();\n                f2 = buffer.readFloat();\n                this.setPivot(f1, f2, buffer.readBool());\n            }\n            f1 = buffer.readFloat();\n            if (f1 != 1)\n                this.alpha = f1;\n            f1 = buffer.readFloat();\n            if (f1 != 0)\n                this.rotation = f1;\n            if (!buffer.readBool())\n                this.visible = false;\n            if (!buffer.readBool())\n                this.touchable = false;\n            if (buffer.readBool())\n                this.grayed = true;\n            var bm = buffer.readByte();\n            this.blendMode = BlendModeTranslate[bm] || THREE.NormalBlending;\n            var filter = buffer.readByte();\n            if (filter == 1) {\n            }\n            var str = buffer.readS();\n            if (str != null)\n                this.data = str;\n        }\n        setup_afterAdd(buffer, beginPos) {\n            buffer.seek(beginPos, 1);\n            var str = buffer.readS();\n            if (str)\n                this.tooltips = str;\n            var groupId = buffer.readShort();\n            if (groupId >= 0)\n                this.group = this.parent.getChildAt(groupId);\n            buffer.seek(beginPos, 2);\n            var cnt = buffer.readShort();\n            for (var i = 0; i < cnt; i++) {\n                var nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                var gear = this.getGear(buffer.readByte());\n                gear.setup(buffer);\n                buffer.pos = nextPos;\n            }\n        }\n        initDrag() {\n            if (this._draggable) {\n                this.on(fgui.InteractiveEvents.Down, this.__touchBegin, this);\n                this.on(fgui.InteractiveEvents.Move, this.__touchMove, this);\n                this.on(fgui.InteractiveEvents.Up, this.__touchEnd, this);\n            }\n            else {\n                this.off(fgui.InteractiveEvents.Down, this.__touchBegin, this);\n                this.off(fgui.InteractiveEvents.Move, this.__touchMove, this);\n                this.off(fgui.InteractiveEvents.Up, this.__touchEnd, this);\n            }\n        }\n        dragBegin(touchId) {\n            if (GObject.draggingObject) {\n                let tmp = GObject.draggingObject;\n                GObject.draggingObject.stopDrag();\n                GObject.draggingObject = null;\n                tmp.dispatchEvent(fgui.DragEvent.END);\n            }\n            this.on(fgui.InteractiveEvents.Move, this.__touchMove, this);\n            this.on(fgui.InteractiveEvents.Up, this.__touchEnd, this);\n            fgui.Stage.getTouchPos(touchId, sGlobalDragStart);\n            this.localToGlobalRect(0, 0, this.width, this.height, sGlobalRect);\n            this._dragTesting = false;\n            GObject.draggingObject = this;\n            fgui.Stage.addTouchMonitor(touchId, this._displayObject);\n        }\n        dragEnd() {\n            if (GObject.draggingObject == this) {\n                this._dragTesting = false;\n                GObject.draggingObject = null;\n            }\n        }\n        __touchBegin(evt) {\n            if (this._dragTouchStartPos == null)\n                this._dragTouchStartPos = new THREE.Vector2();\n            this._dragTouchStartPos.set(evt.input.x, evt.input.y);\n            this._dragTesting = true;\n            evt.captureTouch();\n        }\n        __touchMove(evt) {\n            if (this._dragTesting && GObject.draggingObject != this) {\n                let sensitivity;\n                if (fgui.Stage.touchScreen)\n                    sensitivity = fgui.UIConfig.touchDragSensitivity;\n                else\n                    sensitivity = fgui.UIConfig.clickDragSensitivity;\n                if (Math.abs(this._dragTouchStartPos.x - evt.input.x) < sensitivity\n                    && Math.abs(this._dragTouchStartPos.y - evt.input.y) < sensitivity)\n                    return;\n                this._dragTesting = false;\n                if (!this.dispatchEvent(fgui.DragEvent.START, evt.input.touchId))\n                    this.dragBegin(evt.input.touchId);\n            }\n            if (GObject.draggingObject == this) {\n                let xx = evt.input.x - sGlobalDragStart.x + sGlobalRect.x;\n                let yy = evt.input.y - sGlobalDragStart.y + sGlobalRect.y;\n                if (this._dragBounds) {\n                    let rect = fgui.Decls.GRoot.findFor(this).localToGlobalRect(this._dragBounds.x, this._dragBounds.y, this._dragBounds.width, this._dragBounds.height, s_rect);\n                    if (xx < rect.x)\n                        xx = rect.x;\n                    else if (xx + sGlobalRect.width > rect.xMax) {\n                        xx = rect.xMax - sGlobalRect.width;\n                        if (xx < rect.x)\n                            xx = rect.x;\n                    }\n                    if (yy < rect.y)\n                        yy = rect.y;\n                    else if (yy + sGlobalRect.height > rect.yMax) {\n                        yy = rect.yMax - sGlobalRect.height;\n                        if (yy < rect.y)\n                            yy = rect.y;\n                    }\n                }\n                let pt = this.parent.globalToLocal(xx, yy, s_vec2);\n                s_dragging = true;\n                this.setPosition(Math.round(pt.x), Math.round(pt.y));\n                s_dragging = false;\n                this.dispatchEvent(fgui.DragEvent.MOVING);\n            }\n        }\n        __touchEnd() {\n            if (GObject.draggingObject == this) {\n                GObject.draggingObject = null;\n                this.dispatchEvent(fgui.DragEvent.END);\n            }\n        }\n        static cast(obj) {\n            let dobj;\n            if (obj instanceof THREE.Object3D) {\n                dobj = obj[\"$owner\"];\n                if (!dobj)\n                    return null;\n            }\n            else\n                dobj = obj;\n            return dobj['$owner'];\n        }\n    }\n    fgui.GObject = GObject;\n    let GearClasses = [\n        fgui.GearDisplay, fgui.GearXY, fgui.GearSize, fgui.GearLook, fgui.GearColor,\n        fgui.GearAnimation, fgui.GearText, fgui.GearIcon, fgui.GearDisplay2, fgui.GearFontSize\n    ];\n    function createGear(owner, index) {\n        let ret = new (GearClasses[index])();\n        ret._owner = owner;\n        return ret;\n    }\n    var s_vec2 = new THREE.Vector2();\n    var s_rect = new fgui.Rect();\n    var sGlobalDragStart = new THREE.Vector2();\n    var sGlobalRect = new fgui.Rect();\n    var s_dragging;\n    const BlendModeTranslate = {\n        0: THREE.NormalBlending,\n        1: THREE.NoBlending,\n        2: THREE.AdditiveBlending,\n        3: THREE.MultiplyBlending,\n        4: THREE.SubtractiveBlending,\n    };\n    fgui.gInstanceCounter = 0;\n    fgui.constructingDepth = { n: 0 };\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GComponent extends fgui.GObject {\n        constructor() {\n            super();\n            this._sortingChildCount = 0;\n            this._children = [];\n            this._controllers = [];\n            this._transitions = [];\n            this._margin = new fgui.Margin();\n            this._alignOffset = new THREE.Vector2();\n            this._childrenRenderOrder = 0;\n            this._apexIndex = 0;\n        }\n        createDisplayObject() {\n            super.createDisplayObject();\n            this._container = new fgui.DisplayObject();\n            this._displayObject = this._container;\n        }\n        dispose() {\n            var i;\n            var cnt;\n            cnt = this._transitions.length;\n            for (i = 0; i < cnt; ++i) {\n                var trans = this._transitions[i];\n                trans.dispose();\n            }\n            cnt = this._controllers.length;\n            for (i = 0; i < cnt; ++i) {\n                var cc = this._controllers[i];\n                cc.dispose();\n            }\n            if (this.scrollPane)\n                this.scrollPane.dispose();\n            cnt = this._children.length;\n            for (i = cnt - 1; i >= 0; --i) {\n                var obj = this._children[i];\n                obj.parent = null;\n                obj.dispose();\n            }\n            this._boundsChanged = false;\n            super.dispose();\n        }\n        get displayListContainer() {\n            return this._container;\n        }\n        addChild(child) {\n            this.addChildAt(child, this._children.length);\n            return child;\n        }\n        addChildAt(child, index) {\n            if (!child)\n                throw \"child is null\";\n            if (index >= 0 && index <= this._children.length) {\n                if (child.parent == this) {\n                    this.setChildIndex(child, index);\n                }\n                else {\n                    child.removeFromParent();\n                    child.parent = this;\n                    var cnt = this._children.length;\n                    if (child.sortingOrder != 0) {\n                        this._sortingChildCount++;\n                        index = this.getInsertPosForSortingChild(child);\n                    }\n                    else if (this._sortingChildCount > 0) {\n                        if (index > (cnt - this._sortingChildCount))\n                            index = cnt - this._sortingChildCount;\n                    }\n                    if (index == cnt)\n                        this._children.push(child);\n                    else\n                        this._children.splice(index, 0, child);\n                    this.childStateChanged(child);\n                    this.setBoundsChangedFlag();\n                }\n                return child;\n            }\n            else {\n                throw \"Invalid child index\";\n            }\n        }\n        getInsertPosForSortingChild(target) {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; i++) {\n                var child = this._children[i];\n                if (child == target)\n                    continue;\n                if (target.sortingOrder < child.sortingOrder)\n                    break;\n            }\n            return i;\n        }\n        removeChild(child, dispose) {\n            var childIndex = this._children.indexOf(child);\n            if (childIndex != -1) {\n                this.removeChildAt(childIndex, dispose);\n            }\n            return child;\n        }\n        removeChildAt(index, dispose) {\n            if (index >= 0 && index < this._children.length) {\n                var child = this._children[index];\n                child.parent = null;\n                if (child.sortingOrder != 0)\n                    this._sortingChildCount--;\n                this._children.splice(index, 1);\n                child.group = null;\n                if (child.displayObject.parent) {\n                    this._container.removeChild(child.displayObject);\n                    if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Arch)\n                        fgui.Timers.callLater(this.buildNativeDisplayList, this);\n                }\n                if (dispose)\n                    child.dispose();\n                this.setBoundsChangedFlag();\n                return child;\n            }\n            else {\n                throw \"Invalid child index\";\n            }\n        }\n        removeChildren(beginIndex, endIndex, dispose) {\n            beginIndex = beginIndex || 0;\n            if (endIndex == null)\n                endIndex = -1;\n            if (endIndex < 0 || endIndex >= this._children.length)\n                endIndex = this._children.length - 1;\n            for (var i = beginIndex; i <= endIndex; ++i)\n                this.removeChildAt(beginIndex, dispose);\n        }\n        getChildAt(index) {\n            if (index >= 0 && index < this._children.length)\n                return this._children[index];\n            else\n                throw \"Invalid child index\";\n        }\n        getChild(name) {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                if (this._children[i].name == name)\n                    return this._children[i];\n            }\n            return null;\n        }\n        getChildByPath(path) {\n            var arr = path.split(\".\");\n            var cnt = arr.length;\n            var gcom = this;\n            var obj;\n            for (var i = 0; i < cnt; ++i) {\n                obj = gcom.getChild(arr[i]);\n                if (!obj)\n                    break;\n                if (i != cnt - 1) {\n                    if (!(gcom instanceof GComponent)) {\n                        obj = null;\n                        break;\n                    }\n                    else\n                        gcom = obj;\n                }\n            }\n            return obj;\n        }\n        getVisibleChild(name) {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                var child = this._children[i];\n                if (child.internalVisible && child.internalVisible2 && child.name == name)\n                    return child;\n            }\n            return null;\n        }\n        getChildInGroup(name, group) {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                var child = this._children[i];\n                if (child.group == group && child.name == name)\n                    return child;\n            }\n            return null;\n        }\n        getChildById(id) {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                if (this._children[i]._id == id)\n                    return this._children[i];\n            }\n            return null;\n        }\n        getChildIndex(child) {\n            return this._children.indexOf(child);\n        }\n        setChildIndex(child, index) {\n            var oldIndex = this._children.indexOf(child);\n            if (oldIndex == -1)\n                throw \"Not a child of this container\";\n            if (child.sortingOrder != 0)\n                return;\n            var cnt = this._children.length;\n            if (this._sortingChildCount > 0) {\n                if (index > (cnt - this._sortingChildCount - 1))\n                    index = cnt - this._sortingChildCount - 1;\n            }\n            this._setChildIndex(child, oldIndex, index);\n        }\n        setChildIndexBefore(child, index) {\n            var oldIndex = this._children.indexOf(child);\n            if (oldIndex == -1)\n                throw \"Not a child of this container\";\n            if (child.sortingOrder != 0)\n                return oldIndex;\n            var cnt = this._children.length;\n            if (this._sortingChildCount > 0) {\n                if (index > (cnt - this._sortingChildCount - 1))\n                    index = cnt - this._sortingChildCount - 1;\n            }\n            if (oldIndex < index)\n                return this._setChildIndex(child, oldIndex, index - 1);\n            else\n                return this._setChildIndex(child, oldIndex, index);\n        }\n        _setChildIndex(child, oldIndex, index) {\n            var cnt = this._children.length;\n            if (index > cnt)\n                index = cnt;\n            if (oldIndex == index)\n                return oldIndex;\n            this._children.splice(oldIndex, 1);\n            this._children.splice(index, 0, child);\n            if (child.displayObject.parent) {\n                var displayIndex = 0;\n                var g;\n                var i;\n                if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Ascent) {\n                    for (i = 0; i < index; i++) {\n                        g = this._children[i];\n                        if (g.displayObject.parent)\n                            displayIndex++;\n                    }\n                    if (displayIndex == this._container.numChildren)\n                        displayIndex--;\n                    this._container.setChildIndex(child.displayObject, displayIndex);\n                }\n                else if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Descent) {\n                    for (i = cnt - 1; i > index; i--) {\n                        g = this._children[i];\n                        if (g.displayObject.parent)\n                            displayIndex++;\n                    }\n                    if (displayIndex == this._container.numChildren)\n                        displayIndex--;\n                    this._container.setChildIndex(child.displayObject, displayIndex);\n                }\n                else {\n                    fgui.Timers.callLater(this.buildNativeDisplayList, this);\n                }\n                this.setBoundsChangedFlag();\n            }\n            return index;\n        }\n        swapChildren(child1, child2) {\n            var index1 = this._children.indexOf(child1);\n            var index2 = this._children.indexOf(child2);\n            if (index1 == -1 || index2 == -1)\n                throw \"Not a child of this container\";\n            this.swapChildrenAt(index1, index2);\n        }\n        swapChildrenAt(index1, index2) {\n            var child1 = this._children[index1];\n            var child2 = this._children[index2];\n            this.setChildIndex(child1, index2);\n            this.setChildIndex(child2, index1);\n        }\n        get numChildren() {\n            return this._children.length;\n        }\n        isAncestorOf(child) {\n            if (child == null)\n                return false;\n            var p = child.parent;\n            while (p) {\n                if (p == this)\n                    return true;\n                p = p.parent;\n            }\n            return false;\n        }\n        addController(controller) {\n            this._controllers.push(controller);\n            controller.parent = this;\n            this.applyController(controller);\n        }\n        getControllerAt(index) {\n            return this._controllers[index];\n        }\n        getController(name) {\n            var cnt = this._controllers.length;\n            for (var i = 0; i < cnt; ++i) {\n                var c = this._controllers[i];\n                if (c.name == name)\n                    return c;\n            }\n            return null;\n        }\n        removeController(c) {\n            var index = this._controllers.indexOf(c);\n            if (index == -1)\n                throw new Error(\"controller not exists\");\n            c.parent = null;\n            this._controllers.splice(index, 1);\n            var length = this._children.length;\n            for (var i = 0; i < length; i++) {\n                var child = this._children[i];\n                child.handleControllerChanged(c);\n            }\n        }\n        get controllers() {\n            return this._controllers;\n        }\n        childStateChanged(child) {\n            if (this._buildingDisplayList)\n                return;\n            var cnt = this._children.length;\n            if (child instanceof fgui.GGroup) {\n                for (let i = 0; i < cnt; i++) {\n                    let g = this._children[i];\n                    if (g.group == child)\n                        this.childStateChanged(g);\n                }\n                return;\n            }\n            if (child.internalVisible) {\n                if (!child.displayObject.parent) {\n                    var index = 0;\n                    if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Ascent) {\n                        for (let i = 0; i < cnt; i++) {\n                            let g = this._children[i];\n                            if (g == child)\n                                break;\n                            if (g.displayObject.parent)\n                                index++;\n                        }\n                        this._container.addChildAt(child.displayObject, index);\n                    }\n                    else if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Descent) {\n                        for (let i = cnt - 1; i >= 0; i--) {\n                            let g = this._children[i];\n                            if (g == child)\n                                break;\n                            if (g.displayObject.parent)\n                                index++;\n                        }\n                        this._container.addChildAt(child.displayObject, index);\n                    }\n                    else {\n                        this._container.addChild(child.displayObject);\n                        fgui.Timers.callLater(this.buildNativeDisplayList, this);\n                    }\n                }\n            }\n            else {\n                if (child.displayObject.parent) {\n                    this._container.removeChild(child.displayObject);\n                    if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Arch)\n                        fgui.Timers.callLater(this.buildNativeDisplayList, this);\n                }\n            }\n        }\n        buildNativeDisplayList() {\n            if (!this._displayObject)\n                return;\n            var cnt = this._children.length;\n            if (cnt == 0)\n                return;\n            switch (this._childrenRenderOrder) {\n                case fgui.ChildrenRenderOrder.Ascent:\n                    {\n                        for (let i = 0; i < cnt; i++) {\n                            let g = this._children[i];\n                            if (g.internalVisible)\n                                this._container.addChild(g.displayObject);\n                        }\n                    }\n                    break;\n                case fgui.ChildrenRenderOrder.Descent:\n                    {\n                        for (let i = cnt - 1; i >= 0; i--) {\n                            let g = this._children[i];\n                            if (g.internalVisible)\n                                this._container.addChild(g.displayObject);\n                        }\n                    }\n                    break;\n                case fgui.ChildrenRenderOrder.Arch:\n                    {\n                        var apex = fgui.clamp(this._apexIndex, 0, cnt);\n                        for (let i = 0; i < apex; i++) {\n                            let g = this._children[i];\n                            if (g.internalVisible)\n                                this._container.addChild(g.displayObject);\n                        }\n                        for (let i = cnt - 1; i >= apex; i--) {\n                            let g = this._children[i];\n                            if (g.internalVisible)\n                                this._container.addChild(g.displayObject);\n                        }\n                    }\n                    break;\n            }\n        }\n        applyController(c) {\n            this._applyingController = c;\n            var child;\n            var length = this._children.length;\n            for (var i = 0; i < length; i++) {\n                child = this._children[i];\n                child.handleControllerChanged(c);\n            }\n            this._applyingController = null;\n            c.runActions();\n        }\n        applyAllControllers() {\n            var cnt = this._controllers.length;\n            for (var i = 0; i < cnt; ++i) {\n                this.applyController(this._controllers[i]);\n            }\n        }\n        adjustRadioGroupDepth(obj, c) {\n            var cnt = this._children.length;\n            var myIndex = -1, maxIndex = -1;\n            for (let i = 0; i < cnt; i++) {\n                let child = this._children[i];\n                if (child == obj) {\n                    myIndex = i;\n                }\n                else if ((\"relatedController\" in child) && child.relatedController == c) {\n                    if (i > maxIndex)\n                        maxIndex = i;\n                }\n            }\n            if (myIndex < maxIndex) {\n                if (this._applyingController)\n                    this._children[maxIndex].handleControllerChanged(this._applyingController);\n                this.swapChildrenAt(myIndex, maxIndex);\n            }\n        }\n        getTransitionAt(index) {\n            return this._transitions[index];\n        }\n        getTransition(transName) {\n            var cnt = this._transitions.length;\n            for (var i = 0; i < cnt; ++i) {\n                var trans = this._transitions[i];\n                if (trans.name == transName)\n                    return trans;\n            }\n            return null;\n        }\n        isChildInView(child) {\n            if (this._displayObject.clipRect) {\n                return child.x + child.width >= 0 && child.x <= this.width\n                    && child.y + child.height >= 0 && child.y <= this.height;\n            }\n            else if (this._scrollPane) {\n                return this._scrollPane.isChildInView(child);\n            }\n            else\n                return true;\n        }\n        getFirstChildInView() {\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                var child = this._children[i];\n                if (this.isChildInView(child))\n                    return i;\n            }\n            return -1;\n        }\n        get scrollPane() {\n            return this._scrollPane;\n        }\n        get opaque() {\n            return this._displayObject.opaque;\n        }\n        set opaque(value) {\n            this._displayObject.opaque = value;\n        }\n        get margin() {\n            return this._margin;\n        }\n        set margin(value) {\n            this._margin.copy(value);\n            if (this._displayObject.clipRect) {\n                this._container.setPosition(this._margin.left + this._alignOffset.x, this._margin.top + this._alignOffset.y);\n            }\n            this.handleSizeChanged();\n        }\n        get childrenRenderOrder() {\n            return this._childrenRenderOrder;\n        }\n        set childrenRenderOrder(value) {\n            if (this._childrenRenderOrder != value) {\n                this._childrenRenderOrder = value;\n                this.buildNativeDisplayList();\n            }\n        }\n        get apexIndex() {\n            return this._apexIndex;\n        }\n        set apexIndex(value) {\n            if (this._apexIndex != value) {\n                this._apexIndex = value;\n                if (this._childrenRenderOrder == fgui.ChildrenRenderOrder.Arch)\n                    this.buildNativeDisplayList();\n            }\n        }\n        get baseUserData() {\n            var buffer = this.packageItem.rawData;\n            buffer.seek(0, 4);\n            return buffer.readS();\n        }\n        updateMask() {\n            var rect = this._displayObject.clipRect;\n            if (rect == null)\n                rect = new fgui.Rect();\n            rect.x = this._margin.left;\n            rect.y = this._margin.top;\n            rect.width = this._width - this._margin.right;\n            rect.height = this._height - this._margin.bottom;\n            this._displayObject.clipRect = rect;\n        }\n        setupScroll(buffer) {\n            if (this._displayObject == this._container) {\n                this._container = new fgui.DisplayObject();\n                this._displayObject.addChild(this._container);\n            }\n            this._scrollPane = new fgui.ScrollPane(this);\n            this._scrollPane.setup(buffer);\n        }\n        setupOverflow(overflow) {\n            if (overflow == fgui.OverflowType.Hidden) {\n                if (this._displayObject == this._container) {\n                    this._container = new fgui.DisplayObject();\n                    this._displayObject.addChild(this._container);\n                }\n                this.updateMask();\n                this._container.setPosition(this._margin.left, this._margin.top);\n            }\n            else if (this._margin.left != 0 || this._margin.top != 0) {\n                if (this._displayObject == this._container) {\n                    this._container = new fgui.DisplayObject();\n                    this._displayObject.addChild(this._container);\n                }\n                this._container.setPosition(this._margin.left, this._margin.top);\n            }\n        }\n        handleSizeChanged() {\n            super.handleSizeChanged();\n            if (this._scrollPane)\n                this._scrollPane.onOwnerSizeChanged();\n            else if (this._displayObject.clipRect)\n                this.updateMask();\n        }\n        handleGrayedChanged() {\n            var c = this.getController(\"grayed\");\n            if (c) {\n                c.selectedIndex = this.grayed ? 1 : 0;\n                return;\n            }\n            var v = this.grayed;\n            var cnt = this._children.length;\n            for (var i = 0; i < cnt; ++i) {\n                this._children[i].grayed = v;\n            }\n        }\n        handleControllerChanged(c) {\n            super.handleControllerChanged(c);\n            if (this._scrollPane)\n                this._scrollPane.handleControllerChanged(c);\n        }\n        setBoundsChangedFlag() {\n            if (!this._scrollPane && !this._trackBounds)\n                return;\n            if (!this._boundsChanged) {\n                this._boundsChanged = true;\n                fgui.Timers.callLater(this.__render, this);\n            }\n        }\n        __render() {\n            if (this._boundsChanged) {\n                this.updateBounds();\n            }\n        }\n        ensureBoundsCorrect() {\n            if (this._boundsChanged)\n                this.updateBounds();\n        }\n        updateBounds() {\n            var ax = 0, ay = 0, aw = 0, ah = 0;\n            var len = this._children.length;\n            if (len > 0) {\n                ax = Number.POSITIVE_INFINITY, ay = Number.POSITIVE_INFINITY;\n                var ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;\n                var tmp = 0;\n                var i1 = 0;\n                for (i1 = 0; i1 < len; i1++) {\n                    var child = this._children[i1];\n                    tmp = child.x;\n                    if (tmp < ax)\n                        ax = tmp;\n                    tmp = child.y;\n                    if (tmp < ay)\n                        ay = tmp;\n                    tmp = child.x + child.actualWidth;\n                    if (tmp > ar)\n                        ar = tmp;\n                    tmp = child.y + child.actualHeight;\n                    if (tmp > ab)\n                        ab = tmp;\n                }\n                aw = ar - ax;\n                ah = ab - ay;\n            }\n            this.setBounds(ax, ay, aw, ah);\n        }\n        setBounds(ax, ay, aw, ah) {\n            this._boundsChanged = false;\n            if (this._scrollPane)\n                this._scrollPane.setContentSize(Math.round(ax + aw), Math.round(ay + ah));\n        }\n        get viewWidth() {\n            if (this._scrollPane)\n                return this._scrollPane.viewWidth;\n            else\n                return this.width - this._margin.left - this._margin.right;\n        }\n        set viewWidth(value) {\n            if (this._scrollPane)\n                this._scrollPane.viewWidth = value;\n            else\n                this.width = value + this._margin.left + this._margin.right;\n        }\n        get viewHeight() {\n            if (this._scrollPane)\n                return this._scrollPane.viewHeight;\n            else\n                return this.height - this._margin.top - this._margin.bottom;\n        }\n        set viewHeight(value) {\n            if (this._scrollPane)\n                this._scrollPane.viewHeight = value;\n            else\n                this.height = value + this._margin.top + this._margin.bottom;\n        }\n        getSnappingPosition(xValue, yValue, resultPoint) {\n            return this.getSnappingPositionWithDir(xValue, yValue, 0, 0, resultPoint);\n        }\n        getSnappingPositionWithDir(xValue, yValue, xDir, yDir, resultPoint) {\n            if (!resultPoint)\n                resultPoint = new THREE.Vector2();\n            var cnt = this._children.length;\n            if (cnt == 0) {\n                resultPoint.x = 0;\n                resultPoint.y = 0;\n                return resultPoint;\n            }\n            this.ensureBoundsCorrect();\n            var obj = null;\n            var prev = null;\n            var i = 0;\n            if (yValue != 0) {\n                for (; i < cnt; i++) {\n                    obj = this._children[i];\n                    if (yValue < obj.y) {\n                        if (i == 0) {\n                            yValue = 0;\n                            break;\n                        }\n                        else {\n                            prev = this._children[i - 1];\n                            if (yValue < prev.y + prev.actualHeight / 2)\n                                yValue = prev.y;\n                            else\n                                yValue = obj.y;\n                            break;\n                        }\n                    }\n                }\n                if (i == cnt)\n                    yValue = obj.y;\n            }\n            if (xValue != 0) {\n                if (i > 0)\n                    i--;\n                for (; i < cnt; i++) {\n                    obj = this._children[i];\n                    if (xValue < obj.x) {\n                        if (i == 0) {\n                            xValue = 0;\n                            break;\n                        }\n                        else {\n                            prev = this._children[i - 1];\n                            if (xValue < prev.x + prev.actualWidth / 2)\n                                xValue = prev.x;\n                            else\n                                xValue = obj.x;\n                            break;\n                        }\n                    }\n                }\n                if (i == cnt)\n                    xValue = obj.x;\n            }\n            resultPoint.x = xValue;\n            resultPoint.y = yValue;\n            return resultPoint;\n        }\n        childSortingOrderChanged(child, oldValue, newValue) {\n            if (newValue == 0) {\n                this._sortingChildCount--;\n                this.setChildIndex(child, this._children.length);\n            }\n            else {\n                if (oldValue == 0)\n                    this._sortingChildCount++;\n                var oldIndex = this._children.indexOf(child);\n                var index = this.getInsertPosForSortingChild(child);\n                if (oldIndex < index)\n                    this._setChildIndex(child, oldIndex, index - 1);\n                else\n                    this._setChildIndex(child, oldIndex, index);\n            }\n        }\n        constructFromResource() {\n            this.constructFromResource2(null, 0);\n        }\n        constructFromResource2(objectPool, poolIndex) {\n            var contentItem = this.packageItem.getBranch();\n            if (!contentItem.decoded) {\n                contentItem.decoded = true;\n                fgui.TranslationHelper.translateComponent(contentItem);\n            }\n            var i;\n            var dataLen;\n            var curPos;\n            var nextPos;\n            var f1;\n            var f2;\n            var i1;\n            var i2;\n            var buffer = contentItem.rawData;\n            buffer.seek(0, 0);\n            this._underConstruct = true;\n            this.sourceWidth = buffer.readInt();\n            this.sourceHeight = buffer.readInt();\n            this.initWidth = this.sourceWidth;\n            this.initHeight = this.sourceHeight;\n            this.setSize(this.sourceWidth, this.sourceHeight);\n            if (buffer.readBool()) {\n                this.minWidth = buffer.readInt();\n                this.maxWidth = buffer.readInt();\n                this.minHeight = buffer.readInt();\n                this.maxHeight = buffer.readInt();\n            }\n            if (buffer.readBool()) {\n                f1 = buffer.readFloat();\n                f2 = buffer.readFloat();\n                this.setPivot(f1, f2, buffer.readBool());\n            }\n            if (buffer.readBool()) {\n                this._margin.top = buffer.readInt();\n                this._margin.bottom = buffer.readInt();\n                this._margin.left = buffer.readInt();\n                this._margin.right = buffer.readInt();\n            }\n            var overflow = buffer.readByte();\n            if (overflow == fgui.OverflowType.Scroll) {\n                var savedPos = buffer.pos;\n                buffer.seek(0, 7);\n                this.setupScroll(buffer);\n                buffer.pos = savedPos;\n            }\n            else\n                this.setupOverflow(overflow);\n            if (buffer.readBool())\n                buffer.skip(8);\n            this._buildingDisplayList = true;\n            buffer.seek(0, 1);\n            var controllerCount = buffer.readShort();\n            for (i = 0; i < controllerCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                var controller = new fgui.Controller();\n                this._controllers.push(controller);\n                controller.parent = this;\n                controller.setup(buffer);\n                buffer.pos = nextPos;\n            }\n            buffer.seek(0, 2);\n            var child;\n            var childCount = buffer.readShort();\n            for (i = 0; i < childCount; i++) {\n                dataLen = buffer.readShort();\n                curPos = buffer.pos;\n                if (objectPool)\n                    child = objectPool[poolIndex + i];\n                else {\n                    buffer.seek(curPos, 0);\n                    var type = buffer.readByte();\n                    var src = buffer.readS();\n                    var pkgId = buffer.readS();\n                    var pi;\n                    if (src) {\n                        var pkg;\n                        if (pkgId)\n                            pkg = fgui.UIPackage.getById(pkgId);\n                        else\n                            pkg = contentItem.owner;\n                        pi = pkg ? pkg.getItemById(src) : null;\n                    }\n                    else\n                        pi = null;\n                    if (pi) {\n                        child = fgui.Decls.UIObjectFactory.newObject(pi);\n                        child.constructFromResource();\n                    }\n                    else\n                        child = fgui.Decls.UIObjectFactory.newObject(type);\n                }\n                child._underConstruct = true;\n                child.setup_beforeAdd(buffer, curPos);\n                child.parent = this;\n                this._children.push(child);\n                buffer.pos = curPos + dataLen;\n            }\n            buffer.seek(0, 3);\n            this.relations.setup(buffer, true);\n            buffer.seek(0, 2);\n            buffer.skip(2);\n            for (i = 0; i < childCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                buffer.seek(buffer.pos, 3);\n                this._children[i].relations.setup(buffer, false);\n                buffer.pos = nextPos;\n            }\n            buffer.seek(0, 2);\n            buffer.skip(2);\n            for (i = 0; i < childCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                child = this._children[i];\n                child.setup_afterAdd(buffer, buffer.pos);\n                child._underConstruct = false;\n                buffer.pos = nextPos;\n            }\n            buffer.seek(0, 4);\n            buffer.skip(2);\n            this.opaque = buffer.readBool();\n            var maskId = buffer.readShort();\n            if (maskId != -1) {\n                buffer.readBool();\n            }\n            var hitTestId = buffer.readS();\n            i1 = buffer.readInt();\n            i2 = buffer.readInt();\n            if (hitTestId) {\n                pi = contentItem.owner.getItemById(hitTestId);\n                if (pi && pi.pixelHitTestData)\n                    this._displayObject.hitArea = new fgui.PixelHitTest(pi.pixelHitTestData, i1, i2, this.sourceWidth, this.sourceHeight);\n            }\n            else if (i1 != 0 && i2 != -1) {\n                this._displayObject.hitArea = new fgui.ShapeHitTest(this.getChildAt(i2).displayObject);\n            }\n            buffer.seek(0, 5);\n            var transitionCount = buffer.readShort();\n            for (i = 0; i < transitionCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                var trans = new fgui.Transition(this);\n                trans.setup(buffer);\n                this._transitions.push(trans);\n                buffer.pos = nextPos;\n            }\n            if (this._transitions.length > 0) {\n                this.on(fgui.StageEvent.AddtoStage, () => { this._transitions.forEach(e => e.onOwnerAddedToStage()); });\n                this.on(fgui.StageEvent.RemoveFromStage, () => { this._transitions.forEach(e => e.onOwnerRemovedFromStage()); });\n            }\n            this.applyAllControllers();\n            this._buildingDisplayList = false;\n            this._underConstruct = false;\n            this.buildNativeDisplayList();\n            this.setBoundsChangedFlag();\n            if (contentItem.objectType != fgui.ObjectType.Component)\n                this.constructExtension(buffer);\n            this.onConstruct();\n        }\n        constructExtension(buffer) {\n        }\n        onConstruct() {\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            buffer.seek(beginPos, 4);\n            var pageController = buffer.readShort();\n            if (pageController != -1 && this._scrollPane)\n                this._scrollPane.pageController = this._parent.getControllerAt(pageController);\n            var cnt;\n            var i;\n            cnt = buffer.readShort();\n            for (i = 0; i < cnt; i++) {\n                var cc = this.getController(buffer.readS());\n                var pageId = buffer.readS();\n                if (cc)\n                    cc.selectedPageId = pageId;\n            }\n            if (buffer.version >= 2) {\n                cnt = buffer.readShort();\n                for (i = 0; i < cnt; i++) {\n                    var target = buffer.readS();\n                    var propertyId = buffer.readShort();\n                    var value = buffer.readS();\n                    var obj = this.getChildByPath(target);\n                    if (obj)\n                        obj.setProp(propertyId, value);\n                }\n            }\n        }\n    }\n    fgui.GComponent = GComponent;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GButton extends fgui.GComponent {\n        constructor() {\n            super();\n            this._soundVolumeScale = 0;\n            this._downEffect = 0;\n            this._downEffectValue = 0;\n            this._downScaled = false;\n            this._mode = fgui.ButtonMode.Common;\n            this._title = \"\";\n            this._icon = \"\";\n            this._sound = fgui.UIConfig.buttonSound;\n            this._soundVolumeScale = fgui.UIConfig.buttonSoundVolumeScale;\n            this._changeStateOnClick = true;\n            this._downEffectValue = 0.8;\n        }\n        get icon() {\n            return this._icon;\n        }\n        set icon(value) {\n            this._icon = value;\n            value = (this._selected && this._selectedIcon) ? this._selectedIcon : this._icon;\n            if (this._iconObject)\n                this._iconObject.icon = value;\n            this.updateGear(7);\n        }\n        get selectedIcon() {\n            return this._selectedIcon;\n        }\n        set selectedIcon(value) {\n            this._selectedIcon = value;\n            value = (this._selected && this._selectedIcon) ? this._selectedIcon : this._icon;\n            if (this._iconObject)\n                this._iconObject.icon = value;\n        }\n        get title() {\n            return this._title;\n        }\n        set title(value) {\n            this._title = value;\n            if (this._titleObject)\n                this._titleObject.text = (this._selected && this._selectedTitle) ? this._selectedTitle : this._title;\n            this.updateGear(6);\n        }\n        get text() {\n            return this.title;\n        }\n        set text(value) {\n            this.title = value;\n        }\n        get selectedTitle() {\n            return this._selectedTitle;\n        }\n        set selectedTitle(value) {\n            this._selectedTitle = value;\n            if (this._titleObject)\n                this._titleObject.text = (this._selected && this._selectedTitle) ? this._selectedTitle : this._title;\n        }\n        get titleColor() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.color;\n            else\n                return 0;\n        }\n        set titleColor(value) {\n            var tf = this.getTextField();\n            if (tf)\n                tf.color = value;\n            this.updateGear(4);\n        }\n        get titleFontSize() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.textFormat.size;\n            else\n                return 0;\n        }\n        set titleFontSize(value) {\n            var tf = this.getTextField();\n            if (tf) {\n                tf.textFormat.size = value;\n                tf.applyFormat();\n            }\n        }\n        get sound() {\n            return this._sound;\n        }\n        set sound(val) {\n            this._sound = val;\n        }\n        get soundVolumeScale() {\n            return this._soundVolumeScale;\n        }\n        set soundVolumeScale(value) {\n            this._soundVolumeScale = value;\n        }\n        set selected(val) {\n            if (this._mode == fgui.ButtonMode.Common)\n                return;\n            if (this._selected != val) {\n                this._selected = val;\n                this.setCurrentState();\n                if (this._selectedTitle && this._titleObject)\n                    this._titleObject.text = this._selected ? this._selectedTitle : this._title;\n                if (this._selectedIcon) {\n                    var str = this._selected ? this._selectedIcon : this._icon;\n                    if (this._iconObject)\n                        this._iconObject.icon = str;\n                }\n                if (this._relatedController\n                    && this._parent\n                    && !this._parent._buildingDisplayList) {\n                    if (this._selected) {\n                        this._relatedController.selectedPageId = this._relatedPageId;\n                        if (this._relatedController.autoRadioGroupDepth)\n                            this._parent.adjustRadioGroupDepth(this, this._relatedController);\n                    }\n                    else if (this._mode == fgui.ButtonMode.Check && this._relatedController.selectedPageId == this._relatedPageId)\n                        this._relatedController.oppositePageId = this._relatedPageId;\n                }\n            }\n        }\n        get selected() {\n            return this._selected;\n        }\n        get mode() {\n            return this._mode;\n        }\n        set mode(value) {\n            if (this._mode != value) {\n                if (value == fgui.ButtonMode.Common)\n                    this.selected = false;\n                this._mode = value;\n            }\n        }\n        get relatedController() {\n            return this._relatedController;\n        }\n        set relatedController(val) {\n            if (val != this._relatedController) {\n                this._relatedController = val;\n                this._relatedPageId = null;\n            }\n        }\n        get relatedPageId() {\n            return this._relatedPageId;\n        }\n        set relatedPageId(val) {\n            this._relatedPageId = val;\n        }\n        get changeStateOnClick() {\n            return this._changeStateOnClick;\n        }\n        set changeStateOnClick(value) {\n            this._changeStateOnClick = value;\n        }\n        get linkedPopup() {\n            return this._linkedPopup;\n        }\n        set linkedPopup(value) {\n            this._linkedPopup = value;\n        }\n        getTextField() {\n            if (this._titleObject instanceof fgui.GTextField)\n                return this._titleObject;\n            else if ('getTextField' in this._titleObject)\n                return this._titleObject.getTextField();\n            else\n                return null;\n        }\n        fireClick(downEffect, clickCall) {\n            downEffect = downEffect || false;\n            if (downEffect && this._mode == fgui.ButtonMode.Common) {\n                this.setState(\"over\");\n                fgui.Timers.add(100, 1, this.setState, this, \"down\");\n                fgui.Timers.add(200, 1, this.setState, this, () => {\n                    this.setState(\"up\");\n                    if (clickCall)\n                        this.dispatchEvent(fgui.InteractiveEvents.Click);\n                });\n            }\n        }\n        setState(val) {\n            if (this._buttonController)\n                this._buttonController.selectedPage = val;\n            if (this._downEffect == 1) {\n                var cnt = this.numChildren;\n                if (val == \"down\" || val == \"selectedOver\" || val == \"selectedDisabled\") {\n                    var p = this._downEffectValue * 255;\n                    var r = (p << 16) + (p << 8) + p;\n                    for (var i = 0; i < cnt; i++) {\n                        var obj = this.getChildAt(i);\n                        if (!(obj instanceof fgui.GTextField))\n                            obj.setProp(fgui.ObjectPropID.Color, r);\n                    }\n                }\n                else {\n                    for (i = 0; i < cnt; i++) {\n                        obj = this.getChildAt(i);\n                        if (!(obj instanceof fgui.GTextField))\n                            obj.setProp(fgui.ObjectPropID.Color, 0xFFFFFF);\n                    }\n                }\n            }\n            else if (this._downEffect == 2) {\n                if (val == \"down\" || val == \"selectedOver\" || val == \"selectedDisabled\") {\n                    if (!this._downScaled) {\n                        this.setScale(this.scaleX * this._downEffectValue, this.scaleY * this._downEffectValue);\n                        this._downScaled = true;\n                    }\n                }\n                else {\n                    if (this._downScaled) {\n                        this.setScale(this.scaleX / this._downEffectValue, this.scaleY / this._downEffectValue);\n                        this._downScaled = false;\n                    }\n                }\n            }\n        }\n        setCurrentState() {\n            if (this.grayed && this._buttonController && this._buttonController.hasPage(\"disabled\")) {\n                if (this._selected)\n                    this.setState(\"selectedDisabled\");\n                else\n                    this.setState(\"disabled\");\n            }\n            else {\n                if (this._selected)\n                    this.setState(this._over ? \"selectedOver\" : \"down\");\n                else\n                    this.setState(this._over ? \"over\" : \"up\");\n            }\n        }\n        handleControllerChanged(c) {\n            super.handleControllerChanged(c);\n            if (this._relatedController == c)\n                this.selected = this._relatedPageId == c.selectedPageId;\n        }\n        handleGrayedChanged() {\n            if (this._buttonController && this._buttonController.hasPage(\"disabled\")) {\n                if (this.grayed) {\n                    if (this._selected && this._buttonController.hasPage(\"selectedDisabled\"))\n                        this.setState(\"selectedDisabled\");\n                    else\n                        this.setState(\"disabled\");\n                }\n                else if (this._selected)\n                    this.setState(\"down\");\n                else\n                    this.setState(\"up\");\n            }\n            else\n                super.handleGrayedChanged();\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.titleColor;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf)\n                            return tf.textFormat.outlineColor;\n                        else\n                            return 0;\n                    }\n                case fgui.ObjectPropID.FontSize:\n                    return this.titleFontSize;\n                case fgui.ObjectPropID.Selected:\n                    return this.selected;\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.titleColor = value;\n                    break;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf) {\n                            tf.textFormat.outlineColor = value;\n                            tf.applyFormat();\n                        }\n                    }\n                    break;\n                case fgui.ObjectPropID.FontSize:\n                    this.titleFontSize = value;\n                    break;\n                case fgui.ObjectPropID.Selected:\n                    this.selected = value;\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        constructExtension(buffer) {\n            buffer.seek(0, 6);\n            this._mode = buffer.readByte();\n            var str = buffer.readS();\n            if (str)\n                this._sound = str;\n            this._soundVolumeScale = buffer.readFloat();\n            this._downEffect = buffer.readByte();\n            this._downEffectValue = buffer.readFloat();\n            if (this._downEffect == 2)\n                this.setPivot(0.5, 0.5, this.pivotAsAnchor);\n            this._buttonController = this.getController(\"button\");\n            this._titleObject = this.getChild(\"title\");\n            this._iconObject = this.getChild(\"icon\");\n            if (this._titleObject)\n                this._title = this._titleObject.text;\n            if (this._iconObject)\n                this._icon = this._iconObject.icon;\n            if (this._mode == fgui.ButtonMode.Common)\n                this.setState(\"up\");\n            this.on(fgui.RollEvent.RollOver, this.__rollover, this);\n            this.on(fgui.RollEvent.RollOut, this.__rollout, this);\n            this.on(fgui.InteractiveEvents.Down, this.__btnTouchBegin, this);\n            this.on(fgui.InteractiveEvents.Up, this.__btnTouchEnd, this);\n            this.on(fgui.InteractiveEvents.Click, this.__click, this);\n            this.on(fgui.StageEvent.RemoveFromStage, this.__removeFromStage, this);\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!buffer.seek(beginPos, 6))\n                return;\n            if (buffer.readByte() != this.packageItem.objectType)\n                return;\n            var str;\n            var iv;\n            str = buffer.readS();\n            if (str != null)\n                this.title = str;\n            str = buffer.readS();\n            if (str != null)\n                this.selectedTitle = str;\n            str = buffer.readS();\n            if (str != null)\n                this.icon = str;\n            str = buffer.readS();\n            if (str != null)\n                this.selectedIcon = str;\n            if (buffer.readBool())\n                this.titleColor = buffer.readColor();\n            iv = buffer.readInt();\n            if (iv != 0)\n                this.titleFontSize = iv;\n            iv = buffer.readShort();\n            if (iv >= 0)\n                this._relatedController = this.parent.getControllerAt(iv);\n            this._relatedPageId = buffer.readS();\n            str = buffer.readS();\n            if (str != null)\n                this._sound = str;\n            if (buffer.readBool())\n                this._soundVolumeScale = buffer.readFloat();\n            this.selected = buffer.readBool();\n        }\n        __rollover() {\n            if (!this._buttonController || !this._buttonController.hasPage(\"over\"))\n                return;\n            this._over = true;\n            if (this._down)\n                return;\n            if (this.grayed && this._buttonController.hasPage(\"disabled\"))\n                return;\n            this.setState(this._selected ? \"selectedOver\" : \"over\");\n        }\n        __rollout() {\n            if (!this._buttonController || !this._buttonController.hasPage(\"over\"))\n                return;\n            this._over = false;\n            if (this._down)\n                return;\n            if (this.grayed && this._buttonController.hasPage(\"disabled\"))\n                return;\n            this.setState(this._selected ? \"down\" : \"up\");\n        }\n        __btnTouchBegin(evt) {\n            if (evt.input.button != 0)\n                return;\n            this._down = true;\n            evt.captureTouch();\n            if (this._mode == fgui.ButtonMode.Common) {\n                if (this.grayed && this._buttonController && this._buttonController.hasPage(\"disabled\"))\n                    this.setState(\"selectedDisabled\");\n                else\n                    this.setState(\"down\");\n            }\n            if (this._linkedPopup) {\n                if (this._linkedPopup instanceof fgui.Window)\n                    this._linkedPopup.toggleStatus();\n                else\n                    fgui.GRoot.findFor(this).togglePopup(this._linkedPopup, this);\n            }\n        }\n        __btnTouchEnd(evt) {\n            if (this._down) {\n                this._down = false;\n                if (this._mode == fgui.ButtonMode.Common) {\n                    if (this.grayed && this._buttonController && this._buttonController.hasPage(\"disabled\"))\n                        this.setState(\"disabled\");\n                    else if (this._over)\n                        this.setState(\"over\");\n                    else\n                        this.setState(\"up\");\n                }\n                else {\n                    if (!this._over\n                        && this._buttonController\n                        && (this._buttonController.selectedPage == \"over\" || this._buttonController.selectedPage == \"selectedOver\")) {\n                        this.setCurrentState();\n                    }\n                }\n            }\n        }\n        __removeFromStage() {\n            if (this._over)\n                this.__rollout();\n        }\n        __click(evt) {\n            if (this._sound) {\n                var pi = fgui.UIPackage.getItemByURL(this._sound);\n                if (pi)\n                    fgui.GRoot.inst.playOneShotSound(pi.file);\n                else\n                    fgui.GRoot.inst.playOneShotSound(this._sound);\n            }\n            if (this._mode == fgui.ButtonMode.Check) {\n                if (this._changeStateOnClick) {\n                    this.selected = !this._selected;\n                    this.dispatchEvent(fgui.StateChangeEvent.CHANGED);\n                }\n            }\n            else if (this._mode == fgui.ButtonMode.Radio) {\n                if (this._changeStateOnClick && !this._selected) {\n                    this.selected = true;\n                    this.dispatchEvent(fgui.StateChangeEvent.CHANGED);\n                }\n            }\n            else {\n                if (this._relatedController)\n                    this._relatedController.selectedPageId = this._relatedPageId;\n            }\n        }\n    }\n    fgui.GButton = GButton;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GComboBox extends fgui.GComponent {\n        constructor() {\n            super();\n            this.visibleItemCount = fgui.UIConfig.defaultComboBoxVisibleItemCount;\n            this.popupDirection = fgui.PopupDirection.Auto;\n            this._itemsUpdated = true;\n            this._selectedIndex = -1;\n            this._items = [];\n            this._values = [];\n        }\n        get text() {\n            if (this._titleObject)\n                return this._titleObject.text;\n            else\n                return null;\n        }\n        set text(value) {\n            if (this._titleObject)\n                this._titleObject.text = value;\n            this.updateGear(6);\n        }\n        get titleColor() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.color;\n            else\n                return 0;\n        }\n        set titleColor(value) {\n            var tf = this.getTextField();\n            if (tf)\n                tf.color = value;\n            this.updateGear(4);\n        }\n        get titleFontSize() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.textFormat.size;\n            else\n                return 0;\n        }\n        set titleFontSize(value) {\n            var tf = this.getTextField();\n            if (tf) {\n                tf.textFormat.size = value;\n                tf.applyFormat();\n            }\n        }\n        get icon() {\n            if (this._iconObject)\n                return this._iconObject.icon;\n            else\n                return null;\n        }\n        set icon(value) {\n            if (this._iconObject)\n                this._iconObject.icon = value;\n            this.updateGear(7);\n        }\n        get items() {\n            return this._items;\n        }\n        set items(value) {\n            if (!value)\n                this._items.length = 0;\n            else\n                this._items = value.concat();\n            if (this._items.length > 0) {\n                if (this._selectedIndex >= this._items.length)\n                    this._selectedIndex = this._items.length - 1;\n                else if (this._selectedIndex == -1)\n                    this._selectedIndex = 0;\n                this.text = this._items[this._selectedIndex];\n                if (this._icons && this._selectedIndex < this._icons.length)\n                    this.icon = this._icons[this._selectedIndex];\n            }\n            else {\n                this.text = \"\";\n                if (this._icons)\n                    this.icon = null;\n                this._selectedIndex = -1;\n            }\n            this._itemsUpdated = true;\n        }\n        get icons() {\n            return this._icons;\n        }\n        set icons(value) {\n            this._icons = value;\n            if (this._icons && this._selectedIndex != -1 && this._selectedIndex < this._icons.length)\n                this.icon = this._icons[this._selectedIndex];\n        }\n        get values() {\n            return this._values;\n        }\n        set values(value) {\n            if (!value)\n                this._values.length = 0;\n            else\n                this._values = value.concat();\n        }\n        get selectedIndex() {\n            return this._selectedIndex;\n        }\n        set selectedIndex(val) {\n            if (this._selectedIndex == val)\n                return;\n            this._selectedIndex = val;\n            if (this._selectedIndex >= 0 && this._selectedIndex < this._items.length) {\n                this.text = this._items[this._selectedIndex];\n                if (this._icons && this._selectedIndex < this._icons.length)\n                    this.icon = this._icons[this._selectedIndex];\n            }\n            else {\n                this.text = \"\";\n                if (this._icons)\n                    this.icon = null;\n            }\n            this.updateSelectionController();\n        }\n        get value() {\n            return this._values[this._selectedIndex];\n        }\n        set value(val) {\n            var index = this._values.indexOf(val);\n            if (index == -1 && val == null)\n                index = this._values.indexOf(\"\");\n            this.selectedIndex = index;\n        }\n        getTextField() {\n            if (this._titleObject instanceof fgui.GTextField)\n                return this._titleObject;\n            else if ('getTextField' in this._titleObject)\n                return this._titleObject.getTextField();\n            else\n                return null;\n        }\n        setState(val) {\n            if (this._buttonController)\n                this._buttonController.selectedPage = val;\n        }\n        setCurrentState() {\n            if (this.grayed && this._buttonController && this._buttonController.hasPage(\"disabled\"))\n                this.setState(\"disabled\");\n            else if (this.dropdown && this.dropdown.parent)\n                this.setState(\"down\");\n            else\n                this.setState(this._over ? \"over\" : \"up\");\n        }\n        get selectionController() {\n            return this._selectionController;\n        }\n        set selectionController(value) {\n            this._selectionController = value;\n        }\n        handleControllerChanged(c) {\n            super.handleControllerChanged(c);\n            if (this._selectionController == c)\n                this.selectedIndex = c.selectedIndex;\n        }\n        updateSelectionController() {\n            if (this._selectionController && !this._selectionController.changing\n                && this._selectedIndex < this._selectionController.pageCount) {\n                var c = this._selectionController;\n                this._selectionController = null;\n                c.selectedIndex = this._selectedIndex;\n                this._selectionController = c;\n            }\n        }\n        dispose() {\n            if (this.dropdown) {\n                this.dropdown.dispose();\n                this.dropdown = null;\n            }\n            this._selectionController = null;\n            super.dispose();\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.titleColor;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf)\n                            return tf.textFormat.outlineColor;\n                        else\n                            return 0;\n                    }\n                case fgui.ObjectPropID.FontSize:\n                    {\n                        tf = this.getTextField();\n                        if (tf)\n                            return tf.textFormat.size;\n                        else\n                            return 0;\n                    }\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.titleColor = value;\n                    break;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf) {\n                            tf.textFormat.outlineColor = value;\n                            tf.applyFormat();\n                        }\n                    }\n                    break;\n                case fgui.ObjectPropID.FontSize:\n                    {\n                        tf = this.getTextField();\n                        if (tf) {\n                            tf.textFormat.size = value;\n                            tf.applyFormat();\n                        }\n                    }\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        constructExtension(buffer) {\n            this._buttonController = this.getController(\"button\");\n            this._titleObject = this.getChild(\"title\");\n            this._iconObject = this.getChild(\"icon\");\n            let str = buffer.readS();\n            if (str) {\n                this.dropdown = fgui.UIPackage.createObjectFromURL(str);\n                if (!this.dropdown) {\n                    console.warn(this.resourceURL + \" should be a component.\");\n                    return;\n                }\n                this._list = this.dropdown.getChild(\"list\");\n                if (this._list == null) {\n                    console.warn(this.resourceURL + \": should container a list component named list.\");\n                    return;\n                }\n                this._list.on(fgui.ListEvent.ItemClick, this.__clickItem, this);\n                this._list.addRelation(this.dropdown, fgui.RelationType.Width);\n                this._list.removeRelation(this.dropdown, fgui.RelationType.Height);\n                this.dropdown.addRelation(this._list, fgui.RelationType.Height);\n                this.dropdown.removeRelation(this._list, fgui.RelationType.Width);\n                this.dropdown.on(fgui.StageEvent.RemoveFromStage, this.__popupWinClosed, this);\n            }\n            this.on(fgui.RollEvent.RollOver, this.__rollover, this);\n            this.on(fgui.RollEvent.RollOut, this.__rollout, this);\n            this.on(fgui.InteractiveEvents.Down, this.__mousedown, this);\n            this.on(fgui.InteractiveEvents.Up, this.__mouseup, this);\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!buffer.seek(beginPos, 6))\n                return;\n            if (buffer.readByte() != this.packageItem.objectType)\n                return;\n            var i;\n            var iv;\n            var nextPos;\n            var str;\n            var itemCount = buffer.readShort();\n            for (i = 0; i < itemCount; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                this._items[i] = buffer.readS();\n                this._values[i] = buffer.readS();\n                str = buffer.readS();\n                if (str != null) {\n                    if (this._icons == null)\n                        this._icons = [];\n                    this._icons[i] = str;\n                }\n                buffer.pos = nextPos;\n            }\n            str = buffer.readS();\n            if (str != null) {\n                this.text = str;\n                this._selectedIndex = this._items.indexOf(str);\n            }\n            else if (this._items.length > 0) {\n                this._selectedIndex = 0;\n                this.text = this._items[0];\n            }\n            else\n                this._selectedIndex = -1;\n            str = buffer.readS();\n            if (str != null)\n                this.icon = str;\n            if (buffer.readBool())\n                this.titleColor = buffer.readColor();\n            iv = buffer.readInt();\n            if (iv > 0)\n                this.visibleItemCount = iv;\n            this.popupDirection = buffer.readByte();\n            iv = buffer.readShort();\n            if (iv >= 0)\n                this._selectionController = this.parent.getControllerAt(iv);\n        }\n        showDropdown() {\n            if (this._itemsUpdated) {\n                this._itemsUpdated = false;\n                this._list.removeChildrenToPool();\n                var cnt = this._items.length;\n                for (var i = 0; i < cnt; i++) {\n                    var item = this._list.addItemFromPool();\n                    item.name = i < this._values.length ? this._values[i] : \"\";\n                    item.text = this._items[i];\n                    item.icon = (this._icons && i < this._icons.length) ? this._icons[i] : null;\n                }\n                this._list.resizeToFit(this.visibleItemCount);\n            }\n            this._list.selectedIndex = -1;\n            this.dropdown.width = this.width;\n            this._list.ensureBoundsCorrect();\n            fgui.GRoot.findFor(this).togglePopup(this.dropdown, this, this.popupDirection);\n            if (this.dropdown.parent)\n                this.setState(\"down\");\n        }\n        __popupWinClosed() {\n            this.setCurrentState();\n        }\n        __clickItem(evt) {\n            if (this.dropdown.parent instanceof fgui.GRoot)\n                this.dropdown.parent.hidePopup();\n            this._selectedIndex = -1;\n            this.selectedIndex = this._list.getChildIndex(evt.data);\n            this.dispatchEvent(fgui.StateChangeEvent.CHANGED);\n        }\n        __rollover() {\n            this._over = true;\n            if (this._down || this.dropdown && this.dropdown.parent)\n                return;\n            this.setCurrentState();\n        }\n        __rollout() {\n            this._over = false;\n            if (this._down || this.dropdown && this.dropdown.parent)\n                return;\n            this.setCurrentState();\n        }\n        __mousedown(evt) {\n            if (evt.initiator instanceof fgui.InputTextField)\n                return;\n            this._down = true;\n            if (this.dropdown)\n                this.showDropdown();\n            evt.captureTouch();\n        }\n        __mouseup() {\n            if (this._down) {\n                this._down = false;\n                this.setCurrentState();\n            }\n        }\n    }\n    fgui.GComboBox = GComboBox;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GGraph extends fgui.GObject {\n        constructor() {\n            super();\n        }\n        get shape() {\n            return this._shape;\n        }\n        get color() {\n            return this._shape.graphics.color;\n        }\n        set color(value) {\n            if (this._shape.graphics.color != value) {\n                this._shape.graphics.color = value;\n                this.updateGear(4);\n            }\n        }\n        createDisplayObject() {\n            this._displayObject = this._shape = new fgui.Shape();\n        }\n        getProp(index) {\n            if (index == fgui.ObjectPropID.Color)\n                return this.color;\n            else\n                return super.getProp(index);\n        }\n        setProp(index, value) {\n            if (index == fgui.ObjectPropID.Color)\n                this.color = value;\n            else\n                super.setProp(index, value);\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            let type = buffer.readByte();\n            if (type != 0) {\n                let i;\n                let cnt;\n                let lineSize = buffer.readInt();\n                let lineColor = buffer.readFullColor();\n                let fillColor = buffer.readFullColor();\n                let roundedRect = buffer.readBool();\n                let cornerRadius;\n                if (roundedRect) {\n                    cornerRadius = [];\n                    for (i = 0; i < 4; i++)\n                        cornerRadius[i] = buffer.readFloat();\n                }\n                if (type == 1) {\n                    if (roundedRect)\n                        this._shape.drawRoundRect(lineSize, lineColor, fillColor, cornerRadius[0], cornerRadius[1], cornerRadius[2], cornerRadius[3]);\n                    else\n                        this._shape.drawRect(lineSize, lineColor, fillColor);\n                }\n                else if (type == 2) {\n                    this._shape.drawEllipse(lineSize, fillColor, lineColor, fillColor, 0, 360);\n                }\n                else if (type == 3) {\n                    cnt = buffer.readShort();\n                    let points = [];\n                    points.length = cnt;\n                    for (i = 0; i < cnt; i++)\n                        points[i] = buffer.readFloat();\n                    this._shape.drawPolygon(points, fillColor, lineSize, lineColor);\n                }\n                else if (type == 4) {\n                    let sides = buffer.readShort();\n                    let startAngle = buffer.readFloat();\n                    cnt = buffer.readShort();\n                    let distances;\n                    if (cnt > 0) {\n                        distances = [];\n                        for (i = 0; i < cnt; i++)\n                            distances[i] = buffer.readFloat();\n                    }\n                    this._shape.drawRegularPolygon(sides, lineSize, fillColor, lineColor, fillColor, startAngle, distances);\n                }\n            }\n        }\n    }\n    fgui.GGraph = GGraph;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GGroup extends fgui.GObject {\n        constructor() {\n            super();\n            this._layout = 0;\n            this._lineGap = 0;\n            this._columnGap = 0;\n            this._mainGridIndex = -1;\n            this._mainGridMinSize = 50;\n            this._mainChildIndex = -1;\n            this._totalSize = 0;\n            this._numChildren = 0;\n            this._updating = 0;\n        }\n        dispose() {\n            this._boundsChanged = false;\n            super.dispose();\n        }\n        get layout() {\n            return this._layout;\n        }\n        set layout(value) {\n            if (this._layout != value) {\n                this._layout = value;\n                this.setBoundsChangedFlag();\n            }\n        }\n        get lineGap() {\n            return this._lineGap;\n        }\n        set lineGap(value) {\n            if (this._lineGap != value) {\n                this._lineGap = value;\n                this.setBoundsChangedFlag(true);\n            }\n        }\n        get columnGap() {\n            return this._columnGap;\n        }\n        set columnGap(value) {\n            if (this._columnGap != value) {\n                this._columnGap = value;\n                this.setBoundsChangedFlag(true);\n            }\n        }\n        get excludeInvisibles() {\n            return this._excludeInvisibles;\n        }\n        set excludeInvisibles(value) {\n            if (this._excludeInvisibles != value) {\n                this._excludeInvisibles = value;\n                this.setBoundsChangedFlag();\n            }\n        }\n        get autoSizeDisabled() {\n            return this._autoSizeDisabled;\n        }\n        set autoSizeDisabled(value) {\n            this._autoSizeDisabled = value;\n        }\n        get mainGridMinSize() {\n            return this._mainGridMinSize;\n        }\n        set mainGridMinSize(value) {\n            if (this._mainGridMinSize != value) {\n                this._mainGridMinSize = value;\n                this.setBoundsChangedFlag();\n            }\n        }\n        get mainGridIndex() {\n            return this._mainGridIndex;\n        }\n        set mainGridIndex(value) {\n            if (this._mainGridIndex != value) {\n                this._mainGridIndex = value;\n                this.setBoundsChangedFlag();\n            }\n        }\n        setBoundsChangedFlag(positionChangedOnly) {\n            if (this._updating == 0 && this._parent) {\n                if (!positionChangedOnly)\n                    this._percentReady = false;\n                if (!this._boundsChanged) {\n                    this._boundsChanged = true;\n                    if (this._layout != fgui.GroupLayoutType.None)\n                        fgui.Timers.callLater(this.ensureBoundsCorrect, this);\n                }\n            }\n        }\n        ensureBoundsCorrect() {\n            if (this._parent == null || !this._boundsChanged)\n                return;\n            this._boundsChanged = false;\n            if (this._layout == 0)\n                this.updateBounds();\n            else {\n                if (this._autoSizeDisabled)\n                    this.resizeChildren(0, 0);\n                else {\n                    this.handleLayout();\n                    this.updateBounds();\n                }\n            }\n        }\n        updateBounds() {\n            fgui.Timers.remove(this.ensureBoundsCorrect, this);\n            var cnt = this._parent.numChildren;\n            var i;\n            var child;\n            var ax = Number.POSITIVE_INFINITY, ay = Number.POSITIVE_INFINITY;\n            var ar = Number.NEGATIVE_INFINITY, ab = Number.NEGATIVE_INFINITY;\n            var tmp;\n            var empty = true;\n            for (i = 0; i < cnt; i++) {\n                child = this._parent.getChildAt(i);\n                if (child.group != this || this._excludeInvisibles && !child.internalVisible3)\n                    continue;\n                tmp = child.xMin;\n                if (tmp < ax)\n                    ax = tmp;\n                tmp = child.yMin;\n                if (tmp < ay)\n                    ay = tmp;\n                tmp = child.xMin + child.width;\n                if (tmp > ar)\n                    ar = tmp;\n                tmp = child.yMin + child.height;\n                if (tmp > ab)\n                    ab = tmp;\n                empty = false;\n            }\n            var w = 0, h = 0;\n            if (!empty) {\n                this._updating |= 1;\n                this.setPosition(ax, ay);\n                this._updating &= 2;\n                w = ar - ax;\n                h = ab - ay;\n            }\n            if ((this._updating & 2) == 0) {\n                this._updating |= 2;\n                this.setSize(w, h);\n                this._updating &= 1;\n            }\n            else {\n                this._updating &= 1;\n                this.resizeChildren(this._width - w, this._height - h);\n            }\n        }\n        handleLayout() {\n            this._updating |= 1;\n            var child;\n            var i;\n            var cnt;\n            if (this._layout == fgui.GroupLayoutType.Horizontal) {\n                var curX = this.x;\n                cnt = this._parent.numChildren;\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (this._excludeInvisibles && !child.internalVisible3)\n                        continue;\n                    child.xMin = curX;\n                    if (child.width != 0)\n                        curX += child.width + this._columnGap;\n                }\n            }\n            else if (this._layout == fgui.GroupLayoutType.Vertical) {\n                var curY = this.y;\n                cnt = this._parent.numChildren;\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (this._excludeInvisibles && !child.internalVisible3)\n                        continue;\n                    child.yMin = curY;\n                    if (child.height != 0)\n                        curY += child.height + this._lineGap;\n                }\n            }\n            this._updating &= 2;\n        }\n        moveChildren(dx, dy) {\n            if ((this._updating & 1) != 0 || this._parent == null)\n                return;\n            this._updating |= 1;\n            var cnt = this._parent.numChildren;\n            var i;\n            var child;\n            for (i = 0; i < cnt; i++) {\n                child = this._parent.getChildAt(i);\n                if (child.group == this) {\n                    child.setPosition(child.x + dx, child.y + dy);\n                }\n            }\n            this._updating &= 2;\n        }\n        resizeChildren(dw, dh) {\n            if (this._layout == fgui.GroupLayoutType.None || (this._updating & 2) != 0 || this._parent == null)\n                return;\n            this._updating |= 2;\n            if (this._boundsChanged) {\n                this._boundsChanged = false;\n                if (!this._autoSizeDisabled) {\n                    this.updateBounds();\n                    return;\n                }\n            }\n            var cnt = this._parent.numChildren;\n            var i;\n            var child;\n            if (!this._percentReady) {\n                this._percentReady = true;\n                this._numChildren = 0;\n                this._totalSize = 0;\n                this._mainChildIndex = -1;\n                var j = 0;\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (!this._excludeInvisibles || child.internalVisible3) {\n                        if (j == this._mainGridIndex)\n                            this._mainChildIndex = i;\n                        this._numChildren++;\n                        if (this._layout == 1)\n                            this._totalSize += child.width;\n                        else\n                            this._totalSize += child.height;\n                    }\n                    j++;\n                }\n                if (this._mainChildIndex != -1) {\n                    if (this._layout == 1) {\n                        child = this._parent.getChildAt(this._mainChildIndex);\n                        this._totalSize += this._mainGridMinSize - child.width;\n                        child._sizePercentInGroup = this._mainGridMinSize / this._totalSize;\n                    }\n                    else {\n                        child = this._parent.getChildAt(this._mainChildIndex);\n                        this._totalSize += this._mainGridMinSize - child.height;\n                        child._sizePercentInGroup = this._mainGridMinSize / this._totalSize;\n                    }\n                }\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (i == this._mainChildIndex)\n                        continue;\n                    if (this._totalSize > 0)\n                        child._sizePercentInGroup = (this._layout == 1 ? child.width : child.height) / this._totalSize;\n                    else\n                        child._sizePercentInGroup = 0;\n                }\n            }\n            var remainSize = 0;\n            var remainPercent = 1;\n            var priorHandled = false;\n            if (this._layout == 1) {\n                remainSize = this.width - (this._numChildren - 1) * this._columnGap;\n                if (this._mainChildIndex != -1 && remainSize >= this._totalSize) {\n                    child = this._parent.getChildAt(this._mainChildIndex);\n                    child.setSize(remainSize - (this._totalSize - this._mainGridMinSize), child._rawHeight + dh, true);\n                    remainSize -= child.width;\n                    remainPercent -= child._sizePercentInGroup;\n                    priorHandled = true;\n                }\n                var curX = this.x;\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (this._excludeInvisibles && !child.internalVisible3) {\n                        child.setSize(child._rawWidth, child._rawHeight + dh, true);\n                        continue;\n                    }\n                    if (!priorHandled || i != this._mainChildIndex) {\n                        child.setSize(Math.round(child._sizePercentInGroup / remainPercent * remainSize), child._rawHeight + dh, true);\n                        remainPercent -= child._sizePercentInGroup;\n                        remainSize -= child.width;\n                    }\n                    child.xMin = curX;\n                    if (child.width != 0)\n                        curX += child.width + this._columnGap;\n                }\n            }\n            else {\n                remainSize = this.height - (this._numChildren - 1) * this._lineGap;\n                if (this._mainChildIndex != -1 && remainSize >= this._totalSize) {\n                    child = this._parent.getChildAt(this._mainChildIndex);\n                    child.setSize(child._rawWidth + dw, remainSize - (this._totalSize - this._mainGridMinSize), true);\n                    remainSize -= child.height;\n                    remainPercent -= child._sizePercentInGroup;\n                    priorHandled = true;\n                }\n                var curY = this.y;\n                for (i = 0; i < cnt; i++) {\n                    child = this._parent.getChildAt(i);\n                    if (child.group != this)\n                        continue;\n                    if (this._excludeInvisibles && !child.internalVisible3) {\n                        child.setSize(child._rawWidth + dw, child._rawHeight, true);\n                        continue;\n                    }\n                    if (!priorHandled || i != this._mainChildIndex) {\n                        child.setSize(child._rawWidth + dw, Math.round(child._sizePercentInGroup / remainPercent * remainSize), true);\n                        remainPercent -= child._sizePercentInGroup;\n                        remainSize -= child.height;\n                    }\n                    child.yMin = curY;\n                    if (child.height != 0)\n                        curY += child.height + this._lineGap;\n                }\n            }\n            this._updating &= 1;\n        }\n        handleAlphaChanged() {\n            if (this._underConstruct)\n                return;\n            var cnt = this._parent.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                var child = this._parent.getChildAt(i);\n                if (child.group == this)\n                    child.alpha = this.alpha;\n            }\n        }\n        handleVisibleChanged() {\n            if (!this._parent)\n                return;\n            var cnt = this._parent.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                var child = this._parent.getChildAt(i);\n                if (child.group == this)\n                    child.handleVisibleChanged();\n            }\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            this._layout = buffer.readByte();\n            this._lineGap = buffer.readInt();\n            this._columnGap = buffer.readInt();\n            if (buffer.version >= 2) {\n                this._excludeInvisibles = buffer.readBool();\n                this._autoSizeDisabled = buffer.readBool();\n                this._mainChildIndex = buffer.readShort();\n            }\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!this.visible)\n                this.handleVisibleChanged();\n        }\n    }\n    fgui.GGroup = GGroup;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GImage extends fgui.GObject {\n        constructor() {\n            super();\n        }\n        get color() {\n            return this._image.graphics.color;\n        }\n        set color(value) {\n            if (this._image.graphics.color != value) {\n                this._image.graphics.color = value;\n                this.updateGear(4);\n            }\n        }\n        get flip() {\n            return this._image.graphics.flip;\n        }\n        set flip(value) {\n            this._image.graphics.flip = value;\n        }\n        get fillMethod() {\n            return this._image.fillMethod;\n        }\n        set fillMethod(value) {\n            this._image.fillMethod = value;\n        }\n        get fillOrigin() {\n            return this._image.fillOrigin;\n        }\n        set fillOrigin(value) {\n            this._image.fillOrigin = value;\n        }\n        get fillClockwise() {\n            return this._image.fillClockwise;\n        }\n        set fillClockwise(value) {\n            this._image.fillClockwise = value;\n        }\n        get fillAmount() {\n            return this._image.fillAmount;\n        }\n        set fillAmount(value) {\n            this._image.fillAmount = value;\n        }\n        createDisplayObject() {\n            this._displayObject = this._image = new fgui.Image();\n        }\n        handleSizeChanged() {\n            this._image.width = this._width;\n            this._image.height = this._height;\n        }\n        constructFromResource() {\n            this._contentItem = this.packageItem.getBranch();\n            this.sourceWidth = this._contentItem.width;\n            this.sourceHeight = this._contentItem.height;\n            this.initWidth = this.sourceWidth;\n            this.initHeight = this.sourceHeight;\n            this._contentItem = this._contentItem.getHighResolution();\n            this._contentItem.load();\n            this._image.scale9Grid = this._contentItem.scale9Grid;\n            this._image.scaleByTile = this._contentItem.scaleByTile;\n            this._image.tileGridIndice = this._contentItem.tileGridIndice;\n            this._image.texture = this._contentItem.texture;\n            this.setSize(this.sourceWidth, this.sourceHeight);\n        }\n        getProp(index) {\n            if (index == fgui.ObjectPropID.Color)\n                return this.color;\n            else\n                return super.getProp(index);\n        }\n        setProp(index, value) {\n            if (index == fgui.ObjectPropID.Color)\n                this.color = value;\n            else\n                super.setProp(index, value);\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            if (buffer.readBool())\n                this.color = buffer.readColor();\n            this.flip = buffer.readByte();\n            this._image.fillMethod = buffer.readByte();\n            if (this._image.fillMethod != 0) {\n                this._image.fillOrigin = buffer.readByte();\n                this._image.fillClockwise = buffer.readBool();\n                this._image.fillAmount = buffer.readFloat();\n            }\n        }\n    }\n    fgui.GImage = GImage;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GLabel extends fgui.GComponent {\n        constructor() {\n            super();\n        }\n        get icon() {\n            if (this._iconObject)\n                return this._iconObject.icon;\n            else\n                return null;\n        }\n        set icon(value) {\n            if (this._iconObject)\n                this._iconObject.icon = value;\n            this.updateGear(7);\n        }\n        get title() {\n            if (this._titleObject)\n                return this._titleObject.text;\n            else\n                return null;\n        }\n        set title(value) {\n            if (this._titleObject)\n                this._titleObject.text = value;\n            this.updateGear(6);\n        }\n        get text() {\n            return this.title;\n        }\n        set text(value) {\n            this.title = value;\n        }\n        get titleColor() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.color;\n            else\n                return 0;\n        }\n        set titleColor(value) {\n            var tf = this.getTextField();\n            if (tf)\n                tf.color = value;\n            this.updateGear(4);\n        }\n        get titleFontSize() {\n            var tf = this.getTextField();\n            if (tf)\n                return tf.textFormat.size;\n            else\n                return 0;\n        }\n        set titleFontSize(value) {\n            var tf = this.getTextField();\n            if (tf) {\n                tf.textFormat.size = value;\n                tf.applyFormat();\n            }\n        }\n        get color() {\n            return this.titleColor;\n        }\n        set color(value) {\n            this.titleColor = value;\n        }\n        set editable(val) {\n            if (this._titleObject)\n                this._titleObject.editable = val;\n        }\n        get editable() {\n            if (this._titleObject && (this._titleObject instanceof fgui.GTextInput))\n                return this._titleObject.editable;\n            else\n                return false;\n        }\n        getTextField() {\n            if (this._titleObject instanceof fgui.GTextField)\n                return this._titleObject;\n            else if ('getTextField' in this._titleObject)\n                return this._titleObject.getTextField();\n            else\n                return null;\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.titleColor;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf)\n                            return tf.textFormat.outlineColor;\n                        else\n                            return 0;\n                    }\n                case fgui.ObjectPropID.FontSize:\n                    return this.titleFontSize;\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.titleColor = value;\n                    break;\n                case fgui.ObjectPropID.OutlineColor:\n                    {\n                        var tf = this.getTextField();\n                        if (tf) {\n                            tf.textFormat.outlineColor = value;\n                            tf.applyFormat();\n                        }\n                    }\n                    break;\n                case fgui.ObjectPropID.FontSize:\n                    this.titleFontSize = value;\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        constructExtension(buffer) {\n            this._titleObject = this.getChild(\"title\");\n            this._iconObject = this.getChild(\"icon\");\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!buffer.seek(beginPos, 6))\n                return;\n            if (buffer.readByte() != this.packageItem.objectType)\n                return;\n            var str;\n            str = buffer.readS();\n            if (str != null)\n                this.title = str;\n            str = buffer.readS();\n            if (str != null)\n                this.icon = str;\n            if (buffer.readBool())\n                this.titleColor = buffer.readColor();\n            var iv = buffer.readInt();\n            if (iv != 0)\n                this.titleFontSize = iv;\n            if (buffer.readBool()) {\n                var input = this.getTextField();\n                if (input) {\n                    str = buffer.readS();\n                    if (str != null)\n                        input.promptText = str;\n                    str = buffer.readS();\n                    if (str != null)\n                        input.restrict = str;\n                    iv = buffer.readInt();\n                    if (iv != 0)\n                        input.maxLength = iv;\n                    iv = buffer.readInt();\n                    if (iv != 0) {\n                        if (iv == 4)\n                            input.keyboardType = 'number';\n                        else if (iv == 3)\n                            input.keyboardType = 'url';\n                    }\n                    if (buffer.readBool())\n                        input.password = true;\n                }\n                else\n                    buffer.skip(13);\n            }\n        }\n    }\n    fgui.GLabel = GLabel;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GList extends fgui.GComponent {\n        constructor() {\n            super();\n            this._lineCount = 0;\n            this._columnCount = 0;\n            this._lineGap = 0;\n            this._columnGap = 0;\n            this._lastSelectedIndex = 0;\n            this._numItems = 0;\n            this._firstIndex = 0;\n            this._curLineItemCount = 0;\n            this._virtualListChanged = 0;\n            this.itemInfoVer = 0;\n            this._trackBounds = true;\n            this._pool = new fgui.GObjectPool();\n            this._layout = fgui.ListLayoutType.SingleColumn;\n            this._autoResizeItem = true;\n            this._lastSelectedIndex = -1;\n            this._selectionMode = fgui.ListSelectionMode.Single;\n            this.opaque = true;\n            this.scrollItemToViewOnClick = true;\n            this._align = \"left\";\n            this._verticalAlign = \"top\";\n            this._container = new fgui.DisplayObject();\n            this._displayObject.addChild(this._container);\n        }\n        dispose() {\n            this._pool.clear();\n            super.dispose();\n        }\n        get layout() {\n            return this._layout;\n        }\n        set layout(value) {\n            if (this._layout != value) {\n                this._layout = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get lineCount() {\n            return this._lineCount;\n        }\n        set lineCount(value) {\n            if (this._lineCount != value) {\n                this._lineCount = value;\n                if (this._layout == fgui.ListLayoutType.FlowVertical || this._layout == fgui.ListLayoutType.Pagination) {\n                    this.setBoundsChangedFlag();\n                    if (this._virtual)\n                        this.setVirtualListChangedFlag(true);\n                }\n            }\n        }\n        get columnCount() {\n            return this._columnCount;\n        }\n        set columnCount(value) {\n            if (this._columnCount != value) {\n                this._columnCount = value;\n                if (this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.Pagination) {\n                    this.setBoundsChangedFlag();\n                    if (this._virtual)\n                        this.setVirtualListChangedFlag(true);\n                }\n            }\n        }\n        get lineGap() {\n            return this._lineGap;\n        }\n        set lineGap(value) {\n            if (this._lineGap != value) {\n                this._lineGap = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get columnGap() {\n            return this._columnGap;\n        }\n        set columnGap(value) {\n            if (this._columnGap != value) {\n                this._columnGap = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get align() {\n            return this._align;\n        }\n        set align(value) {\n            if (this._align != value) {\n                this._align = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get verticalAlign() {\n            return this._verticalAlign;\n        }\n        set verticalAlign(value) {\n            if (this._verticalAlign != value) {\n                this._verticalAlign = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get virtualItemSize() {\n            return this._itemSize;\n        }\n        set virtualItemSize(value) {\n            if (this._virtual) {\n                if (this._itemSize == null)\n                    this._itemSize = new THREE.Vector2();\n                this._itemSize.set(value.x, value.y);\n                this.setVirtualListChangedFlag(true);\n            }\n        }\n        get defaultItem() {\n            return this._defaultItem;\n        }\n        set defaultItem(val) {\n            this._defaultItem = val;\n        }\n        get autoResizeItem() {\n            return this._autoResizeItem;\n        }\n        set autoResizeItem(value) {\n            if (this._autoResizeItem != value) {\n                this._autoResizeItem = value;\n                this.setBoundsChangedFlag();\n                if (this._virtual)\n                    this.setVirtualListChangedFlag(true);\n            }\n        }\n        get selectionMode() {\n            return this._selectionMode;\n        }\n        set selectionMode(value) {\n            this._selectionMode = value;\n        }\n        get selectionController() {\n            return this._selectionController;\n        }\n        set selectionController(value) {\n            this._selectionController = value;\n        }\n        get itemPool() {\n            return this._pool;\n        }\n        getFromPool(url) {\n            if (!url)\n                url = this._defaultItem;\n            var obj = this._pool.getObject(url);\n            if (obj)\n                obj.visible = true;\n            return obj;\n        }\n        returnToPool(obj) {\n            this._pool.returnObject(obj);\n        }\n        addChildAt(child, index) {\n            super.addChildAt(child, index);\n            if (child instanceof fgui.GButton) {\n                var button = (child);\n                button.selected = false;\n                button.changeStateOnClick = false;\n            }\n            child.on(fgui.InteractiveEvents.Click, this.__clickItem, this);\n            return child;\n        }\n        addItem(url) {\n            if (!url)\n                url = this._defaultItem;\n            return this.addChild(fgui.UIPackage.createObjectFromURL(url));\n        }\n        addItemFromPool(url) {\n            return this.addChild(this.getFromPool(url));\n        }\n        removeChildAt(index, dispose) {\n            var child = super.removeChildAt(index);\n            if (dispose)\n                child.dispose();\n            else\n                child.off(fgui.InteractiveEvents.Click, this.__clickItem, this);\n            return child;\n        }\n        removeChildToPoolAt(index) {\n            var child = super.removeChildAt(index);\n            this.returnToPool(child);\n        }\n        removeChildToPool(child) {\n            super.removeChild(child);\n            this.returnToPool(child);\n        }\n        removeChildrenToPool(beginIndex, endIndex) {\n            beginIndex = beginIndex || 0;\n            if (endIndex == null)\n                endIndex = -1;\n            if (endIndex < 0 || endIndex >= this._children.length)\n                endIndex = this._children.length - 1;\n            for (var i = beginIndex; i <= endIndex; ++i)\n                this.removeChildToPoolAt(beginIndex);\n        }\n        get selectedIndex() {\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if ((ii.obj instanceof fgui.GButton) && ii.obj.selected\n                        || ii.obj == null && ii.selected) {\n                        if (this._loop)\n                            return i % this._numItems;\n                        else\n                            return i;\n                    }\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj && obj.selected)\n                        return i;\n                }\n            }\n            return -1;\n        }\n        set selectedIndex(value) {\n            if (value >= 0 && value < this.numItems) {\n                if (this._selectionMode != fgui.ListSelectionMode.Single)\n                    this.clearSelection();\n                this.addSelection(value);\n            }\n            else\n                this.clearSelection();\n        }\n        getSelection(result) {\n            if (!result)\n                result = new Array();\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if ((ii.obj instanceof fgui.GButton) && ii.obj.selected\n                        || ii.obj == null && ii.selected) {\n                        var j = i;\n                        if (this._loop) {\n                            j = i % this._numItems;\n                            if (result.indexOf(j) != -1)\n                                continue;\n                        }\n                        result.push(j);\n                    }\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj && obj.selected)\n                        result.push(i);\n                }\n            }\n            return result;\n        }\n        addSelection(index, scrollItToView) {\n            if (this._selectionMode == fgui.ListSelectionMode.None)\n                return;\n            this.checkVirtualList();\n            if (this._selectionMode == fgui.ListSelectionMode.Single)\n                this.clearSelection();\n            if (scrollItToView)\n                this.scrollToView(index);\n            this._lastSelectedIndex = index;\n            var obj = null;\n            if (this._virtual) {\n                var ii = this._virtualItems[index];\n                if (ii.obj)\n                    obj = ii.obj;\n                ii.selected = true;\n            }\n            else\n                obj = this.getChildAt(index);\n            if (obj && !obj.selected) {\n                obj.selected = true;\n                this.updateSelectionController(index);\n            }\n        }\n        removeSelection(index) {\n            if (this._selectionMode == fgui.ListSelectionMode.None)\n                return;\n            var obj = null;\n            if (this._virtual) {\n                var ii = this._virtualItems[index];\n                if (ii.obj)\n                    obj = ii.obj;\n                ii.selected = false;\n            }\n            else\n                obj = this.getChildAt(index);\n            if (obj)\n                obj.selected = false;\n        }\n        clearSelection() {\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.obj.selected = false;\n                    ii.selected = false;\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj)\n                        obj.selected = false;\n                }\n            }\n        }\n        clearSelectionExcept(g) {\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if (ii.obj != g) {\n                        if ((ii.obj instanceof fgui.GButton))\n                            ii.obj.selected = false;\n                        ii.selected = false;\n                    }\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj && obj != g)\n                        obj.selected = false;\n                }\n            }\n        }\n        selectAll() {\n            this.checkVirtualList();\n            var last = -1;\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if ((ii.obj instanceof fgui.GButton) && !ii.obj.selected) {\n                        ii.obj.selected = true;\n                        last = i;\n                    }\n                    ii.selected = true;\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj && !obj.selected) {\n                        obj.selected = true;\n                        last = i;\n                    }\n                }\n            }\n            if (last != -1)\n                this.updateSelectionController(last);\n        }\n        selectNone() {\n            this.clearSelection();\n        }\n        selectReverse() {\n            this.checkVirtualList();\n            var last = -1;\n            var i;\n            if (this._virtual) {\n                for (i = 0; i < this._realNumItems; i++) {\n                    var ii = this._virtualItems[i];\n                    if (ii.obj instanceof fgui.GButton) {\n                        ii.obj.selected = !ii.obj.selected;\n                        if (ii.obj.selected)\n                            last = i;\n                    }\n                    ii.selected = !ii.selected;\n                }\n            }\n            else {\n                var cnt = this._children.length;\n                for (i = 0; i < cnt; i++) {\n                    var obj = this._children[i];\n                    if (obj) {\n                        obj.selected = !obj.selected;\n                        if (obj.selected)\n                            last = i;\n                    }\n                }\n            }\n            if (last != -1)\n                this.updateSelectionController(last);\n        }\n        handleArrowKey(dir) {\n            var index = this.selectedIndex;\n            if (index == -1)\n                return;\n            switch (dir) {\n                case 1:\n                    if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowVertical) {\n                        index--;\n                        if (index >= 0) {\n                            this.clearSelection();\n                            this.addSelection(index, true);\n                        }\n                    }\n                    else if (this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.Pagination) {\n                        var current = this._children[index];\n                        var k = 0;\n                        for (var i = index - 1; i >= 0; i--) {\n                            var obj = this._children[i];\n                            if (obj.y != current.y) {\n                                current = obj;\n                                break;\n                            }\n                            k++;\n                        }\n                        for (; i >= 0; i--) {\n                            obj = this._children[i];\n                            if (obj.y != current.y) {\n                                this.clearSelection();\n                                this.addSelection(i + k + 1, true);\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                case 3:\n                    if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.Pagination) {\n                        index++;\n                        if (index < this.numItems) {\n                            this.clearSelection();\n                            this.addSelection(index, true);\n                        }\n                    }\n                    else if (this._layout == fgui.ListLayoutType.FlowVertical) {\n                        current = this._children[index];\n                        k = 0;\n                        var cnt = this._children.length;\n                        for (i = index + 1; i < cnt; i++) {\n                            obj = this._children[i];\n                            if (obj.x != current.x) {\n                                current = obj;\n                                break;\n                            }\n                            k++;\n                        }\n                        for (; i < cnt; i++) {\n                            obj = this._children[i];\n                            if (obj.x != current.x) {\n                                this.clearSelection();\n                                this.addSelection(i - k - 1, true);\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                case 5:\n                    if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowVertical) {\n                        index++;\n                        if (index < this.numItems) {\n                            this.clearSelection();\n                            this.addSelection(index, true);\n                        }\n                    }\n                    else if (this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.Pagination) {\n                        current = this._children[index];\n                        k = 0;\n                        cnt = this._children.length;\n                        for (i = index + 1; i < cnt; i++) {\n                            obj = this._children[i];\n                            if (obj.y != current.y) {\n                                current = obj;\n                                break;\n                            }\n                            k++;\n                        }\n                        for (; i < cnt; i++) {\n                            obj = this._children[i];\n                            if (obj.y != current.y) {\n                                this.clearSelection();\n                                this.addSelection(i - k - 1, true);\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                case 7:\n                    if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.Pagination) {\n                        index--;\n                        if (index >= 0) {\n                            this.clearSelection();\n                            this.addSelection(index, true);\n                        }\n                    }\n                    else if (this._layout == fgui.ListLayoutType.FlowVertical) {\n                        current = this._children[index];\n                        k = 0;\n                        for (i = index - 1; i >= 0; i--) {\n                            obj = this._children[i];\n                            if (obj.x != current.x) {\n                                current = obj;\n                                break;\n                            }\n                            k++;\n                        }\n                        for (; i >= 0; i--) {\n                            obj = this._children[i];\n                            if (obj.x != current.x) {\n                                this.clearSelection();\n                                this.addSelection(i + k + 1, true);\n                                break;\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n        __clickItem(evt) {\n            if (this._scrollPane && this._scrollPane.isDragged)\n                return;\n            var item = fgui.GObject.cast(evt.sender);\n            this.setSelectionOnEvent(item, evt);\n            if (this._scrollPane && this.scrollItemToViewOnClick)\n                this._scrollPane.scrollToView(item, true);\n            this.dispatchItemEvent(item, evt);\n        }\n        dispatchItemEvent(item, evt) {\n            this.dispatchEvent(fgui.ListEvent.ItemClick, item);\n        }\n        setSelectionOnEvent(item, evt) {\n            if (!(item instanceof fgui.GButton) || this._selectionMode == fgui.ListSelectionMode.None)\n                return;\n            var dontChangeLastIndex = false;\n            var button = (item);\n            var index = this.childIndexToItemIndex(this.getChildIndex(item));\n            if (this._selectionMode == fgui.ListSelectionMode.Single) {\n                if (!button.selected) {\n                    this.clearSelectionExcept(button);\n                    button.selected = true;\n                }\n            }\n            else {\n                if (evt.input.shiftKey) {\n                    if (!button.selected) {\n                        if (this._lastSelectedIndex != -1) {\n                            var min = Math.min(this._lastSelectedIndex, index);\n                            var max = Math.max(this._lastSelectedIndex, index);\n                            max = Math.min(max, this.numItems - 1);\n                            var i;\n                            if (this._virtual) {\n                                for (i = min; i <= max; i++) {\n                                    var ii = this._virtualItems[i];\n                                    if (ii.obj instanceof fgui.GButton)\n                                        ii.obj.selected = true;\n                                    ii.selected = true;\n                                }\n                            }\n                            else {\n                                for (i = min; i <= max; i++) {\n                                    var obj = this.getChildAt(i);\n                                    if (obj)\n                                        obj.selected = true;\n                                }\n                            }\n                            dontChangeLastIndex = true;\n                        }\n                        else {\n                            button.selected = true;\n                        }\n                    }\n                }\n                else if ((evt.input.ctrlKey || evt.input.commandKey) || this._selectionMode == fgui.ListSelectionMode.Multiple_SingleClick) {\n                    button.selected = !button.selected;\n                }\n                else {\n                    if (!button.selected) {\n                        this.clearSelectionExcept(button);\n                        button.selected = true;\n                    }\n                    else\n                        this.clearSelectionExcept(button);\n                }\n            }\n            if (!dontChangeLastIndex)\n                this._lastSelectedIndex = index;\n            if (button.selected)\n                this.updateSelectionController(index);\n        }\n        resizeToFit(itemCount, minSize) {\n            this.ensureBoundsCorrect();\n            var curCount = this.numItems;\n            if (itemCount == null || itemCount > curCount)\n                itemCount = curCount;\n            minSize = minSize || 0;\n            if (this._virtual) {\n                var lineCount = Math.ceil(itemCount / this._curLineItemCount);\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal)\n                    this.viewHeight = lineCount * this._itemSize.y + Math.max(0, lineCount - 1) * this._lineGap;\n                else\n                    this.viewWidth = lineCount * this._itemSize.x + Math.max(0, lineCount - 1) * this._columnGap;\n            }\n            else if (itemCount == 0) {\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal)\n                    this.viewHeight = minSize;\n                else\n                    this.viewWidth = minSize;\n            }\n            else {\n                var i = itemCount - 1;\n                var obj = null;\n                while (i >= 0) {\n                    obj = this.getChildAt(i);\n                    if (!this.foldInvisibleItems || obj.visible)\n                        break;\n                    i--;\n                }\n                if (i < 0) {\n                    if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal)\n                        this.viewHeight = minSize;\n                    else\n                        this.viewWidth = minSize;\n                }\n                else {\n                    var size = 0;\n                    if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                        size = obj.y + obj.height;\n                        if (size < minSize)\n                            size = minSize;\n                        this.viewHeight = size;\n                    }\n                    else {\n                        size = obj.x + obj.width;\n                        if (size < minSize)\n                            size = minSize;\n                        this.viewWidth = size;\n                    }\n                }\n            }\n        }\n        getMaxItemWidth() {\n            var cnt = this._children.length;\n            var max = 0;\n            for (var i = 0; i < cnt; i++) {\n                var child = this.getChildAt(i);\n                if (child.width > max)\n                    max = child.width;\n            }\n            return max;\n        }\n        handleSizeChanged() {\n            super.handleSizeChanged();\n            this.setBoundsChangedFlag();\n            if (this._virtual)\n                this.setVirtualListChangedFlag(true);\n        }\n        handleControllerChanged(c) {\n            super.handleControllerChanged(c);\n            if (this._selectionController == c)\n                this.selectedIndex = c.selectedIndex;\n        }\n        updateSelectionController(index) {\n            if (this._selectionController && !this._selectionController.changing\n                && index < this._selectionController.pageCount) {\n                var c = this._selectionController;\n                this._selectionController = null;\n                c.selectedIndex = index;\n                this._selectionController = c;\n            }\n        }\n        shouldSnapToNext(dir, delta, size) {\n            return dir < 0 && delta > fgui.UIConfig.defaultScrollSnappingThreshold * size\n                || dir > 0 && delta > (1 - fgui.UIConfig.defaultScrollSnappingThreshold) * size\n                || dir == 0 && delta > size / 2;\n        }\n        getSnappingPositionWithDir(xValue, yValue, xDir, yDir, resultPoint) {\n            if (this._virtual) {\n                if (!resultPoint)\n                    resultPoint = new THREE.Vector2();\n                var saved;\n                var index;\n                var size;\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                    saved = yValue;\n                    s_n = yValue;\n                    index = this.getIndexOnPos1(false);\n                    yValue = s_n;\n                    if (index < this._virtualItems.length && index < this._realNumItems) {\n                        size = this._virtualItems[index].height;\n                        if (this.shouldSnapToNext(yDir, saved - yValue, size))\n                            yValue += size + this._lineGap;\n                    }\n                }\n                else if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowVertical) {\n                    saved = xValue;\n                    s_n = xValue;\n                    index = this.getIndexOnPos2(false);\n                    xValue = s_n;\n                    if (index < this._virtualItems.length && index < this._realNumItems) {\n                        size = this._virtualItems[index].width;\n                        if (this.shouldSnapToNext(xDir, saved - xValue, size))\n                            xValue += size + this._columnGap;\n                    }\n                }\n                else {\n                    saved = xValue;\n                    s_n = xValue;\n                    index = this.getIndexOnPos3(false);\n                    xValue = s_n;\n                    if (index < this._virtualItems.length && index < this._realNumItems) {\n                        size = this._virtualItems[index].width;\n                        if (this.shouldSnapToNext(xDir, saved - xValue, size))\n                            xValue += size + this._columnGap;\n                    }\n                }\n                resultPoint.x = xValue;\n                resultPoint.y = yValue;\n                return resultPoint;\n            }\n            else\n                return super.getSnappingPositionWithDir(xValue, yValue, xDir, yDir, resultPoint);\n        }\n        scrollToView(index, ani, setFirst) {\n            if (this._virtual) {\n                if (this._numItems == 0)\n                    return;\n                this.checkVirtualList();\n                if (index >= this._virtualItems.length)\n                    throw new Error(\"Invalid child index: \" + index + \">\" + this._virtualItems.length);\n                if (this._loop)\n                    index = Math.floor(this._firstIndex / this._numItems) * this._numItems + index;\n                var rect;\n                var ii = this._virtualItems[index];\n                var pos = 0;\n                var i;\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                    for (i = this._curLineItemCount - 1; i < index; i += this._curLineItemCount)\n                        pos += this._virtualItems[i].height + this._lineGap;\n                    rect = new fgui.Rect(0, pos, this._itemSize.x, ii.height);\n                }\n                else if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowVertical) {\n                    for (i = this._curLineItemCount - 1; i < index; i += this._curLineItemCount)\n                        pos += this._virtualItems[i].width + this._columnGap;\n                    rect = new fgui.Rect(pos, 0, ii.width, this._itemSize.y);\n                }\n                else {\n                    var page = index / (this._curLineItemCount * this._curLineItemCount2);\n                    rect = new fgui.Rect(page * this.viewWidth + (index % this._curLineItemCount) * (ii.width + this._columnGap), (index / this._curLineItemCount) % this._curLineItemCount2 * (ii.height + this._lineGap), ii.width, ii.height);\n                }\n                setFirst = true;\n                if (this._scrollPane)\n                    this._scrollPane.scrollToView(rect, ani, setFirst);\n            }\n            else {\n                var obj = this.getChildAt(index);\n                if (this._scrollPane)\n                    this._scrollPane.scrollToView(obj, ani, setFirst);\n                else if (this._parent && this._parent.scrollPane)\n                    this._parent.scrollPane.scrollToView(obj, ani, setFirst);\n            }\n        }\n        getFirstChildInView() {\n            return this.childIndexToItemIndex(super.getFirstChildInView());\n        }\n        childIndexToItemIndex(index) {\n            if (!this._virtual)\n                return index;\n            if (this._layout == fgui.ListLayoutType.Pagination) {\n                for (var i = this._firstIndex; i < this._realNumItems; i++) {\n                    if (this._virtualItems[i].obj) {\n                        index--;\n                        if (index < 0)\n                            return i;\n                    }\n                }\n                return index;\n            }\n            else {\n                index += this._firstIndex;\n                if (this._loop && this._numItems > 0)\n                    index = index % this._numItems;\n                return index;\n            }\n        }\n        itemIndexToChildIndex(index) {\n            if (!this._virtual)\n                return index;\n            if (this._layout == fgui.ListLayoutType.Pagination) {\n                return this.getChildIndex(this._virtualItems[index].obj);\n            }\n            else {\n                if (this._loop && this._numItems > 0) {\n                    var j = this._firstIndex % this._numItems;\n                    if (index >= j)\n                        index = index - j;\n                    else\n                        index = this._numItems - j + index;\n                }\n                else\n                    index -= this._firstIndex;\n                return index;\n            }\n        }\n        setVirtual() {\n            this._setVirtual(false);\n        }\n        setVirtualAndLoop() {\n            this._setVirtual(true);\n        }\n        _setVirtual(loop) {\n            if (!this._virtual) {\n                if (this._scrollPane == null)\n                    throw new Error(\"Virtual list must be scrollable!\");\n                if (loop) {\n                    if (this._layout == fgui.ListLayoutType.FlowHorizontal || this._layout == fgui.ListLayoutType.FlowVertical)\n                        throw new Error(\"Loop list instanceof not supported for FlowHorizontal or FlowVertical this.layout!\");\n                    this._scrollPane.bouncebackEffect = false;\n                }\n                this._virtual = true;\n                this._loop = loop;\n                this._virtualItems = new Array();\n                this.removeChildrenToPool();\n                if (this._itemSize == null) {\n                    this._itemSize = new THREE.Vector2();\n                    var obj = this.getFromPool(null);\n                    if (obj == null) {\n                        throw new Error(\"Virtual List must have a default list item resource.\");\n                    }\n                    else {\n                        this._itemSize.x = obj.width;\n                        this._itemSize.y = obj.height;\n                    }\n                    this.returnToPool(obj);\n                }\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                    this._scrollPane.scrollStep = this._itemSize.y;\n                    if (this._loop)\n                        this._scrollPane._loop = 2;\n                }\n                else {\n                    this._scrollPane.scrollStep = this._itemSize.x;\n                    if (this._loop)\n                        this._scrollPane._loop = 1;\n                }\n                this.on(fgui.ScrollEvent.SCROLL, this.__scrolled, this);\n                this.setVirtualListChangedFlag(true);\n            }\n        }\n        get numItems() {\n            if (this._virtual)\n                return this._numItems;\n            else\n                return this._children.length;\n        }\n        set numItems(value) {\n            var i;\n            if (this._virtual) {\n                if (this.itemRenderer == null)\n                    throw new Error(\"set itemRenderer first!\");\n                this._numItems = value;\n                if (this._loop)\n                    this._realNumItems = this._numItems * 6;\n                else\n                    this._realNumItems = this._numItems;\n                var oldCount = this._virtualItems.length;\n                if (this._realNumItems > oldCount) {\n                    for (i = oldCount; i < this._realNumItems; i++) {\n                        var ii = { width: 0, height: 0, flag: 0 };\n                        ii.width = this._itemSize.x;\n                        ii.height = this._itemSize.y;\n                        this._virtualItems.push(ii);\n                    }\n                }\n                else {\n                    for (i = this._realNumItems; i < oldCount; i++)\n                        this._virtualItems[i].selected = false;\n                }\n                if (this._virtualListChanged != 0)\n                    fgui.Timers.remove(this._refreshVirtualList, this);\n                this._refreshVirtualList();\n            }\n            else {\n                var cnt = this._children.length;\n                if (value > cnt) {\n                    for (i = cnt; i < value; i++) {\n                        if (this.itemProvider == null)\n                            this.addItemFromPool();\n                        else\n                            this.addItemFromPool(this.itemProvider(i));\n                    }\n                }\n                else {\n                    this.removeChildrenToPool(value, cnt);\n                }\n                if (this.itemRenderer) {\n                    for (i = 0; i < value; i++)\n                        this.itemRenderer(i, this.getChildAt(i));\n                }\n            }\n        }\n        refreshVirtualList() {\n            this.setVirtualListChangedFlag(false);\n        }\n        checkVirtualList() {\n            if (this._virtualListChanged != 0) {\n                this._refreshVirtualList();\n                fgui.Timers.remove(this._refreshVirtualList, this);\n            }\n        }\n        setVirtualListChangedFlag(layoutChanged) {\n            if (layoutChanged)\n                this._virtualListChanged = 2;\n            else if (this._virtualListChanged == 0)\n                this._virtualListChanged = 1;\n            fgui.Timers.callLater(this._refreshVirtualList, this);\n        }\n        _refreshVirtualList() {\n            if (!this._displayObject)\n                return;\n            var layoutChanged = this._virtualListChanged == 2;\n            this._virtualListChanged = 0;\n            this._eventLocked = true;\n            if (layoutChanged) {\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.SingleRow)\n                    this._curLineItemCount = 1;\n                else if (this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                    if (this._columnCount > 0)\n                        this._curLineItemCount = this._columnCount;\n                    else {\n                        this._curLineItemCount = Math.floor((this._scrollPane.viewWidth + this._columnGap) / (this._itemSize.x + this._columnGap));\n                        if (this._curLineItemCount <= 0)\n                            this._curLineItemCount = 1;\n                    }\n                }\n                else if (this._layout == fgui.ListLayoutType.FlowVertical) {\n                    if (this._lineCount > 0)\n                        this._curLineItemCount = this._lineCount;\n                    else {\n                        this._curLineItemCount = Math.floor((this._scrollPane.viewHeight + this._lineGap) / (this._itemSize.y + this._lineGap));\n                        if (this._curLineItemCount <= 0)\n                            this._curLineItemCount = 1;\n                    }\n                }\n                else {\n                    if (this._columnCount > 0)\n                        this._curLineItemCount = this._columnCount;\n                    else {\n                        this._curLineItemCount = Math.floor((this._scrollPane.viewWidth + this._columnGap) / (this._itemSize.x + this._columnGap));\n                        if (this._curLineItemCount <= 0)\n                            this._curLineItemCount = 1;\n                    }\n                    if (this._lineCount > 0)\n                        this._curLineItemCount2 = this._lineCount;\n                    else {\n                        this._curLineItemCount2 = Math.floor((this._scrollPane.viewHeight + this._lineGap) / (this._itemSize.y + this._lineGap));\n                        if (this._curLineItemCount2 <= 0)\n                            this._curLineItemCount2 = 1;\n                    }\n                }\n            }\n            var ch = 0, cw = 0;\n            if (this._realNumItems > 0) {\n                var i;\n                var len = Math.ceil(this._realNumItems / this._curLineItemCount) * this._curLineItemCount;\n                var len2 = Math.min(this._curLineItemCount, this._realNumItems);\n                if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                    for (i = 0; i < len; i += this._curLineItemCount)\n                        ch += this._virtualItems[i].height + this._lineGap;\n                    if (ch > 0)\n                        ch -= this._lineGap;\n                    if (this._autoResizeItem)\n                        cw = this._scrollPane.viewWidth;\n                    else {\n                        for (i = 0; i < len2; i++)\n                            cw += this._virtualItems[i].width + this._columnGap;\n                        if (cw > 0)\n                            cw -= this._columnGap;\n                    }\n                }\n                else if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowVertical) {\n                    for (i = 0; i < len; i += this._curLineItemCount)\n                        cw += this._virtualItems[i].width + this._columnGap;\n                    if (cw > 0)\n                        cw -= this._columnGap;\n                    if (this._autoResizeItem)\n                        ch = this._scrollPane.viewHeight;\n                    else {\n                        for (i = 0; i < len2; i++)\n                            ch += this._virtualItems[i].height + this._lineGap;\n                        if (ch > 0)\n                            ch -= this._lineGap;\n                    }\n                }\n                else {\n                    var pageCount = Math.ceil(len / (this._curLineItemCount * this._curLineItemCount2));\n                    cw = pageCount * this.viewWidth;\n                    ch = this.viewHeight;\n                }\n            }\n            this.handleAlign(cw, ch);\n            this._scrollPane.setContentSize(cw, ch);\n            this._eventLocked = false;\n            this.handleScroll(true);\n        }\n        __scrolled() {\n            this.handleScroll(false);\n        }\n        getIndexOnPos1(forceUpdate) {\n            if (this._realNumItems < this._curLineItemCount) {\n                s_n = 0;\n                return 0;\n            }\n            var i;\n            var pos2;\n            var pos3;\n            if (this.numChildren > 0 && !forceUpdate) {\n                pos2 = this.getChildAt(0).y;\n                if (pos2 > s_n) {\n                    for (i = this._firstIndex - this._curLineItemCount; i >= 0; i -= this._curLineItemCount) {\n                        pos2 -= (this._virtualItems[i].height + this._lineGap);\n                        if (pos2 <= s_n) {\n                            s_n = pos2;\n                            return i;\n                        }\n                    }\n                    s_n = 0;\n                    return 0;\n                }\n                else {\n                    for (i = this._firstIndex; i < this._realNumItems; i += this._curLineItemCount) {\n                        pos3 = pos2 + this._virtualItems[i].height + this._lineGap;\n                        if (pos3 > s_n) {\n                            s_n = pos2;\n                            return i;\n                        }\n                        pos2 = pos3;\n                    }\n                    s_n = pos2;\n                    return this._realNumItems - this._curLineItemCount;\n                }\n            }\n            else {\n                pos2 = 0;\n                for (i = 0; i < this._realNumItems; i += this._curLineItemCount) {\n                    pos3 = pos2 + this._virtualItems[i].height + this._lineGap;\n                    if (pos3 > s_n) {\n                        s_n = pos2;\n                        return i;\n                    }\n                    pos2 = pos3;\n                }\n                s_n = pos2;\n                return this._realNumItems - this._curLineItemCount;\n            }\n        }\n        getIndexOnPos2(forceUpdate) {\n            if (this._realNumItems < this._curLineItemCount) {\n                s_n = 0;\n                return 0;\n            }\n            var i;\n            var pos2;\n            var pos3;\n            if (this.numChildren > 0 && !forceUpdate) {\n                pos2 = this.getChildAt(0).x;\n                if (pos2 > s_n) {\n                    for (i = this._firstIndex - this._curLineItemCount; i >= 0; i -= this._curLineItemCount) {\n                        pos2 -= (this._virtualItems[i].width + this._columnGap);\n                        if (pos2 <= s_n) {\n                            s_n = pos2;\n                            return i;\n                        }\n                    }\n                    s_n = 0;\n                    return 0;\n                }\n                else {\n                    for (i = this._firstIndex; i < this._realNumItems; i += this._curLineItemCount) {\n                        pos3 = pos2 + this._virtualItems[i].width + this._columnGap;\n                        if (pos3 > s_n) {\n                            s_n = pos2;\n                            return i;\n                        }\n                        pos2 = pos3;\n                    }\n                    s_n = pos2;\n                    return this._realNumItems - this._curLineItemCount;\n                }\n            }\n            else {\n                pos2 = 0;\n                for (i = 0; i < this._realNumItems; i += this._curLineItemCount) {\n                    pos3 = pos2 + this._virtualItems[i].width + this._columnGap;\n                    if (pos3 > s_n) {\n                        s_n = pos2;\n                        return i;\n                    }\n                    pos2 = pos3;\n                }\n                s_n = pos2;\n                return this._realNumItems - this._curLineItemCount;\n            }\n        }\n        getIndexOnPos3(forceUpdate) {\n            if (this._realNumItems < this._curLineItemCount) {\n                s_n = 0;\n                return 0;\n            }\n            var viewWidth = this.viewWidth;\n            var page = Math.floor(s_n / viewWidth);\n            var startIndex = page * (this._curLineItemCount * this._curLineItemCount2);\n            var pos2 = page * viewWidth;\n            var i;\n            var pos3;\n            for (i = 0; i < this._curLineItemCount; i++) {\n                pos3 = pos2 + this._virtualItems[startIndex + i].width + this._columnGap;\n                if (pos3 > s_n) {\n                    s_n = pos2;\n                    return startIndex + i;\n                }\n                pos2 = pos3;\n            }\n            s_n = pos2;\n            return startIndex + this._curLineItemCount - 1;\n        }\n        handleScroll(forceUpdate) {\n            if (this._eventLocked)\n                return;\n            if (this._layout == fgui.ListLayoutType.SingleColumn || this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                var enterCounter = 0;\n                while (this.handleScroll1(forceUpdate)) {\n                    enterCounter++;\n                    forceUpdate = false;\n                    if (enterCounter > 20) {\n                        console.log(\"list will never be <the> filled item renderer function always returns a different size.\");\n                        break;\n                    }\n                }\n                this.handleArchOrder1();\n            }\n            else if (this._layout == fgui.ListLayoutType.SingleRow || this._layout == fgui.ListLayoutType.FlowVertical) {\n                enterCounter = 0;\n                while (this.handleScroll2(forceUpdate)) {\n                    enterCounter++;\n                    forceUpdate = false;\n                    if (enterCounter > 20) {\n                        console.log(\"list will never be <the> filled item renderer function always returns a different size.\");\n                        break;\n                    }\n                }\n                this.handleArchOrder2();\n            }\n            else {\n                this.handleScroll3(forceUpdate);\n            }\n            this._boundsChanged = false;\n        }\n        handleScroll1(forceUpdate) {\n            var pos = this._scrollPane.scrollingPosY;\n            var max = pos + this._scrollPane.viewHeight;\n            var end = max == this._scrollPane.contentHeight;\n            s_n = pos;\n            var newFirstIndex = this.getIndexOnPos1(forceUpdate);\n            pos = s_n;\n            if (newFirstIndex == this._firstIndex && !forceUpdate)\n                return false;\n            var oldFirstIndex = this._firstIndex;\n            this._firstIndex = newFirstIndex;\n            var curIndex = newFirstIndex;\n            var forward = oldFirstIndex > newFirstIndex;\n            var childCount = this.numChildren;\n            var lastIndex = oldFirstIndex + childCount - 1;\n            var reuseIndex = forward ? lastIndex : oldFirstIndex;\n            var curX = 0, curY = pos;\n            var needRender;\n            var deltaSize = 0;\n            var firstItemDeltaSize = 0;\n            var url = this.defaultItem;\n            var ii, ii2;\n            var i, j;\n            var partSize = (this._scrollPane.viewWidth - this._columnGap * (this._curLineItemCount - 1)) / this._curLineItemCount;\n            this.itemInfoVer++;\n            while (curIndex < this._realNumItems && (end || curY < max)) {\n                ii = this._virtualItems[curIndex];\n                if (ii.obj == null || forceUpdate) {\n                    if (this.itemProvider) {\n                        url = this.itemProvider(curIndex % this._numItems);\n                        if (url == null)\n                            url = this._defaultItem;\n                        url = fgui.UIPackage.normalizeURL(url);\n                    }\n                    if (ii.obj && ii.obj.resourceURL != url) {\n                        if (ii.obj instanceof fgui.GButton)\n                            ii.selected = ii.obj.selected;\n                        this.removeChildToPool(ii.obj);\n                        ii.obj = null;\n                    }\n                }\n                if (ii.obj == null) {\n                    if (forward) {\n                        for (j = reuseIndex; j >= oldFirstIndex; j--) {\n                            ii2 = this._virtualItems[j];\n                            if (ii2.obj && ii2.flag != this.itemInfoVer && ii2.obj.resourceURL == url) {\n                                if (ii2.obj instanceof fgui.GButton)\n                                    ii2.selected = ii2.obj.selected;\n                                ii.obj = ii2.obj;\n                                ii2.obj = null;\n                                if (j == reuseIndex)\n                                    reuseIndex--;\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        for (j = reuseIndex; j <= lastIndex; j++) {\n                            ii2 = this._virtualItems[j];\n                            if (ii2.obj && ii2.flag != this.itemInfoVer && ii2.obj.resourceURL == url) {\n                                if (ii2.obj instanceof fgui.GButton)\n                                    ii2.selected = ii2.obj.selected;\n                                ii.obj = ii2.obj;\n                                ii2.obj = null;\n                                if (j == reuseIndex)\n                                    reuseIndex++;\n                                break;\n                            }\n                        }\n                    }\n                    if (ii.obj) {\n                        this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);\n                    }\n                    else {\n                        ii.obj = this._pool.getObject(url);\n                        if (forward)\n                            this.addChildAt(ii.obj, curIndex - newFirstIndex);\n                        else\n                            this.addChild(ii.obj);\n                    }\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.obj.selected = ii.selected;\n                    needRender = true;\n                }\n                else\n                    needRender = forceUpdate;\n                if (needRender) {\n                    if (this._autoResizeItem && (this._layout == fgui.ListLayoutType.SingleColumn || this._columnCount > 0))\n                        ii.obj.setSize(partSize, ii.obj.height, true);\n                    this.itemRenderer(curIndex % this._numItems, ii.obj);\n                    if (curIndex % this._curLineItemCount == 0) {\n                        deltaSize += Math.ceil(ii.obj.height) - ii.height;\n                        if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex) {\n                            firstItemDeltaSize = Math.ceil(ii.obj.height) - ii.height;\n                        }\n                    }\n                    ii.width = Math.ceil(ii.obj.width);\n                    ii.height = Math.ceil(ii.obj.height);\n                }\n                ii.flag = this.itemInfoVer;\n                ii.obj.setPosition(curX, curY);\n                if (curIndex == newFirstIndex)\n                    max += ii.height;\n                curX += ii.width + this._columnGap;\n                if (curIndex % this._curLineItemCount == this._curLineItemCount - 1) {\n                    curX = 0;\n                    curY += ii.height + this._lineGap;\n                }\n                curIndex++;\n            }\n            for (i = 0; i < childCount; i++) {\n                ii = this._virtualItems[oldFirstIndex + i];\n                if (ii.flag != this.itemInfoVer && ii.obj) {\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.selected = ii.obj.selected;\n                    this.removeChildToPool(ii.obj);\n                    ii.obj = null;\n                }\n            }\n            childCount = this._children.length;\n            for (i = 0; i < childCount; i++) {\n                var obj = this._virtualItems[newFirstIndex + i].obj;\n                if (this._children[i] != obj)\n                    this.setChildIndex(obj, i);\n            }\n            if (deltaSize != 0 || firstItemDeltaSize != 0)\n                this._scrollPane.changeContentSizeOnScrolling(0, deltaSize, 0, firstItemDeltaSize);\n            if (curIndex > 0 && this.numChildren > 0 && this._container.y <= 0 && this.getChildAt(0).y > -this._container.y)\n                return true;\n            else\n                return false;\n        }\n        handleScroll2(forceUpdate) {\n            var pos = this._scrollPane.scrollingPosX;\n            var max = pos + this._scrollPane.viewWidth;\n            var end = pos == this._scrollPane.contentWidth;\n            s_n = pos;\n            var newFirstIndex = this.getIndexOnPos2(forceUpdate);\n            pos = s_n;\n            if (newFirstIndex == this._firstIndex && !forceUpdate)\n                return false;\n            var oldFirstIndex = this._firstIndex;\n            this._firstIndex = newFirstIndex;\n            var curIndex = newFirstIndex;\n            var forward = oldFirstIndex > newFirstIndex;\n            var childCount = this.numChildren;\n            var lastIndex = oldFirstIndex + childCount - 1;\n            var reuseIndex = forward ? lastIndex : oldFirstIndex;\n            var curX = pos, curY = 0;\n            var needRender;\n            var deltaSize = 0;\n            var firstItemDeltaSize = 0;\n            var url = this.defaultItem;\n            var ii, ii2;\n            var i, j;\n            var partSize = (this._scrollPane.viewHeight - this._lineGap * (this._curLineItemCount - 1)) / this._curLineItemCount;\n            this.itemInfoVer++;\n            while (curIndex < this._realNumItems && (end || curX < max)) {\n                ii = this._virtualItems[curIndex];\n                if (ii.obj == null || forceUpdate) {\n                    if (this.itemProvider) {\n                        url = this.itemProvider(curIndex % this._numItems);\n                        if (url == null)\n                            url = this._defaultItem;\n                        url = fgui.UIPackage.normalizeURL(url);\n                    }\n                    if (ii.obj && ii.obj.resourceURL != url) {\n                        if (ii.obj instanceof fgui.GButton)\n                            ii.selected = ii.obj.selected;\n                        this.removeChildToPool(ii.obj);\n                        ii.obj = null;\n                    }\n                }\n                if (ii.obj == null) {\n                    if (forward) {\n                        for (j = reuseIndex; j >= oldFirstIndex; j--) {\n                            ii2 = this._virtualItems[j];\n                            if (ii2.obj && ii2.flag != this.itemInfoVer && ii2.obj.resourceURL == url) {\n                                if (ii2.obj instanceof fgui.GButton)\n                                    ii2.selected = ii2.obj.selected;\n                                ii.obj = ii2.obj;\n                                ii2.obj = null;\n                                if (j == reuseIndex)\n                                    reuseIndex--;\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        for (j = reuseIndex; j <= lastIndex; j++) {\n                            ii2 = this._virtualItems[j];\n                            if (ii2.obj && ii2.flag != this.itemInfoVer && ii2.obj.resourceURL == url) {\n                                if (ii2.obj instanceof fgui.GButton)\n                                    ii2.selected = ii2.obj.selected;\n                                ii.obj = ii2.obj;\n                                ii2.obj = null;\n                                if (j == reuseIndex)\n                                    reuseIndex++;\n                                break;\n                            }\n                        }\n                    }\n                    if (ii.obj) {\n                        this.setChildIndex(ii.obj, forward ? curIndex - newFirstIndex : this.numChildren);\n                    }\n                    else {\n                        ii.obj = this._pool.getObject(url);\n                        if (forward)\n                            this.addChildAt(ii.obj, curIndex - newFirstIndex);\n                        else\n                            this.addChild(ii.obj);\n                    }\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.obj.selected = ii.selected;\n                    needRender = true;\n                }\n                else\n                    needRender = forceUpdate;\n                if (needRender) {\n                    if (this._autoResizeItem && (this._layout == fgui.ListLayoutType.SingleRow || this._lineCount > 0))\n                        ii.obj.setSize(ii.obj.width, partSize, true);\n                    this.itemRenderer(curIndex % this._numItems, ii.obj);\n                    if (curIndex % this._curLineItemCount == 0) {\n                        deltaSize += Math.ceil(ii.obj.width) - ii.width;\n                        if (curIndex == newFirstIndex && oldFirstIndex > newFirstIndex) {\n                            firstItemDeltaSize = Math.ceil(ii.obj.width) - ii.width;\n                        }\n                    }\n                    ii.width = Math.ceil(ii.obj.width);\n                    ii.height = Math.ceil(ii.obj.height);\n                }\n                ii.flag = this.itemInfoVer;\n                ii.obj.setPosition(curX, curY);\n                if (curIndex == newFirstIndex)\n                    max += ii.width;\n                curY += ii.height + this._lineGap;\n                if (curIndex % this._curLineItemCount == this._curLineItemCount - 1) {\n                    curY = 0;\n                    curX += ii.width + this._columnGap;\n                }\n                curIndex++;\n            }\n            for (i = 0; i < childCount; i++) {\n                ii = this._virtualItems[oldFirstIndex + i];\n                if (ii.flag != this.itemInfoVer && ii.obj) {\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.selected = ii.obj.selected;\n                    this.removeChildToPool(ii.obj);\n                    ii.obj = null;\n                }\n            }\n            childCount = this._children.length;\n            for (i = 0; i < childCount; i++) {\n                var obj = this._virtualItems[newFirstIndex + i].obj;\n                if (this._children[i] != obj)\n                    this.setChildIndex(obj, i);\n            }\n            if (deltaSize != 0 || firstItemDeltaSize != 0)\n                this._scrollPane.changeContentSizeOnScrolling(deltaSize, 0, firstItemDeltaSize, 0);\n            if (curIndex > 0 && this.numChildren > 0 && this._container.x <= 0 && this.getChildAt(0).x > -this._container.x)\n                return true;\n            else\n                return false;\n        }\n        handleScroll3(forceUpdate) {\n            var pos = this._scrollPane.scrollingPosX;\n            s_n = pos;\n            var newFirstIndex = this.getIndexOnPos3(forceUpdate);\n            pos = s_n;\n            if (newFirstIndex == this._firstIndex && !forceUpdate)\n                return;\n            var oldFirstIndex = this._firstIndex;\n            this._firstIndex = newFirstIndex;\n            var reuseIndex = oldFirstIndex;\n            var virtualItemCount = this._virtualItems.length;\n            var pageSize = this._curLineItemCount * this._curLineItemCount2;\n            var startCol = newFirstIndex % this._curLineItemCount;\n            var viewWidth = this.viewWidth;\n            var page = Math.floor(newFirstIndex / pageSize);\n            var startIndex = page * pageSize;\n            var lastIndex = startIndex + pageSize * 2;\n            var needRender;\n            var i;\n            var ii, ii2;\n            var col;\n            var url = this._defaultItem;\n            var partWidth = (this._scrollPane.viewWidth - this._columnGap * (this._curLineItemCount - 1)) / this._curLineItemCount;\n            var partHeight = (this._scrollPane.viewHeight - this._lineGap * (this._curLineItemCount2 - 1)) / this._curLineItemCount2;\n            this.itemInfoVer++;\n            for (i = startIndex; i < lastIndex; i++) {\n                if (i >= this._realNumItems)\n                    continue;\n                col = i % this._curLineItemCount;\n                if (i - startIndex < pageSize) {\n                    if (col < startCol)\n                        continue;\n                }\n                else {\n                    if (col > startCol)\n                        continue;\n                }\n                ii = this._virtualItems[i];\n                ii.flag = this.itemInfoVer;\n            }\n            var lastObj = null;\n            var insertIndex = 0;\n            for (i = startIndex; i < lastIndex; i++) {\n                if (i >= this._realNumItems)\n                    continue;\n                ii = this._virtualItems[i];\n                if (ii.flag != this.itemInfoVer)\n                    continue;\n                if (ii.obj == null) {\n                    while (reuseIndex < virtualItemCount) {\n                        ii2 = this._virtualItems[reuseIndex];\n                        if (ii2.obj && ii2.flag != this.itemInfoVer) {\n                            if (ii2.obj instanceof fgui.GButton)\n                                ii2.selected = ii2.obj.selected;\n                            ii.obj = ii2.obj;\n                            ii2.obj = null;\n                            break;\n                        }\n                        reuseIndex++;\n                    }\n                    if (insertIndex == -1)\n                        insertIndex = this.getChildIndex(lastObj) + 1;\n                    if (ii.obj == null) {\n                        if (this.itemProvider) {\n                            url = this.itemProvider(i % this._numItems);\n                            if (url == null)\n                                url = this._defaultItem;\n                            url = fgui.UIPackage.normalizeURL(url);\n                        }\n                        ii.obj = this._pool.getObject(url);\n                        this.addChildAt(ii.obj, insertIndex);\n                    }\n                    else {\n                        insertIndex = this.setChildIndexBefore(ii.obj, insertIndex);\n                    }\n                    insertIndex++;\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.obj.selected = ii.selected;\n                    needRender = true;\n                }\n                else {\n                    needRender = forceUpdate;\n                    insertIndex = -1;\n                    lastObj = ii.obj;\n                }\n                if (needRender) {\n                    if (this._autoResizeItem) {\n                        if (this._curLineItemCount == this._columnCount && this._curLineItemCount2 == this._lineCount)\n                            ii.obj.setSize(partWidth, partHeight, true);\n                        else if (this._curLineItemCount == this._columnCount)\n                            ii.obj.setSize(partWidth, ii.obj.height, true);\n                        else if (this._curLineItemCount2 == this._lineCount)\n                            ii.obj.setSize(ii.obj.width, partHeight, true);\n                    }\n                    this.itemRenderer(i % this._numItems, ii.obj);\n                    ii.width = Math.ceil(ii.obj.width);\n                    ii.height = Math.ceil(ii.obj.height);\n                }\n            }\n            var borderX = (startIndex / pageSize) * viewWidth;\n            var xx = borderX;\n            var yy = 0;\n            var lineHeight = 0;\n            for (i = startIndex; i < lastIndex; i++) {\n                if (i >= this._realNumItems)\n                    continue;\n                ii = this._virtualItems[i];\n                if (ii.flag == this.itemInfoVer)\n                    ii.obj.setPosition(xx, yy);\n                if (ii.height > lineHeight)\n                    lineHeight = ii.height;\n                if (i % this._curLineItemCount == this._curLineItemCount - 1) {\n                    xx = borderX;\n                    yy += lineHeight + this._lineGap;\n                    lineHeight = 0;\n                    if (i == startIndex + pageSize - 1) {\n                        borderX += viewWidth;\n                        xx = borderX;\n                        yy = 0;\n                    }\n                }\n                else\n                    xx += ii.width + this._columnGap;\n            }\n            for (i = reuseIndex; i < virtualItemCount; i++) {\n                ii = this._virtualItems[i];\n                if (ii.flag != this.itemInfoVer && ii.obj) {\n                    if (ii.obj instanceof fgui.GButton)\n                        ii.selected = ii.obj.selected;\n                    this.removeChildToPool(ii.obj);\n                    ii.obj = null;\n                }\n            }\n        }\n        handleArchOrder1() {\n            if (this.childrenRenderOrder == fgui.ChildrenRenderOrder.Arch) {\n                var mid = this._scrollPane.posY + this.viewHeight / 2;\n                var minDist = Number.POSITIVE_INFINITY;\n                var dist = 0;\n                var apexIndex = 0;\n                var cnt = this.numChildren;\n                for (var i = 0; i < cnt; i++) {\n                    var obj = this.getChildAt(i);\n                    if (!this.foldInvisibleItems || obj.visible) {\n                        dist = Math.abs(mid - obj.y - obj.height / 2);\n                        if (dist < minDist) {\n                            minDist = dist;\n                            apexIndex = i;\n                        }\n                    }\n                }\n                this.apexIndex = apexIndex;\n            }\n        }\n        handleArchOrder2() {\n            if (this.childrenRenderOrder == fgui.ChildrenRenderOrder.Arch) {\n                var mid = this._scrollPane.posX + this.viewWidth / 2;\n                var minDist = Number.POSITIVE_INFINITY;\n                var dist = 0;\n                var apexIndex = 0;\n                var cnt = this.numChildren;\n                for (var i = 0; i < cnt; i++) {\n                    var obj = this.getChildAt(i);\n                    if (!this.foldInvisibleItems || obj.visible) {\n                        dist = Math.abs(mid - obj.x - obj.width / 2);\n                        if (dist < minDist) {\n                            minDist = dist;\n                            apexIndex = i;\n                        }\n                    }\n                }\n                this.apexIndex = apexIndex;\n            }\n        }\n        handleAlign(contentWidth, contentHeight) {\n            var newOffsetX = 0;\n            var newOffsetY = 0;\n            if (contentHeight < this.viewHeight) {\n                if (this._verticalAlign == \"middle\")\n                    newOffsetY = Math.floor((this.viewHeight - contentHeight) / 2);\n                else if (this._verticalAlign == \"bottom\")\n                    newOffsetY = this.viewHeight - contentHeight;\n            }\n            if (contentWidth < this.viewWidth) {\n                if (this._align == \"center\")\n                    newOffsetX = Math.floor((this.viewWidth - contentWidth) / 2);\n                else if (this._align == \"right\")\n                    newOffsetX = this.viewWidth - contentWidth;\n            }\n            if (newOffsetX != this._alignOffset.x || newOffsetY != this._alignOffset.y) {\n                this._alignOffset.set(newOffsetX, newOffsetY);\n                if (this._scrollPane)\n                    this._scrollPane.adjustMaskContainer();\n                else\n                    this._container.setPosition(this._margin.left + this._alignOffset.x, this._margin.top + this._alignOffset.y);\n            }\n        }\n        updateBounds() {\n            if (this._virtual)\n                return;\n            var i;\n            var child;\n            var curX = 0;\n            var curY = 0;\n            var maxWidth = 0;\n            var maxHeight = 0;\n            var cw, ch;\n            var j = 0;\n            var page = 0;\n            var k = 0;\n            var cnt = this._children.length;\n            var viewWidth = this.viewWidth;\n            var viewHeight = this.viewHeight;\n            var lineSize = 0;\n            var lineStart = 0;\n            var ratio;\n            if (this._layout == fgui.ListLayoutType.SingleColumn) {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    if (curY != 0)\n                        curY += this._lineGap;\n                    child.y = curY;\n                    if (this._autoResizeItem)\n                        child.setSize(viewWidth, child.height, true);\n                    curY += Math.ceil(child.height);\n                    if (child.width > maxWidth)\n                        maxWidth = child.width;\n                }\n                ch = curY;\n                if (ch <= viewHeight && this._autoResizeItem && this._scrollPane && this._scrollPane._displayInDemand && this._scrollPane.vtScrollBar) {\n                    viewWidth += this._scrollPane.vtScrollBar.width;\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        child.setSize(viewWidth, child.height, true);\n                        if (child.width > maxWidth)\n                            maxWidth = child.width;\n                    }\n                }\n                cw = Math.ceil(maxWidth);\n            }\n            else if (this._layout == fgui.ListLayoutType.SingleRow) {\n                for (i = 0; i < cnt; i++) {\n                    child = this.getChildAt(i);\n                    if (this.foldInvisibleItems && !child.visible)\n                        continue;\n                    if (curX != 0)\n                        curX += this._columnGap;\n                    child.x = curX;\n                    if (this._autoResizeItem)\n                        child.setSize(child.width, viewHeight, true);\n                    curX += Math.ceil(child.width);\n                    if (child.height > maxHeight)\n                        maxHeight = child.height;\n                }\n                cw = curX;\n                if (cw <= viewWidth && this._autoResizeItem && this._scrollPane && this._scrollPane._displayInDemand && this._scrollPane.hzScrollBar) {\n                    viewHeight += this._scrollPane.hzScrollBar.height;\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        child.setSize(child.width, viewHeight, true);\n                        if (child.height > maxHeight)\n                            maxHeight = child.height;\n                    }\n                }\n                ch = Math.ceil(maxHeight);\n            }\n            else if (this._layout == fgui.ListLayoutType.FlowHorizontal) {\n                if (this._autoResizeItem && this._columnCount > 0) {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        lineSize += child.sourceWidth;\n                        j++;\n                        if (j == this._columnCount || i == cnt - 1) {\n                            ratio = (viewWidth - lineSize - (j - 1) * this._columnGap) / lineSize;\n                            curX = 0;\n                            for (j = lineStart; j <= i; j++) {\n                                child = this.getChildAt(j);\n                                if (this.foldInvisibleItems && !child.visible)\n                                    continue;\n                                child.setPosition(curX, curY);\n                                if (j < i) {\n                                    child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), child.height, true);\n                                    curX += Math.ceil(child.width) + this._columnGap;\n                                }\n                                else {\n                                    child.setSize(viewWidth - curX, child.height, true);\n                                }\n                                if (child.height > maxHeight)\n                                    maxHeight = child.height;\n                            }\n                            curY += Math.ceil(maxHeight) + this._lineGap;\n                            maxHeight = 0;\n                            j = 0;\n                            lineStart = i + 1;\n                            lineSize = 0;\n                        }\n                    }\n                    ch = curY + Math.ceil(maxHeight);\n                    cw = viewWidth;\n                }\n                else {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        if (curX != 0)\n                            curX += this._columnGap;\n                        if (this._columnCount != 0 && j >= this._columnCount\n                            || this._columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0) {\n                            curX = 0;\n                            curY += Math.ceil(maxHeight) + this._lineGap;\n                            maxHeight = 0;\n                            j = 0;\n                        }\n                        child.setPosition(curX, curY);\n                        curX += Math.ceil(child.width);\n                        if (curX > maxWidth)\n                            maxWidth = curX;\n                        if (child.height > maxHeight)\n                            maxHeight = child.height;\n                        j++;\n                    }\n                    ch = curY + Math.ceil(maxHeight);\n                    cw = Math.ceil(maxWidth);\n                }\n            }\n            else if (this._layout == fgui.ListLayoutType.FlowVertical) {\n                if (this._autoResizeItem && this._lineCount > 0) {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        lineSize += child.sourceHeight;\n                        j++;\n                        if (j == this._lineCount || i == cnt - 1) {\n                            ratio = (viewHeight - lineSize - (j - 1) * this._lineGap) / lineSize;\n                            curY = 0;\n                            for (j = lineStart; j <= i; j++) {\n                                child = this.getChildAt(j);\n                                if (this.foldInvisibleItems && !child.visible)\n                                    continue;\n                                child.setPosition(curX, curY);\n                                if (j < i) {\n                                    child.setSize(child.width, child.sourceHeight + Math.round(child.sourceHeight * ratio), true);\n                                    curY += Math.ceil(child.height) + this._lineGap;\n                                }\n                                else {\n                                    child.setSize(child.width, viewHeight - curY, true);\n                                }\n                                if (child.width > maxWidth)\n                                    maxWidth = child.width;\n                            }\n                            curX += Math.ceil(maxWidth) + this._columnGap;\n                            maxWidth = 0;\n                            j = 0;\n                            lineStart = i + 1;\n                            lineSize = 0;\n                        }\n                    }\n                    cw = curX + Math.ceil(maxWidth);\n                    ch = viewHeight;\n                }\n                else {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        if (curY != 0)\n                            curY += this._lineGap;\n                        if (this._lineCount != 0 && j >= this._lineCount\n                            || this._lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0) {\n                            curY = 0;\n                            curX += Math.ceil(maxWidth) + this._columnGap;\n                            maxWidth = 0;\n                            j = 0;\n                        }\n                        child.setPosition(curX, curY);\n                        curY += Math.ceil(child.height);\n                        if (curY > maxHeight)\n                            maxHeight = curY;\n                        if (child.width > maxWidth)\n                            maxWidth = child.width;\n                        j++;\n                    }\n                    cw = curX + Math.ceil(maxWidth);\n                    ch = Math.ceil(maxHeight);\n                }\n            }\n            else {\n                var eachHeight;\n                if (this._autoResizeItem && this._lineCount > 0)\n                    eachHeight = Math.floor((viewHeight - (this._lineCount - 1) * this._lineGap) / this._lineCount);\n                if (this._autoResizeItem && this._columnCount > 0) {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        if (j == 0 && (this._lineCount != 0 && k >= this._lineCount\n                            || this._lineCount == 0 && curY + child.height > viewHeight)) {\n                            page++;\n                            curY = 0;\n                            k = 0;\n                        }\n                        lineSize += child.sourceWidth;\n                        j++;\n                        if (j == this._columnCount || i == cnt - 1) {\n                            ratio = (viewWidth - lineSize - (j - 1) * this._columnGap) / lineSize;\n                            curX = 0;\n                            for (j = lineStart; j <= i; j++) {\n                                child = this.getChildAt(j);\n                                if (this.foldInvisibleItems && !child.visible)\n                                    continue;\n                                child.setPosition(page * viewWidth + curX, curY);\n                                if (j < i) {\n                                    child.setSize(child.sourceWidth + Math.round(child.sourceWidth * ratio), this._lineCount > 0 ? eachHeight : child.height, true);\n                                    curX += Math.ceil(child.width) + this._columnGap;\n                                }\n                                else {\n                                    child.setSize(viewWidth - curX, this._lineCount > 0 ? eachHeight : child.height, true);\n                                }\n                                if (child.height > maxHeight)\n                                    maxHeight = child.height;\n                            }\n                            curY += Math.ceil(maxHeight) + this._lineGap;\n                            maxHeight = 0;\n                            j = 0;\n                            lineStart = i + 1;\n                            lineSize = 0;\n                            k++;\n                        }\n                    }\n                }\n                else {\n                    for (i = 0; i < cnt; i++) {\n                        child = this.getChildAt(i);\n                        if (this.foldInvisibleItems && !child.visible)\n                            continue;\n                        if (curX != 0)\n                            curX += this._columnGap;\n                        if (this._autoResizeItem && this._lineCount > 0)\n                            child.setSize(child.width, eachHeight, true);\n                        if (this._columnCount != 0 && j >= this._columnCount\n                            || this._columnCount == 0 && curX + child.width > viewWidth && maxHeight != 0) {\n                            curX = 0;\n                            curY += Math.ceil(maxHeight) + this._lineGap;\n                            maxHeight = 0;\n                            j = 0;\n                            k++;\n                            if (this._lineCount != 0 && k >= this._lineCount\n                                || this._lineCount == 0 && curY + child.height > viewHeight && maxWidth != 0) {\n                                page++;\n                                curY = 0;\n                                k = 0;\n                            }\n                        }\n                        child.setPosition(page * viewWidth + curX, curY);\n                        curX += Math.ceil(child.width);\n                        if (curX > maxWidth)\n                            maxWidth = curX;\n                        if (child.height > maxHeight)\n                            maxHeight = child.height;\n                        j++;\n                    }\n                }\n                ch = page > 0 ? viewHeight : curY + Math.ceil(maxHeight);\n                cw = (page + 1) * viewWidth;\n            }\n            this.handleAlign(cw, ch);\n            this.setBounds(0, 0, cw, ch);\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            var i1;\n            this._layout = buffer.readByte();\n            this._selectionMode = buffer.readByte();\n            i1 = buffer.readByte();\n            this._align = i1 == 0 ? \"left\" : (i1 == 1 ? \"center\" : \"right\");\n            i1 = buffer.readByte();\n            this._verticalAlign = i1 == 0 ? \"top\" : (i1 == 1 ? \"middle\" : \"bottom\");\n            this._lineGap = buffer.readShort();\n            this._columnGap = buffer.readShort();\n            this._lineCount = buffer.readShort();\n            this._columnCount = buffer.readShort();\n            this._autoResizeItem = buffer.readBool();\n            this._childrenRenderOrder = buffer.readByte();\n            this._apexIndex = buffer.readShort();\n            if (buffer.readBool()) {\n                this._margin.top = buffer.readInt();\n                this._margin.bottom = buffer.readInt();\n                this._margin.left = buffer.readInt();\n                this._margin.right = buffer.readInt();\n            }\n            var overflow = buffer.readByte();\n            if (overflow == fgui.OverflowType.Scroll) {\n                var savedPos = buffer.pos;\n                buffer.seek(beginPos, 7);\n                this.setupScroll(buffer);\n                buffer.pos = savedPos;\n            }\n            else\n                this.setupOverflow(overflow);\n            if (buffer.readBool())\n                buffer.skip(8);\n            if (buffer.version >= 2) {\n                this.scrollItemToViewOnClick = buffer.readBool();\n                this.foldInvisibleItems = buffer.readBool();\n            }\n            buffer.seek(beginPos, 8);\n            this._defaultItem = buffer.readS();\n            this.readItems(buffer);\n        }\n        readItems(buffer) {\n            var cnt;\n            var i;\n            var nextPos;\n            var str;\n            cnt = buffer.readShort();\n            for (i = 0; i < cnt; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                str = buffer.readS();\n                if (str == null) {\n                    str = this.defaultItem;\n                    if (!str) {\n                        buffer.pos = nextPos;\n                        continue;\n                    }\n                }\n                var obj = this.getFromPool(str);\n                if (obj) {\n                    this.addChild(obj);\n                    this.setupItem(buffer, obj);\n                }\n                buffer.pos = nextPos;\n            }\n        }\n        setupItem(buffer, obj) {\n            var str;\n            str = buffer.readS();\n            if (str != null)\n                obj.text = str;\n            str = buffer.readS();\n            if (str != null && (obj instanceof fgui.GButton))\n                obj.selectedTitle = str;\n            str = buffer.readS();\n            if (str != null)\n                obj.icon = str;\n            str = buffer.readS();\n            if (str != null && (obj instanceof fgui.GButton))\n                obj.selectedIcon = str;\n            str = buffer.readS();\n            if (str != null)\n                obj.name = str;\n            var cnt;\n            var i;\n            if (obj instanceof fgui.GComponent) {\n                cnt = buffer.readShort();\n                for (i = 0; i < cnt; i++) {\n                    var cc = obj.getController(buffer.readS());\n                    str = buffer.readS();\n                    if (cc)\n                        cc.selectedPageId = str;\n                }\n                if (buffer.version >= 2) {\n                    cnt = buffer.readShort();\n                    for (i = 0; i < cnt; i++) {\n                        var target = buffer.readS();\n                        var propertyId = buffer.readShort();\n                        var value = buffer.readS();\n                        var obj2 = obj.getChildByPath(target);\n                        if (obj2)\n                            obj2.setProp(propertyId, value);\n                    }\n                }\n            }\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            buffer.seek(beginPos, 6);\n            var i = buffer.readShort();\n            if (i != -1)\n                this._selectionController = this._parent.getControllerAt(i);\n        }\n    }\n    fgui.GList = GList;\n    var s_n = 0;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GLoader extends fgui.GObject {\n        constructor() {\n            super();\n            this._contentSourceWidth = 0;\n            this._contentSourceHeight = 0;\n            this._contentWidth = 0;\n            this._contentHeight = 0;\n            this._url = \"\";\n            this._fill = fgui.LoaderFillType.None;\n            this._align = \"left\";\n            this._valign = \"top\";\n        }\n        createDisplayObject() {\n            this._displayObject = new fgui.DisplayObject();\n            this._content = new fgui.MovieClip();\n            this._displayObject.addChild(this._content);\n        }\n        dispose() {\n            if (this._contentItem && this._content.texture) {\n                this.freeExternal(this._content.texture);\n            }\n            if (this._content2)\n                this._content2.dispose();\n            super.dispose();\n        }\n        get url() {\n            return this._url;\n        }\n        set url(value) {\n            if (this._url == value)\n                return;\n            this._url = value;\n            this.loadContent();\n            this.updateGear(7);\n        }\n        get icon() {\n            return this._url;\n        }\n        set icon(value) {\n            this.url = value;\n        }\n        get align() {\n            return this._align;\n        }\n        set align(value) {\n            if (this._align != value) {\n                this._align = value;\n                this.updateLayout();\n            }\n        }\n        get verticalAlign() {\n            return this._valign;\n        }\n        set verticalAlign(value) {\n            if (this._valign != value) {\n                this._valign = value;\n                this.updateLayout();\n            }\n        }\n        get fill() {\n            return this._fill;\n        }\n        set fill(value) {\n            if (this._fill != value) {\n                this._fill = value;\n                this.updateLayout();\n            }\n        }\n        get shrinkOnly() {\n            return this._shrinkOnly;\n        }\n        set shrinkOnly(value) {\n            if (this._shrinkOnly != value) {\n                this._shrinkOnly = value;\n                this.updateLayout();\n            }\n        }\n        get autoSize() {\n            return this._autoSize;\n        }\n        set autoSize(value) {\n            if (this._autoSize != value) {\n                this._autoSize = value;\n                this.updateLayout();\n            }\n        }\n        get playing() {\n            return this._content.playing;\n        }\n        set playing(value) {\n            if (this._content.playing != value) {\n                this._content.playing = value;\n                this.updateGear(5);\n            }\n        }\n        get frame() {\n            return this._content.frame;\n        }\n        set frame(value) {\n            if (this._content.frame != value) {\n                this._content.frame = value;\n                this.updateGear(5);\n            }\n        }\n        get color() {\n            return this._content.graphics.color;\n        }\n        set color(value) {\n            if (this._content.graphics.color != value) {\n                this._content.graphics.color = value;\n                this.updateGear(4);\n            }\n        }\n        get content() {\n            return this._content;\n        }\n        get component() {\n            return this._content2;\n        }\n        loadContent() {\n            this.clearContent();\n            if (!this._url)\n                return;\n            if (this._url.startsWith(\"ui://\"))\n                this.loadFromPackage(this._url);\n            else\n                this.loadExternal();\n        }\n        loadFromPackage(itemURL) {\n            this._contentItem = fgui.UIPackage.getItemByURL(itemURL);\n            if (this._contentItem) {\n                this._contentItem = this._contentItem.getBranch();\n                this._contentSourceWidth = this._contentItem.width;\n                this._contentSourceHeight = this._contentItem.height;\n                this._contentItem = this._contentItem.getHighResolution();\n                this._contentItem.load();\n                if (this._autoSize)\n                    this.setSize(this._contentSourceWidth, this._contentSourceHeight);\n                if (this._contentItem.type == fgui.PackageItemType.Image) {\n                    if (this._contentItem.texture == null) {\n                        this.setErrorState();\n                    }\n                    else {\n                        this._content.texture = this._contentItem.texture;\n                        this._content.scale9Grid = this._contentItem.scale9Grid;\n                        this._content.scaleByTile = this._contentItem.scaleByTile;\n                        this._content.tileGridIndice = this._contentItem.tileGridIndice;\n                        this._contentSourceWidth = this._contentItem.width;\n                        this._contentSourceHeight = this._contentItem.height;\n                        this.updateLayout();\n                    }\n                }\n                else if (this._contentItem.type == fgui.PackageItemType.MovieClip) {\n                    this._contentSourceWidth = this._contentItem.width;\n                    this._contentSourceHeight = this._contentItem.height;\n                    this._content.interval = this._contentItem.interval;\n                    this._content.swing = this._contentItem.swing;\n                    this._content.repeatDelay = this._contentItem.repeatDelay;\n                    this._content.frames = this._contentItem.frames;\n                    this.updateLayout();\n                }\n                else if (this._contentItem.type == fgui.PackageItemType.Component) {\n                    var obj = fgui.UIPackage.createObjectFromURL(itemURL);\n                    if (!obj)\n                        this.setErrorState();\n                    else if (!(obj instanceof fgui.GComponent)) {\n                        obj.dispose();\n                        this.setErrorState();\n                    }\n                    else {\n                        this._content2 = obj;\n                        this._displayObject.addChild(this._content2.displayObject);\n                        this.updateLayout();\n                    }\n                }\n                else\n                    this.setErrorState();\n            }\n            else\n                this.setErrorState();\n        }\n        loadExternal() {\n            let url = this._url;\n            new THREE.TextureLoader().load(this._url, tex => {\n                if (url == this._url)\n                    this.onExternalLoadSuccess(new fgui.NTexture(tex));\n            });\n        }\n        freeExternal(texture) {\n        }\n        onExternalLoadSuccess(texture) {\n            this._content.texture = texture;\n            this._content.scale9Grid = null;\n            this._content.scaleByTile = false;\n            this._contentSourceWidth = texture.width;\n            this._contentSourceHeight = texture.height;\n            this.updateLayout();\n        }\n        onExternalLoadFailed() {\n            this.setErrorState();\n        }\n        setErrorState() {\n        }\n        clearErrorState() {\n        }\n        updateLayout() {\n            if (!this._content2 && !this._content.texture && !this._content.frames) {\n                if (this._autoSize) {\n                    this._updatingLayout = true;\n                    this.setSize(50, 30);\n                    this._updatingLayout = false;\n                }\n                return;\n            }\n            this._contentWidth = this._contentSourceWidth;\n            this._contentHeight = this._contentSourceHeight;\n            if (this._autoSize) {\n                this._updatingLayout = true;\n                if (this._contentWidth == 0)\n                    this._contentWidth = 50;\n                if (this._contentHeight == 0)\n                    this._contentHeight = 30;\n                this.setSize(this._contentWidth, this._contentHeight);\n                this._updatingLayout = false;\n                if (this._contentWidth == this._width && this._contentHeight == this._height) {\n                    if (this._content2) {\n                        this._content2.setPosition(0, 0);\n                        this._content2.setScale(1, 1);\n                    }\n                    else {\n                        this._content.setSize(this._contentWidth, this._contentHeight);\n                        this._content.setPosition(0, 0);\n                    }\n                    return;\n                }\n            }\n            var sx = 1, sy = 1;\n            if (this._fill != fgui.LoaderFillType.None) {\n                sx = this.width / this._contentSourceWidth;\n                sy = this.height / this._contentSourceHeight;\n                if (sx != 1 || sy != 1) {\n                    if (this._fill == fgui.LoaderFillType.ScaleMatchHeight)\n                        sx = sy;\n                    else if (this._fill == fgui.LoaderFillType.ScaleMatchWidth)\n                        sy = sx;\n                    else if (this._fill == fgui.LoaderFillType.Scale) {\n                        if (sx > sy)\n                            sx = sy;\n                        else\n                            sy = sx;\n                    }\n                    else if (this._fill == fgui.LoaderFillType.ScaleNoBorder) {\n                        if (sx > sy)\n                            sy = sx;\n                        else\n                            sx = sy;\n                    }\n                    if (this._shrinkOnly) {\n                        if (sx > 1)\n                            sx = 1;\n                        if (sy > 1)\n                            sy = 1;\n                    }\n                    this._contentWidth = this._contentSourceWidth * sx;\n                    this._contentHeight = this._contentSourceHeight * sy;\n                }\n            }\n            if (this._content2)\n                this._content2.setScale(sx, sy);\n            else\n                this._content.setSize(this._contentWidth, this._contentHeight);\n            var nx, ny;\n            if (this._align == \"center\")\n                nx = Math.floor((this.width - this._contentWidth) / 2);\n            else if (this._align == \"right\")\n                nx = this.width - this._contentWidth;\n            else\n                nx = 0;\n            if (this._valign == \"middle\")\n                ny = Math.floor((this.height - this._contentHeight) / 2);\n            else if (this._valign == \"bottom\")\n                ny = this.height - this._contentHeight;\n            else\n                ny = 0;\n            if (this._content2)\n                this._content2.setPosition(nx, ny);\n            else\n                this._content.setPosition(nx, ny);\n        }\n        clearContent() {\n            this.clearErrorState();\n            if (this._contentItem == null && this._content.texture) {\n                this.freeExternal(this._content.texture);\n            }\n            this._content.texture = null;\n            this._content.frames = null;\n            if (this._content2) {\n                this._content2.dispose();\n                this._content2 = null;\n            }\n            this._contentItem = null;\n        }\n        handleSizeChanged() {\n            super.handleSizeChanged();\n            if (!this._updatingLayout)\n                this.updateLayout();\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.color;\n                case fgui.ObjectPropID.Playing:\n                    return this.playing;\n                case fgui.ObjectPropID.Frame:\n                    return this.frame;\n                case fgui.ObjectPropID.TimeScale:\n                    return this._content.timeScale;\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.color = value;\n                    break;\n                case fgui.ObjectPropID.Playing:\n                    this.playing = value;\n                    break;\n                case fgui.ObjectPropID.Frame:\n                    this.frame = value;\n                    break;\n                case fgui.ObjectPropID.TimeScale:\n                    this._content.timeScale = value;\n                    break;\n                case fgui.ObjectPropID.DeltaTime:\n                    this._content.advance(value);\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            var iv;\n            this._url = buffer.readS();\n            iv = buffer.readByte();\n            this._align = iv == 0 ? \"left\" : (iv == 1 ? \"center\" : \"right\");\n            iv = buffer.readByte();\n            this._valign = iv == 0 ? \"top\" : (iv == 1 ? \"middle\" : \"bottom\");\n            this._fill = buffer.readByte();\n            this._shrinkOnly = buffer.readBool();\n            this._autoSize = buffer.readBool();\n            buffer.readBool();\n            this._content.playing = buffer.readBool();\n            this._content.frame = buffer.readInt();\n            if (buffer.readBool())\n                this.color = buffer.readColor();\n            this._content.fillMethod = buffer.readByte();\n            if (this._content.fillMethod != 0) {\n                this._content.fillOrigin = buffer.readByte();\n                this._content.fillClockwise = buffer.readBool();\n                this._content.fillAmount = buffer.readFloat();\n            }\n            if (this._url)\n                this.loadContent();\n        }\n    }\n    fgui.GLoader = GLoader;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GLoader3D extends fgui.GObject {\n    }\n    fgui.GLoader3D = GLoader3D;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GMovieClip extends fgui.GObject {\n        constructor() {\n            super();\n        }\n        get color() {\n            return this._movieClip.graphics.color;\n        }\n        set color(value) {\n            this._movieClip.graphics.color = value;\n        }\n        createDisplayObject() {\n            this._displayObject = this._movieClip = new fgui.MovieClip();\n        }\n        get playing() {\n            return this._movieClip.playing;\n        }\n        set playing(value) {\n            if (this._movieClip.playing != value) {\n                this._movieClip.playing = value;\n                this.updateGear(5);\n            }\n        }\n        get frame() {\n            return this._movieClip.frame;\n        }\n        set frame(value) {\n            if (this._movieClip.frame != value) {\n                this._movieClip.frame = value;\n                this.updateGear(5);\n            }\n        }\n        get timeScale() {\n            return this._movieClip.timeScale;\n        }\n        set timeScale(value) {\n            this._movieClip.timeScale = value;\n        }\n        rewind() {\n            this._movieClip.rewind();\n        }\n        syncStatus(anotherMc) {\n            this._movieClip.syncStatus(anotherMc._movieClip);\n        }\n        advance(timeInMiniseconds) {\n            this._movieClip.advance(timeInMiniseconds);\n        }\n        setPlaySettings(start, end, times, endAt) {\n            this._movieClip.setPlaySettings(start, end, times, endAt);\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.color;\n                case fgui.ObjectPropID.Playing:\n                    return this.playing;\n                case fgui.ObjectPropID.Frame:\n                    return this.frame;\n                case fgui.ObjectPropID.TimeScale:\n                    return this.timeScale;\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.color = value;\n                    break;\n                case fgui.ObjectPropID.Playing:\n                    this.playing = value;\n                    break;\n                case fgui.ObjectPropID.Frame:\n                    this.frame = value;\n                    break;\n                case fgui.ObjectPropID.TimeScale:\n                    this.timeScale = value;\n                    break;\n                case fgui.ObjectPropID.DeltaTime:\n                    this.advance(value);\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        constructFromResource() {\n            var displayItem = this.packageItem.getBranch();\n            this.sourceWidth = displayItem.width;\n            this.sourceHeight = displayItem.height;\n            this.initWidth = this.sourceWidth;\n            this.initHeight = this.sourceHeight;\n            this.setSize(this.sourceWidth, this.sourceHeight);\n            displayItem = displayItem.getHighResolution();\n            displayItem.load();\n            this._movieClip.interval = displayItem.interval;\n            this._movieClip.swing = displayItem.swing;\n            this._movieClip.repeatDelay = displayItem.repeatDelay;\n            this._movieClip.frames = displayItem.frames;\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            if (buffer.readBool())\n                this.color = buffer.readColor();\n            this._movieClip.graphics.flip = buffer.readByte();\n            this._movieClip.frame = buffer.readInt();\n            this._movieClip.playing = buffer.readBool();\n        }\n    }\n    fgui.GMovieClip = GMovieClip;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GObjectPool {\n        constructor() {\n            this._count = 0;\n            this._pool = {};\n        }\n        clear() {\n            for (var i1 in this._pool) {\n                var arr = this._pool[i1];\n                arr.forEach(obj => obj.dispose());\n            }\n            this._pool = {};\n            this._count = 0;\n        }\n        get count() {\n            return this._count;\n        }\n        getObject(url) {\n            url = fgui.UIPackage.normalizeURL(url);\n            if (url == null)\n                return null;\n            var arr = this._pool[url];\n            if (arr && arr.length > 0) {\n                this._count--;\n                return arr.shift();\n            }\n            return fgui.UIPackage.createObjectFromURL(url);\n        }\n        returnObject(obj) {\n            var url = obj.resourceURL;\n            if (!url)\n                return;\n            var arr = this._pool[url];\n            if (!arr) {\n                arr = [];\n                this._pool[url] = arr;\n            }\n            this._count++;\n            arr.push(obj);\n        }\n    }\n    fgui.GObjectPool = GObjectPool;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GProgressBar extends fgui.GComponent {\n        constructor() {\n            super();\n            this._min = 0;\n            this._max = 0;\n            this._value = 0;\n            this._barMaxWidth = 0;\n            this._barMaxHeight = 0;\n            this._barMaxWidthDelta = 0;\n            this._barMaxHeightDelta = 0;\n            this._barStartX = 0;\n            this._barStartY = 0;\n            this._titleType = fgui.ProgressTitleType.Percent;\n            this._value = 50;\n            this._max = 100;\n        }\n        get titleType() {\n            return this._titleType;\n        }\n        set titleType(value) {\n            if (this._titleType != value) {\n                this._titleType = value;\n                this.update(value);\n            }\n        }\n        get min() {\n            return this._min;\n        }\n        set min(value) {\n            if (this._min != value) {\n                this._min = value;\n                this.update(this._value);\n            }\n        }\n        get max() {\n            return this._max;\n        }\n        set max(value) {\n            if (this._max != value) {\n                this._max = value;\n                this.update(this._value);\n            }\n        }\n        get value() {\n            return this._value;\n        }\n        set value(value) {\n            if (this._value != value) {\n                fgui.GTween.kill(this, false, this.update);\n                this._value = value;\n                this.update(value);\n            }\n        }\n        tweenValue(value, duration) {\n            var oldValule;\n            var tweener = fgui.GTween.getTween(this, this.update);\n            if (tweener) {\n                oldValule = tweener.value.x;\n                tweener.kill();\n            }\n            else\n                oldValule = this._value;\n            this._value = value;\n            return fgui.GTween.to(oldValule, this._value, duration).setTarget(this, this.update).setEase(fgui.EaseType.Linear);\n        }\n        update(newValue) {\n            var percent = fgui.clamp01((newValue - this._min) / (this._max - this._min));\n            if (this._titleObject) {\n                switch (this._titleType) {\n                    case fgui.ProgressTitleType.Percent:\n                        this._titleObject.text = Math.floor(percent * 100) + \"%\";\n                        break;\n                    case fgui.ProgressTitleType.ValueAndMax:\n                        this._titleObject.text = Math.floor(newValue) + \"/\" + Math.floor(this._max);\n                        break;\n                    case fgui.ProgressTitleType.Value:\n                        this._titleObject.text = \"\" + Math.floor(newValue);\n                        break;\n                    case fgui.ProgressTitleType.Max:\n                        this._titleObject.text = \"\" + Math.floor(this._max);\n                        break;\n                }\n            }\n            var fullWidth = this.width - this._barMaxWidthDelta;\n            var fullHeight = this.height - this._barMaxHeightDelta;\n            if (!this._reverse) {\n                if (this._barObjectH) {\n                    if ((this._barObjectH instanceof fgui.GImage) && this._barObjectH.fillMethod != fgui.FillMethod.None)\n                        this._barObjectH.fillAmount = percent;\n                    else\n                        this._barObjectH.width = Math.floor(fullWidth * percent);\n                }\n                if (this._barObjectV) {\n                    if ((this._barObjectV instanceof fgui.GImage) && this._barObjectV.fillMethod != fgui.FillMethod.None)\n                        this._barObjectV.fillAmount = percent;\n                    else\n                        this._barObjectV.height = Math.floor(fullHeight * percent);\n                }\n            }\n            else {\n                if (this._barObjectH) {\n                    if ((this._barObjectH instanceof fgui.GImage) && this._barObjectH.fillMethod != fgui.FillMethod.None)\n                        this._barObjectH.fillAmount = 1 - percent;\n                    else {\n                        this._barObjectH.width = Math.floor(fullWidth * percent);\n                        this._barObjectH.x = this._barStartX + (fullWidth - this._barObjectH.width);\n                    }\n                }\n                if (this._barObjectV) {\n                    if ((this._barObjectV instanceof fgui.GImage) && this._barObjectV.fillMethod != fgui.FillMethod.None)\n                        this._barObjectV.fillAmount = 1 - percent;\n                    else {\n                        this._barObjectV.height = Math.floor(fullHeight * percent);\n                        this._barObjectV.y = this._barStartY + (fullHeight - this._barObjectV.height);\n                    }\n                }\n            }\n            if (this._aniObject)\n                this._aniObject.setProp(fgui.ObjectPropID.Frame, Math.floor(percent * 100));\n        }\n        constructExtension(buffer) {\n            buffer.seek(0, 6);\n            this._titleType = buffer.readByte();\n            this._reverse = buffer.readBool();\n            this._titleObject = this.getChild(\"title\");\n            this._barObjectH = this.getChild(\"bar\");\n            this._barObjectV = this.getChild(\"bar_v\");\n            this._aniObject = this.getChild(\"ani\");\n            if (this._barObjectH) {\n                this._barMaxWidth = this._barObjectH.width;\n                this._barMaxWidthDelta = this.width - this._barMaxWidth;\n                this._barStartX = this._barObjectH.x;\n            }\n            if (this._barObjectV) {\n                this._barMaxHeight = this._barObjectV.height;\n                this._barMaxHeightDelta = this.height - this._barMaxHeight;\n                this._barStartY = this._barObjectV.y;\n            }\n        }\n        handleSizeChanged() {\n            super.handleSizeChanged();\n            if (this._barObjectH)\n                this._barMaxWidth = this.width - this._barMaxWidthDelta;\n            if (this._barObjectV)\n                this._barMaxHeight = this.height - this._barMaxHeightDelta;\n            if (!this._underConstruct)\n                this.update(this._value);\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!buffer.seek(beginPos, 6)) {\n                this.update(this._value);\n                return;\n            }\n            if (buffer.readByte() != this.packageItem.objectType) {\n                this.update(this._value);\n                return;\n            }\n            this._value = buffer.readInt();\n            this._max = buffer.readInt();\n            if (buffer.version >= 2)\n                this._min = buffer.readInt();\n            this.update(this._value);\n        }\n    }\n    fgui.GProgressBar = GProgressBar;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GTextField extends fgui.GObject {\n        constructor() {\n            super();\n            let tf = this._textField.textFormat;\n            tf.font = fgui.UIConfig.defaultFont;\n            tf.size = 12;\n            tf.lineSpacing = 3;\n            this._textField.applyFormat();\n            this._text = \"\";\n            this._textField.autoSize = fgui.AutoSizeType.Both;\n            this._textField.wordWrap = false;\n        }\n        createDisplayObject() {\n            this._displayObject = this._textField = new fgui.TextField();\n        }\n        get text() {\n            if (this._displayObject instanceof fgui.InputTextField)\n                this._text = this._textField.text;\n            return this._text;\n        }\n        set text(value) {\n            if (value == null)\n                value = \"\";\n            this._text = value;\n            this.setText();\n            this.updateSize();\n            this.updateGear(6);\n        }\n        setText() {\n            let str = this._text;\n            if (this._template)\n                str = this.parseTemplate(str);\n            this._textField.maxWidth = this.maxWidth;\n            if (this._ubbEnabled)\n                this._textField.htmlText = fgui.defaultParser.parse(fgui.XMLUtils.encodeString(str));\n            else\n                this._textField.text = str;\n        }\n        get textTemplate() {\n            return this._template;\n        }\n        set textTemplate(value) {\n            if (!this._template && !value)\n                return;\n            this._template = value;\n            this.flushVars();\n        }\n        setVar(name, value) {\n            if (!this._template)\n                this._template = {};\n            this._template[name] = value;\n            return this;\n        }\n        flushVars() {\n            this.setText();\n            this.updateSize();\n        }\n        get textFormat() {\n            return this._textField.textFormat;\n        }\n        applyFormat() {\n            this._textField.applyFormat();\n            if (!this._underConstruct)\n                this.updateSize();\n        }\n        get align() {\n            return this._textField.align;\n        }\n        set align(value) {\n            this._textField.align = value;\n        }\n        get verticalAlign() {\n            return this._textField.verticalAlign;\n        }\n        set verticalAlign(value) {\n            this._textField.verticalAlign = value;\n        }\n        get singleLine() {\n            return this._textField.singleLine;\n        }\n        set singleLine(value) {\n            this._textField.singleLine = value;\n        }\n        set ubbEnabled(value) {\n            this._ubbEnabled = value;\n        }\n        get ubbEnabled() {\n            return this._ubbEnabled;\n        }\n        get autoSize() {\n            return this._textField.autoSize;\n        }\n        set autoSize(value) {\n            this._textField.autoSize = value;\n            if (value == fgui.AutoSizeType.Both) {\n                this._textField.wordWrap = false;\n                if (!this._underConstruct)\n                    this.setSize(this._textField.textWidth, this._textField.textHeight);\n            }\n            else {\n                this._textField.wordWrap = true;\n                if (value == fgui.AutoSizeType.Height) {\n                    if (!this._underConstruct) {\n                        this._textField.width = this.width;\n                        this.height = this._textField.textHeight;\n                    }\n                }\n                else\n                    this._textField.setSize(this.width, this.height);\n            }\n        }\n        get textWidth() {\n            return this._textField.textWidth;\n        }\n        get textHeight() {\n            return this._textField.textHeight;\n        }\n        get color() {\n            return this._textField.textFormat.color;\n        }\n        set color(value) {\n            if (this._textField.textFormat.color != value) {\n                this._textField.textFormat.color = value;\n                this._textField.applyFormat();\n                this.updateGear(4);\n            }\n        }\n        getProp(index) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    return this.color;\n                case fgui.ObjectPropID.OutlineColor:\n                    return this._textField.textFormat.outlineColor;\n                case fgui.ObjectPropID.FontSize:\n                    return this._textField.textFormat.size;\n                default:\n                    return super.getProp(index);\n            }\n        }\n        setProp(index, value) {\n            switch (index) {\n                case fgui.ObjectPropID.Color:\n                    this.color = value;\n                    break;\n                case fgui.ObjectPropID.OutlineColor:\n                    this._textField.textFormat.outlineColor = value;\n                    this._textField.applyFormat();\n                    break;\n                case fgui.ObjectPropID.FontSize:\n                    this._textField.textFormat.size = value;\n                    this._textField.applyFormat();\n                    break;\n                default:\n                    super.setProp(index, value);\n                    break;\n            }\n        }\n        updateSize() {\n            if (this._updatingSize)\n                return;\n            this._updatingSize = true;\n            if (this._textField.autoSize == fgui.AutoSizeType.Both) {\n                this.setSize(this._textField.width, this._textField.height);\n            }\n            else if (this._textField.autoSize == fgui.AutoSizeType.Height) {\n                this.height = this._textField.height;\n            }\n            this._updatingSize = false;\n        }\n        handleSizeChanged() {\n            if (this._updatingSize)\n                return;\n            if (this._underConstruct)\n                this._textField.setSize(this.width, this.height);\n            else if (this._textField.autoSize != fgui.AutoSizeType.Both) {\n                if (this._textField.autoSize == fgui.AutoSizeType.Height) {\n                    this._textField.width = this.width;\n                    if (this._text != \"\")\n                        this.setSizeDirectly(this.width, this._textField.height);\n                }\n                else\n                    this._textField.setSize(this.width, this.height);\n            }\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 5);\n            let tf = this._textField.textFormat;\n            tf.font = buffer.readS();\n            tf.size = buffer.readShort();\n            tf.color = buffer.readColor();\n            let c = buffer.readByte();\n            this.align = c == 0 ? \"left\" : (c == 1 ? \"center\" : \"right\");\n            c = buffer.readByte();\n            this.verticalAlign = c == 0 ? \"top\" : (c == 1 ? \"middle\" : \"bottom\");\n            tf.lineSpacing = buffer.readShort();\n            tf.letterSpacing = buffer.readShort();\n            this.ubbEnabled = buffer.readBool();\n            this.autoSize = buffer.readByte();\n            tf.underline = buffer.readBool();\n            tf.italic = buffer.readBool();\n            tf.bold = buffer.readBool();\n            this.singleLine = buffer.readBool();\n            if (buffer.readBool()) {\n                tf.outlineColor = buffer.readColor();\n                tf.outline = buffer.readFloat() + 1;\n            }\n            if (buffer.readBool()) {\n                tf.shadowColor = buffer.readColor();\n                let f1 = buffer.readFloat();\n                let f2 = buffer.readFloat();\n                tf.shadowOffset.set(f1, f2);\n            }\n            if (buffer.readBool())\n                this._template = {};\n            if (buffer.version >= 3)\n                tf.strikethrough = buffer.readBool();\n            this._textField.applyFormat();\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            buffer.seek(beginPos, 6);\n            var str = buffer.readS();\n            if (str != null)\n                this.text = str;\n        }\n        parseTemplate(template) {\n            var pos1 = 0, pos2, pos3;\n            var tag;\n            var value;\n            var result = \"\";\n            while ((pos2 = template.indexOf(\"{\", pos1)) != -1) {\n                if (pos2 > 0 && template.charCodeAt(pos2 - 1) == 92) {\n                    result += template.substring(pos1, pos2 - 1);\n                    result += \"{\";\n                    pos1 = pos2 + 1;\n                    continue;\n                }\n                result += template.substring(pos1, pos2);\n                pos1 = pos2;\n                pos2 = template.indexOf(\"}\", pos1);\n                if (pos2 == -1)\n                    break;\n                if (pos2 == pos1 + 1) {\n                    result += template.substr(pos1, 2);\n                    pos1 = pos2 + 1;\n                    continue;\n                }\n                tag = template.substring(pos1 + 1, pos2);\n                pos3 = tag.indexOf(\"=\");\n                if (pos3 != -1) {\n                    value = this._template[tag.substring(0, pos3)];\n                    if (value == null)\n                        result += tag.substring(pos3 + 1);\n                    else\n                        result += value;\n                }\n                else {\n                    value = this._template[tag];\n                    if (value != null)\n                        result += value;\n                }\n                pos1 = pos2 + 1;\n            }\n            if (pos1 < template.length)\n                result += template.substr(pos1);\n            return result;\n        }\n    }\n    fgui.GTextField = GTextField;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GRichTextField extends fgui.GTextField {\n        constructor() {\n            super();\n        }\n        createDisplayObject() {\n            this._displayObject = this._textField = new fgui.RichTextField();\n        }\n        setText() {\n            let str = this._text;\n            if (this._template)\n                str = this.parseTemplate(str);\n            this._textField.maxWidth = this.maxWidth;\n            if (this._ubbEnabled)\n                this._textField.htmlText = fgui.defaultParser.parse(str);\n            else\n                this._textField.htmlText = str;\n        }\n    }\n    fgui.GRichTextField = GRichTextField;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var _inst;\n    class GRoot extends fgui.GComponent {\n        constructor() {\n            super();\n            if (!_inst)\n                _inst = this;\n            this.opaque = false;\n            this._popupStack = [];\n            this._justClosedPopups = [];\n            this.on(fgui.InteractiveEvents.Down, this.__stageTouchBegin, this, true);\n            this._modalLayer = new fgui.GGraph();\n            this._modalLayer.setSize(this.width, this.height);\n            this._modalLayer.shape.drawRect(0, new fgui.Color4(0, 0), fgui.UIConfig.modalLayerColor);\n            this._modalLayer.addRelation(this, fgui.RelationType.Size);\n            this.applyScaleFactor();\n            this.on(fgui.StageEvent.ContentScaleChanged, this.applyScaleFactor, this);\n        }\n        static get inst() {\n            if (!_inst) {\n                _inst = new GRoot();\n                fgui.Stage.scene.add(_inst.displayObject.obj3D);\n            }\n            return _inst;\n        }\n        static findFor(obj) {\n            if (obj instanceof GRoot)\n                return obj;\n            if (!obj)\n                return _inst;\n            var p = obj._parent;\n            while (p) {\n                if (p instanceof GRoot)\n                    return p;\n                p = p.parent;\n            }\n            return _inst;\n        }\n        applyScaleFactor() {\n            this.setSize(Math.ceil(fgui.Stage.width / fgui.UIContentScaler.scaleFactor), Math.ceil(fgui.Stage.height / fgui.UIContentScaler.scaleFactor));\n            this.setScale(fgui.UIContentScaler.scaleFactor, fgui.UIContentScaler.scaleFactor);\n        }\n        showWindow(win) {\n            this.addChild(win);\n            if (win.x > this.width)\n                win.x = this.width - win.width;\n            else if (win.x + win.width < 0)\n                win.x = 0;\n            if (win.y > this.height)\n                win.y = this.height - win.height;\n            else if (win.y + win.height < 0)\n                win.y = 0;\n            this.adjustModalLayer();\n        }\n        hideWindow(win) {\n            win.hide();\n        }\n        hideWindowImmediately(win) {\n            if (win.parent == this)\n                this.removeChild(win);\n            this.adjustModalLayer();\n        }\n        bringToFront(win) {\n            var cnt = this.numChildren;\n            var i;\n            if (this._modalLayer.parent && !win.modal)\n                i = this.getChildIndex(this._modalLayer) - 1;\n            else\n                i = cnt - 1;\n            for (; i >= 0; i--) {\n                var g = this.getChildAt(i);\n                if (g == win)\n                    return;\n                if (g instanceof fgui.Window)\n                    break;\n            }\n            if (i >= 0)\n                this.setChildIndex(win, i);\n        }\n        showModalWait(msg) {\n            if (fgui.UIConfig.globalModalWaiting) {\n                if (this._modalWaitPane == null)\n                    this._modalWaitPane = fgui.UIPackage.createObjectFromURL(fgui.UIConfig.globalModalWaiting);\n                this._modalWaitPane.setSize(this.width, this.height);\n                this._modalWaitPane.addRelation(this, fgui.RelationType.Size);\n                this.addChild(this._modalWaitPane);\n                this._modalWaitPane.text = msg || \"\";\n            }\n        }\n        closeModalWait() {\n            if (this._modalWaitPane && this._modalWaitPane.parent)\n                this.removeChild(this._modalWaitPane);\n        }\n        closeAllExceptModals() {\n            var arr = this._children.slice();\n            var cnt = arr.length;\n            for (var i = 0; i < cnt; i++) {\n                var g = arr[i];\n                if ((g instanceof fgui.Window) && !g.modal)\n                    g.hide();\n            }\n        }\n        closeAllWindows() {\n            var arr = this._children.slice();\n            var cnt = arr.length;\n            for (var i = 0; i < cnt; i++) {\n                var g = arr[i];\n                if (g instanceof fgui.Window)\n                    g.hide();\n            }\n        }\n        getTopWindow() {\n            var cnt = this.numChildren;\n            for (var i = cnt - 1; i >= 0; i--) {\n                var g = this.getChildAt(i);\n                if (g instanceof fgui.Window) {\n                    return g;\n                }\n            }\n            return null;\n        }\n        get modalLayer() {\n            return this._modalLayer;\n        }\n        get hasModalWindow() {\n            return this._modalLayer.parent != null;\n        }\n        get modalWaiting() {\n            return this._modalWaitPane && this._modalWaitPane.onStage;\n        }\n        showPopup(popup, target, dir) {\n            if (this._popupStack.length > 0) {\n                var k = this._popupStack.indexOf(popup);\n                if (k != -1) {\n                    for (var i = this._popupStack.length - 1; i >= k; i--)\n                        this.removeChild(this._popupStack.pop());\n                }\n            }\n            this._popupStack.push(popup);\n            if (target) {\n                var p = target;\n                while (p) {\n                    if (p.parent == this) {\n                        if (popup.sortingOrder < p.sortingOrder) {\n                            popup.sortingOrder = p.sortingOrder;\n                        }\n                        break;\n                    }\n                    p = p.parent;\n                }\n            }\n            this.addChild(popup);\n            this.adjustModalLayer();\n            var pos;\n            var sizeW = 0, sizeH = 0;\n            if (target) {\n                pos = target.localToRoot(0, 0);\n                let size = target.localToRoot(target.width, target.height);\n                sizeW = size.x - pos.x;\n                sizeH = size.y - pos.y;\n            }\n            else {\n                pos = fgui.Stage.getTouchPos();\n                pos = this.globalToLocal(pos.x, pos.y);\n            }\n            var xx, yy;\n            xx = pos.x;\n            if (xx + popup.width > this.width)\n                xx = xx + sizeW - popup.width;\n            yy = pos.y + sizeH;\n            if (((dir == null || dir == fgui.PopupDirection.Auto) && yy + popup.height > this.height)\n                || dir == fgui.PopupDirection.Up) {\n                yy = pos.y - popup.height - 1;\n                if (yy < 0) {\n                    yy = 0;\n                    xx += sizeW / 2;\n                }\n            }\n            popup.setPosition(xx, yy);\n        }\n        togglePopup(popup, target, dir) {\n            if (this._justClosedPopups.indexOf(popup) != -1)\n                return;\n            this.showPopup(popup, target, dir);\n        }\n        hidePopup(popup) {\n            if (popup) {\n                var k = this._popupStack.indexOf(popup);\n                if (k != -1) {\n                    for (var i = this._popupStack.length - 1; i >= k; i--)\n                        this.closePopup(this._popupStack.pop());\n                }\n            }\n            else {\n                var cnt = this._popupStack.length;\n                for (i = cnt - 1; i >= 0; i--)\n                    this.closePopup(this._popupStack[i]);\n                this._popupStack.length = 0;\n            }\n        }\n        get hasAnyPopup() {\n            return this._popupStack.length != 0;\n        }\n        closePopup(target) {\n            if (target.parent) {\n                if (target instanceof fgui.Window)\n                    target.hide();\n                else\n                    this.removeChild(target);\n            }\n        }\n        showTooltips(msg) {\n            if (this._defaultTooltipWin == null) {\n                var resourceURL = fgui.UIConfig.tooltipsWin;\n                if (!resourceURL) {\n                    console.warn(\"UIConfig.tooltipsWin not defined\");\n                    return;\n                }\n                this._defaultTooltipWin = fgui.UIPackage.createObjectFromURL(resourceURL);\n            }\n            this._defaultTooltipWin.text = msg;\n            this.showTooltipsWin(this._defaultTooltipWin);\n        }\n        showTooltipsWin(tooltipWin, xx, yy) {\n            this.hideTooltips();\n            this._tooltipWin = tooltipWin;\n            if (xx == null || yy == null) {\n                xx = fgui.Stage.touchPos.x + 10;\n                yy = fgui.Stage.touchPos.y + 20;\n            }\n            var pt = this.globalToLocal(xx, yy);\n            xx = pt.x;\n            yy = pt.y;\n            if (xx + this._tooltipWin.width > this.width) {\n                xx = xx - this._tooltipWin.width - 1;\n                if (xx < 0)\n                    xx = 10;\n            }\n            if (yy + this._tooltipWin.height > this.height) {\n                yy = yy - this._tooltipWin.height - 1;\n                if (xx - this._tooltipWin.width - 1 > 0)\n                    xx = xx - this._tooltipWin.width - 1;\n                if (yy < 0)\n                    yy = 10;\n            }\n            this._tooltipWin.x = xx;\n            this._tooltipWin.y = yy;\n            this.addChild(this._tooltipWin);\n        }\n        hideTooltips() {\n            if (this._tooltipWin) {\n                if (this._tooltipWin.parent)\n                    this.removeChild(this._tooltipWin);\n                this._tooltipWin = null;\n            }\n        }\n        playOneShotSound(url, volumeScale) {\n            if (!fgui.Stage.audioListener)\n                return;\n            if (volumeScale == null)\n                volumeScale = 1;\n            let pi = fgui.UIPackage.getItemByURL(url);\n            if (pi && pi.audioBuffer) {\n                if (!pi.sound) {\n                    pi.sound = new THREE.Audio(fgui.Stage.audioListener);\n                    pi.sound.setBuffer(pi.audioBuffer);\n                    pi.sound.setLoop(false);\n                }\n                pi.sound.setVolume(volumeScale);\n                pi.sound.play();\n            }\n        }\n        adjustModalLayer() {\n            var cnt = this.numChildren;\n            if (this._modalWaitPane && this._modalWaitPane.parent)\n                this.setChildIndex(this._modalWaitPane, cnt - 1);\n            for (var i = cnt - 1; i >= 0; i--) {\n                var g = this.getChildAt(i);\n                if ((g instanceof fgui.Window) && g.modal) {\n                    if (this._modalLayer.parent == null)\n                        this.addChildAt(this._modalLayer, i);\n                    else\n                        this.setChildIndexBefore(this._modalLayer, i);\n                    return;\n                }\n            }\n            if (this._modalLayer.parent)\n                this.removeChild(this._modalLayer);\n        }\n        checkPopups() {\n            this._justClosedPopups.length = 0;\n            if (this._popupStack.length > 0) {\n                let mc = fgui.Stage.touchTarget;\n                let handled = false;\n                while (mc) {\n                    let gobj = fgui.GObject.cast(mc);\n                    if (gobj) {\n                        let k = this._popupStack.indexOf(gobj);\n                        if (k != -1) {\n                            for (let i = this._popupStack.length - 1; i > k; i--) {\n                                let last = this._popupStack.length - 1;\n                                let popup = this._popupStack[last];\n                                this.closePopup(popup);\n                                this._justClosedPopups.push(popup);\n                                this._popupStack.splice(last, 1);\n                            }\n                            handled = true;\n                            break;\n                        }\n                    }\n                    mc = mc.parent;\n                }\n                if (!handled) {\n                    for (let i = this._popupStack.length - 1; i >= 0; i--) {\n                        let popup = this._popupStack[i];\n                        this.closePopup(popup);\n                        this._justClosedPopups.push(popup);\n                        this._popupStack.splice(i, 1);\n                    }\n                }\n            }\n        }\n        __stageTouchBegin() {\n            if (this._tooltipWin)\n                this.hideTooltips();\n            this.checkPopups();\n        }\n    }\n    fgui.GRoot = GRoot;\n    fgui.Decls.GRoot = GRoot;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_vec2 = new THREE.Vector2();\n    class GScrollBar extends fgui.GComponent {\n        constructor() {\n            super();\n            this._dragOffset = new THREE.Vector2();\n            this._scrollPerc = 0;\n        }\n        setScrollPane(target, vertical) {\n            this._target = target;\n            this._vertical = vertical;\n        }\n        setDisplayPerc(value) {\n            if (this._vertical) {\n                if (!this._fixedGripSize)\n                    this._grip.height = Math.floor(value * this._bar.height);\n                this._grip.y = this._bar.y + (this._bar.height - this._grip.height) * this._scrollPerc;\n            }\n            else {\n                if (!this._fixedGripSize)\n                    this._grip.width = Math.floor(value * this._bar.width);\n                this._grip.x = this._bar.x + (this._bar.width - this._grip.width) * this._scrollPerc;\n            }\n            this._grip.visible = value != 0 && value != 1;\n        }\n        setScrollPerc(val) {\n            this._scrollPerc = val;\n            if (this._vertical)\n                this._grip.y = this._bar.y + (this._bar.height - this._grip.height) * this._scrollPerc;\n            else\n                this._grip.x = this._bar.x + (this._bar.width - this._grip.width) * this._scrollPerc;\n        }\n        get minSize() {\n            if (this._vertical)\n                return (this._arrowButton1 ? this._arrowButton1.height : 0) + (this._arrowButton2 ? this._arrowButton2.height : 0);\n            else\n                return (this._arrowButton1 ? this._arrowButton1.width : 0) + (this._arrowButton2 ? this._arrowButton2.width : 0);\n        }\n        get gripDragging() {\n            return this._gripDragging;\n        }\n        constructExtension(buffer) {\n            buffer.seek(0, 6);\n            this._fixedGripSize = buffer.readBool();\n            this._grip = this.getChild(\"grip\");\n            if (!this._grip) {\n                console.warn(\"需要定义grip\");\n                return;\n            }\n            this._bar = this.getChild(\"bar\");\n            if (!this._bar) {\n                console.warn(\"需要定义bar\");\n                return;\n            }\n            this._arrowButton1 = this.getChild(\"arrow1\");\n            this._arrowButton2 = this.getChild(\"arrow2\");\n            this._grip.on(fgui.InteractiveEvents.Down, this.__gripTouchBegin, this);\n            this._grip.on(fgui.InteractiveEvents.Move, this.__gripTouchMove, this);\n            this._grip.on(fgui.InteractiveEvents.Up, this.__gripTouchEnd, this);\n            this.on(fgui.InteractiveEvents.Down, this.__barTouchBegin, this);\n            if (this._arrowButton1)\n                this._arrowButton1.on(fgui.InteractiveEvents.Down, this.__arrowButton1Click, this);\n            if (this._arrowButton2)\n                this._arrowButton2.on(fgui.InteractiveEvents.Down, this.__arrowButton2Click, this);\n        }\n        __gripTouchBegin(evt) {\n            if (this._bar == null)\n                return;\n            evt.stopPropagation();\n            this._gripDragging = true;\n            this._target.updateScrollBarVisible();\n            this.globalToLocal(evt.input.x, evt.input.y, this._dragOffset);\n            this._dragOffset.x -= this._grip.x;\n            this._dragOffset.y -= this._grip.y;\n        }\n        __gripTouchMove(evt) {\n            if (!this.onStage)\n                return;\n            var pt = this.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            if (this._vertical) {\n                let curY = pt.y - this._dragOffset.y;\n                let diff = this._bar.height - this._grip.height;\n                if (diff == 0)\n                    this._target.percY = 0;\n                else\n                    this._target.percY = (curY - this._bar.y) / diff;\n            }\n            else {\n                let curX = pt.x - this._dragOffset.x;\n                let diff = this._bar.width - this._grip.width;\n                if (diff == 0)\n                    this._target.percX = 0;\n                else\n                    this._target.percX = (curX - this._bar.x) / (this._bar.width - this._grip.width);\n            }\n        }\n        __gripTouchEnd(evt) {\n            this._gripDragging = false;\n            this._target.updateScrollBarVisible();\n        }\n        __arrowButton1Click(evt) {\n            evt.stopPropagation();\n            if (this._vertical)\n                this._target.scrollUp();\n            else\n                this._target.scrollLeft();\n        }\n        __arrowButton2Click(evt) {\n            evt.stopPropagation();\n            if (this._vertical)\n                this._target.scrollDown();\n            else\n                this._target.scrollRight();\n        }\n        __barTouchBegin(evt) {\n            evt.stopPropagation();\n            var pt = this.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            var pt = this._grip.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            if (this._vertical) {\n                if (pt.y < 0)\n                    this._target.scrollUp(4);\n                else\n                    this._target.scrollDown(4);\n            }\n            else {\n                if (pt.x < 0)\n                    this._target.scrollLeft(4);\n                else\n                    this._target.scrollRight(4);\n            }\n        }\n    }\n    fgui.GScrollBar = GScrollBar;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let s_vec2 = new THREE.Vector2();\n    class GSlider extends fgui.GComponent {\n        constructor() {\n            super();\n            this.changeOnClick = true;\n            this.canDrag = true;\n            this._min = 0;\n            this._max = 0;\n            this._value = 0;\n            this._barMaxWidth = 0;\n            this._barMaxHeight = 0;\n            this._barMaxWidthDelta = 0;\n            this._barMaxHeightDelta = 0;\n            this._clickPercent = 0;\n            this._barStartX = 0;\n            this._barStartY = 0;\n            this._titleType = fgui.ProgressTitleType.Percent;\n            this._value = 50;\n            this._max = 100;\n            this._clickPos = new THREE.Vector2();\n        }\n        get titleType() {\n            return this._titleType;\n        }\n        set titleType(value) {\n            this._titleType = value;\n        }\n        get wholeNumbers() {\n            return this._wholeNumbers;\n        }\n        set wholeNumbers(value) {\n            if (this._wholeNumbers != value) {\n                this._wholeNumbers = value;\n                this.update();\n            }\n        }\n        get min() {\n            return this._min;\n        }\n        set min(value) {\n            if (this._min != value) {\n                this._min = value;\n                this.update();\n            }\n        }\n        get max() {\n            return this._max;\n        }\n        set max(value) {\n            if (this._max != value) {\n                this._max = value;\n                this.update();\n            }\n        }\n        get value() {\n            return this._value;\n        }\n        set value(value) {\n            if (this._value != value) {\n                this._value = value;\n                this.update();\n            }\n        }\n        update() {\n            this.updateWithPercent((this._value - this._min) / (this._max - this._min), false);\n        }\n        updateWithPercent(percent, manual) {\n            percent = fgui.clamp01(percent);\n            if (manual) {\n                var newValue = fgui.clamp(this._min + (this._max - this._min) * percent, this._min, this._max);\n                if (this._wholeNumbers) {\n                    newValue = Math.round(newValue);\n                    percent = fgui.clamp01((newValue - this._min) / (this._max - this._min));\n                }\n                if (newValue != this._value) {\n                    this._value = newValue;\n                    if (this.dispatchEvent(fgui.StateChangeEvent.CHANGED))\n                        return;\n                }\n            }\n            if (this._titleObject) {\n                switch (this._titleType) {\n                    case fgui.ProgressTitleType.Percent:\n                        this._titleObject.text = Math.floor(percent * 100) + \"%\";\n                        break;\n                    case fgui.ProgressTitleType.ValueAndMax:\n                        this._titleObject.text = this._value + \"/\" + this._max;\n                        break;\n                    case fgui.ProgressTitleType.Value:\n                        this._titleObject.text = \"\" + this._value;\n                        break;\n                    case fgui.ProgressTitleType.Max:\n                        this._titleObject.text = \"\" + this._max;\n                        break;\n                }\n            }\n            var fullWidth = this.width - this._barMaxWidthDelta;\n            var fullHeight = this.height - this._barMaxHeightDelta;\n            if (!this._reverse) {\n                if (this._barObjectH)\n                    this._barObjectH.width = Math.round(fullWidth * percent);\n                if (this._barObjectV)\n                    this._barObjectV.height = Math.round(fullHeight * percent);\n            }\n            else {\n                if (this._barObjectH) {\n                    this._barObjectH.width = Math.round(fullWidth * percent);\n                    this._barObjectH.x = this._barStartX + (fullWidth - this._barObjectH.width);\n                }\n                if (this._barObjectV) {\n                    this._barObjectV.height = Math.round(fullHeight * percent);\n                    this._barObjectV.y = this._barStartY + (fullHeight - this._barObjectV.height);\n                }\n            }\n        }\n        constructExtension(buffer) {\n            buffer.seek(0, 6);\n            this._titleType = buffer.readByte();\n            this._reverse = buffer.readBool();\n            if (buffer.version >= 2) {\n                this._wholeNumbers = buffer.readBool();\n                this.changeOnClick = buffer.readBool();\n            }\n            this._titleObject = this.getChild(\"title\");\n            this._barObjectH = this.getChild(\"bar\");\n            this._barObjectV = this.getChild(\"bar_v\");\n            this._gripObject = this.getChild(\"grip\");\n            if (this._barObjectH) {\n                this._barMaxWidth = this._barObjectH.width;\n                this._barMaxWidthDelta = this.width - this._barMaxWidth;\n                this._barStartX = this._barObjectH.x;\n            }\n            if (this._barObjectV) {\n                this._barMaxHeight = this._barObjectV.height;\n                this._barMaxHeightDelta = this.height - this._barMaxHeight;\n                this._barStartY = this._barObjectV.y;\n            }\n            if (this._gripObject) {\n                this._gripObject.on(fgui.InteractiveEvents.Down, this.__gripTouchBegin, this);\n                this._gripObject.on(fgui.InteractiveEvents.Move, this.__gripTouchMove, this);\n            }\n            this.on(fgui.InteractiveEvents.Down, this.__barTouchBegin, this);\n        }\n        handleSizeChanged() {\n            super.handleSizeChanged();\n            if (this._barObjectH)\n                this._barMaxWidth = this.width - this._barMaxWidthDelta;\n            if (this._barObjectV)\n                this._barMaxHeight = this.height - this._barMaxHeightDelta;\n            if (!this._underConstruct)\n                this.update();\n        }\n        setup_afterAdd(buffer, beginPos) {\n            super.setup_afterAdd(buffer, beginPos);\n            if (!buffer.seek(beginPos, 6)) {\n                this.update();\n                return;\n            }\n            if (buffer.readByte() != this.packageItem.objectType) {\n                this.update();\n                return;\n            }\n            this._value = buffer.readInt();\n            this._max = buffer.readInt();\n            if (buffer.version >= 2)\n                this._min = buffer.readInt();\n            this.update();\n        }\n        __gripTouchBegin(evt) {\n            if (evt.input.button != 0)\n                return;\n            this.canDrag = true;\n            evt.stopPropagation();\n            evt.captureTouch();\n            this.globalToLocal(evt.input.x, evt.input.y, this._clickPos);\n            this._clickPercent = fgui.clamp01((this._value - this._min) / (this._max - this._min));\n        }\n        __gripTouchMove(evt) {\n            if (!this.canDrag)\n                return;\n            var pt = this.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            var deltaX = pt.x - this._clickPos.x;\n            var deltaY = pt.y - this._clickPos.y;\n            if (this._reverse) {\n                deltaX = -deltaX;\n                deltaY = -deltaY;\n            }\n            var percent;\n            if (this._barObjectH)\n                percent = this._clickPercent + deltaX / this._barMaxWidth;\n            else\n                percent = this._clickPercent + deltaY / this._barMaxHeight;\n            this.updateWithPercent(percent, true);\n        }\n        __barTouchBegin(evt) {\n            if (!this.changeOnClick)\n                return;\n            var pt = this._gripObject.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            var percent = fgui.clamp01((this._value - this._min) / (this._max - this._min));\n            var delta = 0;\n            if (this._barObjectH != null)\n                delta = (pt.x - this._gripObject.width / 2) / this._barMaxWidth;\n            if (this._barObjectV != null)\n                delta = (pt.y - this._gripObject.height / 2) / this._barMaxHeight;\n            if (this._reverse)\n                percent -= delta;\n            else\n                percent += delta;\n            this.updateWithPercent(percent, true);\n        }\n    }\n    fgui.GSlider = GSlider;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GTextInput extends fgui.GTextField {\n        constructor() {\n            super();\n        }\n        createDisplayObject() {\n            this._displayObject = this._textField = new fgui.InputTextField();\n        }\n        get password() {\n            return this._textField.password;\n        }\n        set password(value) {\n            this._textField.password = value;\n        }\n        get keyboardType() {\n            return this._textField.keyboardType;\n        }\n        set keyboardType(value) {\n            this._textField.keyboardType = value;\n        }\n        set editable(value) {\n            this._textField.editable = value;\n        }\n        get editable() {\n            return this._textField.editable;\n        }\n        set maxLength(value) {\n            this._textField.maxLength = value;\n        }\n        get maxLength() {\n            return this._textField.maxLength;\n        }\n        set promptText(value) {\n            this._textField.promptText = value;\n        }\n        get promptText() {\n            return this._textField.promptText;\n        }\n        set restrict(value) {\n            this._textField.restrict = value;\n        }\n        get restrict() {\n            return this._textField.restrict;\n        }\n        requestFocus() {\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 4);\n            var str = buffer.readS();\n            if (str != null)\n                this.promptText = str;\n            str = buffer.readS();\n            if (str != null)\n                this.restrict = str;\n            var iv = buffer.readInt();\n            if (iv != 0)\n                this.maxLength = iv;\n            iv = buffer.readInt();\n            if (iv != 0) {\n                if (iv == 4)\n                    this.keyboardType = \"number\";\n                else if (iv == 3)\n                    this.keyboardType = \"url\";\n            }\n            if (buffer.readBool())\n                this.password = true;\n        }\n    }\n    fgui.GTextInput = GTextInput;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_list = new Array();\n    class GTree extends fgui.GList {\n        constructor() {\n            super();\n            this._indent = 15;\n            this._rootNode = new fgui.GTreeNode(true);\n            this._rootNode._setTree(this);\n            this._rootNode.expanded = true;\n        }\n        get rootNode() {\n            return this._rootNode;\n        }\n        get indent() {\n            return this._indent;\n        }\n        set indent(value) {\n            this._indent = value;\n        }\n        get clickToExpand() {\n            return this._clickToExpand;\n        }\n        set clickToExpand(value) {\n            this._clickToExpand = value;\n        }\n        getSelectedNode() {\n            if (this.selectedIndex != -1)\n                return this.getChildAt(this.selectedIndex)._treeNode;\n            else\n                return null;\n        }\n        getSelectedNodes(result) {\n            if (!result)\n                result = new Array();\n            s_list.length = 0;\n            super.getSelection(s_list);\n            var cnt = s_list.length;\n            var ret = new Array();\n            for (var i = 0; i < cnt; i++) {\n                var node = this.getChildAt(s_list[i])._treeNode;\n                ret.push(node);\n            }\n            return ret;\n        }\n        selectNode(node, scrollItToView) {\n            var parentNode = node.parent;\n            while (parentNode && parentNode != this._rootNode) {\n                parentNode.expanded = true;\n                parentNode = parentNode.parent;\n            }\n            if (!node._cell)\n                return;\n            this.addSelection(this.getChildIndex(node._cell), scrollItToView);\n        }\n        unselectNode(node) {\n            if (!node._cell)\n                return;\n            this.removeSelection(this.getChildIndex(node._cell));\n        }\n        expandAll(folderNode) {\n            if (!folderNode)\n                folderNode = this._rootNode;\n            folderNode.expanded = true;\n            var cnt = folderNode.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                var node = folderNode.getChildAt(i);\n                if (node.isFolder)\n                    this.expandAll(node);\n            }\n        }\n        collapseAll(folderNode) {\n            if (!folderNode)\n                folderNode = this._rootNode;\n            if (folderNode != this._rootNode)\n                folderNode.expanded = false;\n            var cnt = folderNode.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                var node = folderNode.getChildAt(i);\n                if (node.isFolder)\n                    this.collapseAll(node);\n            }\n        }\n        createCell(node) {\n            var child = this.getFromPool(node._resURL ? node._resURL : this.defaultItem);\n            if (!child)\n                throw new Error(\"cannot create tree node object.\");\n            child._treeNode = node;\n            node._cell = child;\n            var indentObj = child.getChild(\"indent\");\n            if (indentObj)\n                indentObj.width = (node.level - 1) * this._indent;\n            var cc;\n            cc = child.getController(\"expanded\");\n            if (cc) {\n                cc.on(fgui.StateChangeEvent.CHANGED, this.__expandedStateChanged, this);\n                cc.selectedIndex = node.expanded ? 1 : 0;\n            }\n            cc = child.getController(\"leaf\");\n            if (cc)\n                cc.selectedIndex = node.isFolder ? 0 : 1;\n            if (node.isFolder)\n                child.on(fgui.InteractiveEvents.Down, this.__cellMouseDown, this);\n            if (this.treeNodeRender)\n                this.treeNodeRender(node, child);\n        }\n        _afterInserted(node) {\n            if (!node._cell)\n                this.createCell(node);\n            var index = this.getInsertIndexForNode(node);\n            this.addChildAt(node._cell, index);\n            if (this.treeNodeRender)\n                this.treeNodeRender(node, node._cell);\n            if (node.isFolder && node.expanded)\n                this.checkChildren(node, index);\n        }\n        getInsertIndexForNode(node) {\n            var prevNode = node.getPrevSibling();\n            if (prevNode == null)\n                prevNode = node.parent;\n            var insertIndex = this.getChildIndex(prevNode._cell) + 1;\n            var myLevel = node.level;\n            var cnt = this.numChildren;\n            for (var i = insertIndex; i < cnt; i++) {\n                var testNode = this.getChildAt(i)._treeNode;\n                if (testNode.level <= myLevel)\n                    break;\n                insertIndex++;\n            }\n            return insertIndex;\n        }\n        _afterRemoved(node) {\n            this.removeNode(node);\n        }\n        _afterExpanded(node) {\n            if (node == this._rootNode) {\n                this.checkChildren(this._rootNode, 0);\n                return;\n            }\n            if (this.treeNodeWillExpand)\n                this.treeNodeWillExpand(node, true);\n            if (node._cell == null)\n                return;\n            if (this.treeNodeRender)\n                this.treeNodeRender(node, node._cell);\n            var cc = node._cell.getController(\"expanded\");\n            if (cc)\n                cc.selectedIndex = 1;\n            if (node._cell.parent)\n                this.checkChildren(node, this.getChildIndex(node._cell));\n        }\n        _afterCollapsed(node) {\n            if (node == this._rootNode) {\n                this.checkChildren(this._rootNode, 0);\n                return;\n            }\n            if (this.treeNodeWillExpand)\n                this.treeNodeWillExpand(node, false);\n            if (node._cell == null)\n                return;\n            if (this.treeNodeRender)\n                this.treeNodeRender(node, node._cell);\n            var cc = node._cell.getController(\"expanded\");\n            if (cc)\n                cc.selectedIndex = 0;\n            if (node._cell.parent)\n                this.hideFolderNode(node);\n        }\n        _afterMoved(node) {\n            var startIndex = this.getChildIndex(node._cell);\n            var endIndex;\n            if (node.isFolder)\n                endIndex = this.getFolderEndIndex(startIndex, node.level);\n            else\n                endIndex = startIndex + 1;\n            var insertIndex = this.getInsertIndexForNode(node);\n            var i;\n            var cnt = endIndex - startIndex;\n            var obj;\n            if (insertIndex < startIndex) {\n                for (i = 0; i < cnt; i++) {\n                    obj = this.getChildAt(startIndex + i);\n                    this.setChildIndex(obj, insertIndex + i);\n                }\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    obj = this.getChildAt(startIndex);\n                    this.setChildIndex(obj, insertIndex);\n                }\n            }\n        }\n        getFolderEndIndex(startIndex, level) {\n            var cnt = this.numChildren;\n            for (var i = startIndex + 1; i < cnt; i++) {\n                var node = this.getChildAt(i)._treeNode;\n                if (node.level <= level)\n                    return i;\n            }\n            return cnt;\n        }\n        checkChildren(folderNode, index) {\n            var cnt = folderNode.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                index++;\n                var node = folderNode.getChildAt(i);\n                if (node._cell == null)\n                    this.createCell(node);\n                if (!node._cell.parent)\n                    this.addChildAt(node._cell, index);\n                if (node.isFolder && node.expanded)\n                    index = this.checkChildren(node, index);\n            }\n            return index;\n        }\n        hideFolderNode(folderNode) {\n            var cnt = folderNode.numChildren;\n            for (var i = 0; i < cnt; i++) {\n                var node = folderNode.getChildAt(i);\n                if (node._cell)\n                    this.removeChild(node._cell);\n                if (node.isFolder && node.expanded)\n                    this.hideFolderNode(node);\n            }\n        }\n        removeNode(node) {\n            if (node._cell) {\n                if (node._cell.parent)\n                    this.removeChild(node._cell);\n                this.returnToPool(node._cell);\n                node._cell._treeNode = null;\n                node._cell = null;\n            }\n            if (node.isFolder) {\n                var cnt = node.numChildren;\n                for (var i = 0; i < cnt; i++) {\n                    var node2 = node.getChildAt(i);\n                    this.removeNode(node2);\n                }\n            }\n        }\n        __cellMouseDown(evt) {\n            var node = fgui.GObject.cast(evt.sender)._treeNode;\n            this._expandedStatusInEvt = node.expanded;\n        }\n        __expandedStateChanged(evt) {\n            let cc = evt.sender;\n            var node = cc.parent._treeNode;\n            node.expanded = cc.selectedIndex == 1;\n        }\n        dispatchItemEvent(item, evt) {\n            if (this._clickToExpand != 0) {\n                var node = item._treeNode;\n                if (node && node.isFolder && this._expandedStatusInEvt == node.expanded) {\n                    if (this._clickToExpand == 2) {\n                        if (evt.input.clickCount == 2)\n                            node.expanded = !node.expanded;\n                    }\n                    else\n                        node.expanded = !node.expanded;\n                }\n            }\n            super.dispatchItemEvent(item, evt);\n        }\n        setup_beforeAdd(buffer, beginPos) {\n            super.setup_beforeAdd(buffer, beginPos);\n            buffer.seek(beginPos, 9);\n            this._indent = buffer.readInt();\n            this._clickToExpand = buffer.readByte();\n        }\n        readItems(buffer) {\n            var cnt;\n            var i;\n            var nextPos;\n            var str;\n            var isFolder;\n            var lastNode;\n            var level;\n            var prevLevel = 0;\n            cnt = buffer.readShort();\n            for (i = 0; i < cnt; i++) {\n                nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                str = buffer.readS();\n                if (str == null) {\n                    str = this.defaultItem;\n                    if (!str) {\n                        buffer.pos = nextPos;\n                        continue;\n                    }\n                }\n                isFolder = buffer.readBool();\n                level = buffer.readByte();\n                var node = new fgui.GTreeNode(isFolder, str);\n                node.expanded = true;\n                if (i == 0)\n                    this._rootNode.addChild(node);\n                else {\n                    if (level > prevLevel)\n                        lastNode.addChild(node);\n                    else if (level < prevLevel) {\n                        for (var j = level; j <= prevLevel; j++)\n                            lastNode = lastNode.parent;\n                        lastNode.addChild(node);\n                    }\n                    else\n                        lastNode.parent.addChild(node);\n                }\n                lastNode = node;\n                prevLevel = level;\n                this.setupItem(buffer, node.cell);\n                buffer.pos = nextPos;\n            }\n        }\n    }\n    fgui.GTree = GTree;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class GTreeNode {\n        constructor(hasChild, resURL) {\n            this._expanded = false;\n            this._level = 0;\n            this._resURL = resURL;\n            if (hasChild)\n                this._children = new Array();\n        }\n        set expanded(value) {\n            if (this._children == null)\n                return;\n            if (this._expanded != value) {\n                this._expanded = value;\n                if (this._tree) {\n                    if (this._expanded)\n                        this._tree._afterExpanded(this);\n                    else\n                        this._tree._afterCollapsed(this);\n                }\n            }\n        }\n        get expanded() {\n            return this._expanded;\n        }\n        get isFolder() {\n            return this._children != null;\n        }\n        get parent() {\n            return this._parent;\n        }\n        get text() {\n            if (this._cell)\n                return this._cell.text;\n            else\n                return null;\n        }\n        set text(value) {\n            if (this._cell)\n                this._cell.text = value;\n        }\n        get icon() {\n            if (this._cell)\n                return this._cell.icon;\n            else\n                return null;\n        }\n        set icon(value) {\n            if (this._cell)\n                this._cell.icon = value;\n        }\n        get cell() {\n            return this._cell;\n        }\n        get level() {\n            return this._level;\n        }\n        _setLevel(value) {\n            this._level = value;\n        }\n        addChild(child) {\n            this.addChildAt(child, this._children.length);\n            return child;\n        }\n        addChildAt(child, index) {\n            if (!child)\n                throw new Error(\"child is null\");\n            var numChildren = this._children.length;\n            if (index >= 0 && index <= numChildren) {\n                if (child._parent == this) {\n                    this.setChildIndex(child, index);\n                }\n                else {\n                    if (child._parent)\n                        child._parent.removeChild(child);\n                    var cnt = this._children.length;\n                    if (index == cnt)\n                        this._children.push(child);\n                    else\n                        this._children.splice(index, 0, child);\n                    child._parent = this;\n                    child._level = this._level + 1;\n                    child._setTree(this._tree);\n                    if (this._tree && this == this._tree.rootNode || this._cell && this._cell.parent && this._expanded)\n                        this._tree._afterInserted(child);\n                }\n                return child;\n            }\n            else {\n                throw new RangeError(\"Invalid child index\");\n            }\n        }\n        removeChild(child) {\n            var childIndex = this._children.indexOf(child);\n            if (childIndex != -1) {\n                this.removeChildAt(childIndex);\n            }\n            return child;\n        }\n        removeChildAt(index) {\n            if (index >= 0 && index < this.numChildren) {\n                var child = this._children[index];\n                this._children.splice(index, 1);\n                child._parent = null;\n                if (this._tree) {\n                    child._setTree(null);\n                    this._tree._afterRemoved(child);\n                }\n                return child;\n            }\n            else {\n                throw \"Invalid child index\";\n            }\n        }\n        removeChildren(beginIndex, endIndex) {\n            beginIndex = beginIndex || 0;\n            if (endIndex == null)\n                endIndex = -1;\n            if (endIndex < 0 || endIndex >= this.numChildren)\n                endIndex = this.numChildren - 1;\n            for (var i = beginIndex; i <= endIndex; ++i)\n                this.removeChildAt(beginIndex);\n        }\n        getChildAt(index) {\n            if (index >= 0 && index < this.numChildren)\n                return this._children[index];\n            else\n                throw \"Invalid child index\";\n        }\n        getChildIndex(child) {\n            return this._children.indexOf(child);\n        }\n        getPrevSibling() {\n            if (this._parent == null)\n                return null;\n            var i = this._parent._children.indexOf(this);\n            if (i <= 0)\n                return null;\n            return this._parent._children[i - 1];\n        }\n        getNextSibling() {\n            if (this._parent == null)\n                return null;\n            var i = this._parent._children.indexOf(this);\n            if (i < 0 || i >= this._parent._children.length - 1)\n                return null;\n            return this._parent._children[i + 1];\n        }\n        setChildIndex(child, index) {\n            var oldIndex = this._children.indexOf(child);\n            if (oldIndex == -1)\n                throw \"Not a child of this container\";\n            var cnt = this._children.length;\n            if (index < 0)\n                index = 0;\n            else if (index > cnt)\n                index = cnt;\n            if (oldIndex == index)\n                return;\n            this._children.splice(oldIndex, 1);\n            this._children.splice(index, 0, child);\n            if (this._tree && this == this._tree.rootNode || this._cell && this._cell.parent && this._expanded)\n                this._tree._afterMoved(child);\n        }\n        swapChildren(child1, child2) {\n            var index1 = this._children.indexOf(child1);\n            var index2 = this._children.indexOf(child2);\n            if (index1 == -1 || index2 == -1)\n                throw \"Not a child of this container\";\n            this.swapChildrenAt(index1, index2);\n        }\n        swapChildrenAt(index1, index2) {\n            var child1 = this._children[index1];\n            var child2 = this._children[index2];\n            this.setChildIndex(child1, index2);\n            this.setChildIndex(child2, index1);\n        }\n        get numChildren() {\n            return this._children.length;\n        }\n        expandToRoot() {\n            var p = this;\n            while (p) {\n                p.expanded = true;\n                p = p.parent;\n            }\n        }\n        get tree() {\n            return this._tree;\n        }\n        _setTree(value) {\n            this._tree = value;\n            if (this._tree && this._tree.treeNodeWillExpand && this._expanded)\n                this._tree.treeNodeWillExpand(this, true);\n            if (this._children) {\n                var cnt = this._children.length;\n                for (var i = 0; i < cnt; i++) {\n                    var node = this._children[i];\n                    node._level = this._level + 1;\n                    node._setTree(value);\n                }\n            }\n        }\n    }\n    fgui.GTreeNode = GTreeNode;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Margin {\n        constructor() {\n            this.left = 0;\n            this.right = 0;\n            this.top = 0;\n            this.bottom = 0;\n        }\n        copy(source) {\n            this.top = source.top;\n            this.bottom = source.bottom;\n            this.left = source.left;\n            this.right = source.right;\n        }\n    }\n    fgui.Margin = Margin;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class PackageItem {\n        constructor() {\n            this.width = 0;\n            this.height = 0;\n        }\n        load() {\n            return this.owner.getItemAsset(this);\n        }\n        getBranch() {\n            if (this.branches && this.owner._branchIndex != -1) {\n                var itemId = this.branches[this.owner._branchIndex];\n                if (itemId)\n                    return this.owner.getItemById(itemId);\n            }\n            return this;\n        }\n        getHighResolution() {\n            if (this.highResolution && fgui.UIContentScaler.scaleLevel > 0) {\n                var itemId = this.highResolution[fgui.UIContentScaler.scaleLevel - 1];\n                if (itemId)\n                    return this.owner.getItemById(itemId);\n            }\n            return this;\n        }\n        toString() {\n            return this.name;\n        }\n    }\n    fgui.PackageItem = PackageItem;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class PopupMenu {\n        constructor(resourceURL) {\n            if (!resourceURL) {\n                resourceURL = fgui.UIConfig.popupMenu;\n                if (!resourceURL)\n                    throw \"UIConfig.popupMenu not defined\";\n            }\n            this._contentPane = fgui.UIPackage.createObjectFromURL(resourceURL);\n            this._contentPane.on(fgui.StageEvent.AddtoStage, this.__addedToStage, this);\n            this._list = (this._contentPane.getChild(\"list\"));\n            this._list.removeChildrenToPool();\n            this._list.addRelation(this._contentPane, fgui.RelationType.Width);\n            this._list.removeRelation(this._contentPane, fgui.RelationType.Height);\n            this._contentPane.addRelation(this._list, fgui.RelationType.Height);\n            this._list.on(fgui.ListEvent.ItemClick, this.__clickItem, this);\n        }\n        dispose() {\n            this._contentPane.dispose();\n        }\n        addItem(caption, handler) {\n            var item = this._list.addItemFromPool();\n            item.title = caption;\n            item.data = handler;\n            item.grayed = false;\n            var c = item.getController(\"checked\");\n            if (c)\n                c.selectedIndex = 0;\n            return item;\n        }\n        addItemAt(caption, index, handler) {\n            var item = this._list.getFromPool();\n            this._list.addChildAt(item, index);\n            item.title = caption;\n            item.data = handler;\n            item.grayed = false;\n            var c = item.getController(\"checked\");\n            if (c)\n                c.selectedIndex = 0;\n            return item;\n        }\n        addSeperator() {\n            if (fgui.UIConfig.popupMenu_seperator == null)\n                throw \"UIConfig.popupMenu_seperator not defined\";\n            this.list.addItemFromPool(fgui.UIConfig.popupMenu_seperator);\n        }\n        getItemName(index) {\n            var item = this._list.getChildAt(index);\n            return item.name;\n        }\n        setItemText(name, caption) {\n            var item = this._list.getChild(name);\n            item.title = caption;\n        }\n        setItemVisible(name, visible) {\n            var item = this._list.getChild(name);\n            if (item.visible != visible) {\n                item.visible = visible;\n                this._list.setBoundsChangedFlag();\n            }\n        }\n        setItemGrayed(name, grayed) {\n            var item = this._list.getChild(name);\n            item.grayed = grayed;\n        }\n        setItemCheckable(name, checkable) {\n            var item = this._list.getChild(name);\n            var c = item.getController(\"checked\");\n            if (c) {\n                if (checkable) {\n                    if (c.selectedIndex == 0)\n                        c.selectedIndex = 1;\n                }\n                else\n                    c.selectedIndex = 0;\n            }\n        }\n        setItemChecked(name, checked) {\n            var item = this._list.getChild(name);\n            var c = item.getController(\"checked\");\n            if (c)\n                c.selectedIndex = checked ? 2 : 1;\n        }\n        isItemChecked(name) {\n            var item = this._list.getChild(name);\n            var c = item.getController(\"checked\");\n            if (c)\n                return c.selectedIndex == 2;\n            else\n                return false;\n        }\n        removeItem(name) {\n            var item = this._list.getChild(name);\n            if (item) {\n                var index = this._list.getChildIndex(item);\n                this._list.removeChildToPoolAt(index);\n                return true;\n            }\n            else\n                return false;\n        }\n        clearItems() {\n            this._list.removeChildrenToPool();\n        }\n        get itemCount() {\n            return this._list.numChildren;\n        }\n        get contentPane() {\n            return this._contentPane;\n        }\n        get list() {\n            return this._list;\n        }\n        show(target, dir) {\n            var r = fgui.GRoot.findFor(target);\n            r.showPopup(this.contentPane, (target instanceof fgui.GRoot) ? null : target, dir);\n        }\n        __clickItem(evt) {\n            let itemObject = evt.data;\n            if (!(itemObject instanceof fgui.GButton))\n                return;\n            if (itemObject.grayed) {\n                this._list.selectedIndex = -1;\n                return;\n            }\n            var c = itemObject.getController(\"checked\");\n            if (c && c.selectedIndex != 0) {\n                if (c.selectedIndex == 1)\n                    c.selectedIndex = 2;\n                else\n                    c.selectedIndex = 1;\n            }\n            var r = (this._contentPane.parent);\n            r.hidePopup(this.contentPane);\n            if (itemObject.data) {\n                itemObject.data();\n            }\n        }\n        __addedToStage() {\n            this._list.selectedIndex = -1;\n            this._list.resizeToFit(100000, 10);\n        }\n    }\n    fgui.PopupMenu = PopupMenu;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class RelationItem {\n        constructor(owner) {\n            this._owner = owner;\n            this._defs = new Array();\n        }\n        get owner() {\n            return this._owner;\n        }\n        set target(value) {\n            if (this._target != value) {\n                if (this._target)\n                    this.releaseRefTarget();\n                this._target = value;\n                if (this._target)\n                    this.addRefTarget();\n            }\n        }\n        get target() {\n            return this._target;\n        }\n        add(relationType, usePercent) {\n            if (relationType == fgui.RelationType.Size) {\n                this.add(fgui.RelationType.Width, usePercent);\n                this.add(fgui.RelationType.Height, usePercent);\n                return;\n            }\n            var cnt = this._defs.length;\n            for (var i = 0; i < cnt; i++) {\n                if (this._defs[i].type == relationType)\n                    return;\n            }\n            this.internalAdd(relationType, usePercent);\n        }\n        internalAdd(relationType, usePercent) {\n            if (relationType == fgui.RelationType.Size) {\n                this.internalAdd(fgui.RelationType.Width, usePercent);\n                this.internalAdd(fgui.RelationType.Height, usePercent);\n                return;\n            }\n            var info = new RelationDef();\n            info.percent = usePercent;\n            info.type = relationType;\n            info.axis = (relationType <= fgui.RelationType.Right_Right || relationType == fgui.RelationType.Width || relationType >= fgui.RelationType.LeftExt_Left && relationType <= fgui.RelationType.RightExt_Right) ? 0 : 1;\n            this._defs.push(info);\n        }\n        remove(relationType) {\n            if (relationType == fgui.RelationType.Size) {\n                this.remove(fgui.RelationType.Width);\n                this.remove(fgui.RelationType.Height);\n                return;\n            }\n            var dc = this._defs.length;\n            for (var k = 0; k < dc; k++) {\n                if (this._defs[k].type == relationType) {\n                    this._defs.splice(k, 1);\n                    break;\n                }\n            }\n        }\n        copy(source) {\n            this._target = source.target;\n            this._defs.length = 0;\n            var cnt = source._defs.length;\n            for (var i = 0; i < cnt; i++) {\n                var info = source._defs[i];\n                var info2 = new RelationDef();\n                info2.copy(info);\n                this._defs.push(info2);\n            }\n        }\n        dispose() {\n            if (this._target) {\n                this.releaseRefTarget();\n                this._target = null;\n            }\n        }\n        get isEmpty() {\n            return this._defs.length == 0;\n        }\n        applyOnSelfResized(dWidth, dHeight, applyPivot) {\n            var cnt = this._defs.length;\n            if (cnt == 0)\n                return;\n            var ox = this._owner.x;\n            var oy = this._owner.y;\n            for (var i = 0; i < cnt; i++) {\n                var info = this._defs[i];\n                switch (info.type) {\n                    case fgui.RelationType.Center_Center:\n                        this._owner.x -= (0.5 - (applyPivot ? this._owner.pivotX : 0)) * dWidth;\n                        break;\n                    case fgui.RelationType.Right_Center:\n                    case fgui.RelationType.Right_Left:\n                    case fgui.RelationType.Right_Right:\n                        this._owner.x -= (1 - (applyPivot ? this._owner.pivotX : 0)) * dWidth;\n                        break;\n                    case fgui.RelationType.Middle_Middle:\n                        this._owner.y -= (0.5 - (applyPivot ? this._owner.pivotY : 0)) * dHeight;\n                        break;\n                    case fgui.RelationType.Bottom_Middle:\n                    case fgui.RelationType.Bottom_Top:\n                    case fgui.RelationType.Bottom_Bottom:\n                        this._owner.y -= (1 - (applyPivot ? this._owner.pivotY : 0)) * dHeight;\n                        break;\n                }\n            }\n            if (ox != this._owner.x || oy != this._owner.y) {\n                ox = this._owner.x - ox;\n                oy = this._owner.y - oy;\n                this._owner.updateGearFromRelations(1, ox, oy);\n                if (this._owner.parent && this._owner.parent._transitions.length > 0) {\n                    cnt = this._owner.parent._transitions.length;\n                    for (var j = 0; j < cnt; j++) {\n                        var trans = this._owner.parent._transitions[j];\n                        trans.updateFromRelations(this._owner.id, ox, oy);\n                    }\n                }\n            }\n        }\n        applyOnXYChanged(info, dx, dy) {\n            var tmp;\n            switch (info.type) {\n                case fgui.RelationType.Left_Left:\n                case fgui.RelationType.Left_Center:\n                case fgui.RelationType.Left_Right:\n                case fgui.RelationType.Center_Center:\n                case fgui.RelationType.Right_Left:\n                case fgui.RelationType.Right_Center:\n                case fgui.RelationType.Right_Right:\n                    this._owner.x += dx;\n                    break;\n                case fgui.RelationType.Top_Top:\n                case fgui.RelationType.Top_Middle:\n                case fgui.RelationType.Top_Bottom:\n                case fgui.RelationType.Middle_Middle:\n                case fgui.RelationType.Bottom_Top:\n                case fgui.RelationType.Bottom_Middle:\n                case fgui.RelationType.Bottom_Bottom:\n                    this._owner.y += dy;\n                    break;\n                case fgui.RelationType.Width:\n                case fgui.RelationType.Height:\n                    break;\n                case fgui.RelationType.LeftExt_Left:\n                case fgui.RelationType.LeftExt_Right:\n                    if (this._owner != this._target.parent) {\n                        tmp = this._owner.xMin;\n                        this._owner.width = this._owner._rawWidth - dx;\n                        this._owner.xMin = tmp + dx;\n                    }\n                    else\n                        this._owner.width = this._owner._rawWidth - dx;\n                    break;\n                case fgui.RelationType.RightExt_Left:\n                case fgui.RelationType.RightExt_Right:\n                    if (this._owner != this._target.parent) {\n                        tmp = this._owner.xMin;\n                        this._owner.width = this._owner._rawWidth + dx;\n                        this._owner.xMin = tmp;\n                    }\n                    else\n                        this._owner.width = this._owner._rawWidth + dx;\n                    break;\n                case fgui.RelationType.TopExt_Top:\n                case fgui.RelationType.TopExt_Bottom:\n                    if (this._owner != this._target.parent) {\n                        tmp = this._owner.yMin;\n                        this._owner.height = this._owner._rawHeight - dy;\n                        this._owner.yMin = tmp + dy;\n                    }\n                    else\n                        this._owner.height = this._owner._rawHeight - dy;\n                    break;\n                case fgui.RelationType.BottomExt_Top:\n                case fgui.RelationType.BottomExt_Bottom:\n                    if (this._owner != this._target.parent) {\n                        tmp = this._owner.yMin;\n                        this._owner.height = this._owner._rawHeight + dy;\n                        this._owner.yMin = tmp;\n                    }\n                    else\n                        this._owner.height = this._owner._rawHeight + dy;\n                    break;\n            }\n        }\n        applyOnSizeChanged(info) {\n            var pos = 0, pivot = 0, delta = 0;\n            var v, tmp;\n            if (info.axis == 0) {\n                if (this._target != this._owner.parent) {\n                    pos = this._target.x;\n                    if (this._target.pivotAsAnchor)\n                        pivot = this._target.pivotX;\n                }\n                if (info.percent) {\n                    if (this._targetWidth != 0)\n                        delta = this._target._width / this._targetWidth;\n                }\n                else\n                    delta = this._target._width - this._targetWidth;\n            }\n            else {\n                if (this._target != this._owner.parent) {\n                    pos = this._target.y;\n                    if (this._target.pivotAsAnchor)\n                        pivot = this._target.pivotY;\n                }\n                if (info.percent) {\n                    if (this._targetHeight != 0)\n                        delta = this._target._height / this._targetHeight;\n                }\n                else\n                    delta = this._target._height - this._targetHeight;\n            }\n            switch (info.type) {\n                case fgui.RelationType.Left_Left:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin - pos) * delta;\n                    else if (pivot != 0)\n                        this._owner.x += delta * (-pivot);\n                    break;\n                case fgui.RelationType.Left_Center:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin - pos) * delta;\n                    else\n                        this._owner.x += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Left_Right:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin - pos) * delta;\n                    else\n                        this._owner.x += delta * (1 - pivot);\n                    break;\n                case fgui.RelationType.Center_Center:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth * 0.5 - pos) * delta - this._owner._rawWidth * 0.5;\n                    else\n                        this._owner.x += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Right_Left:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;\n                    else if (pivot != 0)\n                        this._owner.x += delta * (-pivot);\n                    break;\n                case fgui.RelationType.Right_Center:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;\n                    else\n                        this._owner.x += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Right_Right:\n                    if (info.percent)\n                        this._owner.xMin = pos + (this._owner.xMin + this._owner._rawWidth - pos) * delta - this._owner._rawWidth;\n                    else\n                        this._owner.x += delta * (1 - pivot);\n                    break;\n                case fgui.RelationType.Top_Top:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin - pos) * delta;\n                    else if (pivot != 0)\n                        this._owner.y += delta * (-pivot);\n                    break;\n                case fgui.RelationType.Top_Middle:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin - pos) * delta;\n                    else\n                        this._owner.y += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Top_Bottom:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin - pos) * delta;\n                    else\n                        this._owner.y += delta * (1 - pivot);\n                    break;\n                case fgui.RelationType.Middle_Middle:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight * 0.5 - pos) * delta - this._owner._rawHeight * 0.5;\n                    else\n                        this._owner.y += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Bottom_Top:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;\n                    else if (pivot != 0)\n                        this._owner.y += delta * (-pivot);\n                    break;\n                case fgui.RelationType.Bottom_Middle:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;\n                    else\n                        this._owner.y += delta * (0.5 - pivot);\n                    break;\n                case fgui.RelationType.Bottom_Bottom:\n                    if (info.percent)\n                        this._owner.yMin = pos + (this._owner.yMin + this._owner._rawHeight - pos) * delta - this._owner._rawHeight;\n                    else\n                        this._owner.y += delta * (1 - pivot);\n                    break;\n                case fgui.RelationType.Width:\n                    if (this._owner._underConstruct && this._owner == this._target.parent)\n                        v = this._owner.sourceWidth - this._target.initWidth;\n                    else\n                        v = this._owner._rawWidth - this._targetWidth;\n                    if (info.percent)\n                        v = v * delta;\n                    if (this._target == this._owner.parent) {\n                        if (this._owner.pivotAsAnchor) {\n                            tmp = this._owner.xMin;\n                            this._owner.setSize(this._target._width + v, this._owner._rawHeight, true);\n                            this._owner.xMin = tmp;\n                        }\n                        else\n                            this._owner.setSize(this._target._width + v, this._owner._rawHeight, true);\n                    }\n                    else\n                        this._owner.width = this._target._width + v;\n                    break;\n                case fgui.RelationType.Height:\n                    if (this._owner._underConstruct && this._owner == this._target.parent)\n                        v = this._owner.sourceHeight - this._target.initHeight;\n                    else\n                        v = this._owner._rawHeight - this._targetHeight;\n                    if (info.percent)\n                        v = v * delta;\n                    if (this._target == this._owner.parent) {\n                        if (this._owner.pivotAsAnchor) {\n                            tmp = this._owner.yMin;\n                            this._owner.setSize(this._owner._rawWidth, this._target._height + v, true);\n                            this._owner.yMin = tmp;\n                        }\n                        else\n                            this._owner.setSize(this._owner._rawWidth, this._target._height + v, true);\n                    }\n                    else\n                        this._owner.height = this._target._height + v;\n                    break;\n                case fgui.RelationType.LeftExt_Left:\n                    tmp = this._owner.xMin;\n                    if (info.percent)\n                        v = pos + (tmp - pos) * delta - tmp;\n                    else\n                        v = delta * (-pivot);\n                    this._owner.width = this._owner._rawWidth - v;\n                    this._owner.xMin = tmp + v;\n                    break;\n                case fgui.RelationType.LeftExt_Right:\n                    tmp = this._owner.xMin;\n                    if (info.percent)\n                        v = pos + (tmp - pos) * delta - tmp;\n                    else\n                        v = delta * (1 - pivot);\n                    this._owner.width = this._owner._rawWidth - v;\n                    this._owner.xMin = tmp + v;\n                    break;\n                case fgui.RelationType.RightExt_Left:\n                    tmp = this._owner.xMin;\n                    if (info.percent)\n                        v = pos + (tmp + this._owner._rawWidth - pos) * delta - (tmp + this._owner._rawWidth);\n                    else\n                        v = delta * (-pivot);\n                    this._owner.width = this._owner._rawWidth + v;\n                    this._owner.xMin = tmp;\n                    break;\n                case fgui.RelationType.RightExt_Right:\n                    tmp = this._owner.xMin;\n                    if (info.percent) {\n                        if (this._owner == this._target.parent) {\n                            if (this._owner._underConstruct)\n                                this._owner.width = pos + this._target._width - this._target._width * pivot +\n                                    (this._owner.sourceWidth - pos - this._target.initWidth + this._target.initWidth * pivot) * delta;\n                            else\n                                this._owner.width = pos + (this._owner._rawWidth - pos) * delta;\n                        }\n                        else {\n                            v = pos + (tmp + this._owner._rawWidth - pos) * delta - (tmp + this._owner._rawWidth);\n                            this._owner.width = this._owner._rawWidth + v;\n                            this._owner.xMin = tmp;\n                        }\n                    }\n                    else {\n                        if (this._owner == this._target.parent) {\n                            if (this._owner._underConstruct)\n                                this._owner.width = this._owner.sourceWidth + (this._target._width - this._target.initWidth) * (1 - pivot);\n                            else\n                                this._owner.width = this._owner._rawWidth + delta * (1 - pivot);\n                        }\n                        else {\n                            v = delta * (1 - pivot);\n                            this._owner.width = this._owner._rawWidth + v;\n                            this._owner.xMin = tmp;\n                        }\n                    }\n                    break;\n                case fgui.RelationType.TopExt_Top:\n                    tmp = this._owner.yMin;\n                    if (info.percent)\n                        v = pos + (tmp - pos) * delta - tmp;\n                    else\n                        v = delta * (-pivot);\n                    this._owner.height = this._owner._rawHeight - v;\n                    this._owner.yMin = tmp + v;\n                    break;\n                case fgui.RelationType.TopExt_Bottom:\n                    tmp = this._owner.yMin;\n                    if (info.percent)\n                        v = pos + (tmp - pos) * delta - tmp;\n                    else\n                        v = delta * (1 - pivot);\n                    this._owner.height = this._owner._rawHeight - v;\n                    this._owner.yMin = tmp + v;\n                    break;\n                case fgui.RelationType.BottomExt_Top:\n                    tmp = this._owner.yMin;\n                    if (info.percent)\n                        v = pos + (tmp + this._owner._rawHeight - pos) * delta - (tmp + this._owner._rawHeight);\n                    else\n                        v = delta * (-pivot);\n                    this._owner.height = this._owner._rawHeight + v;\n                    this._owner.yMin = tmp;\n                    break;\n                case fgui.RelationType.BottomExt_Bottom:\n                    tmp = this._owner.yMin;\n                    if (info.percent) {\n                        if (this._owner == this._target.parent) {\n                            if (this._owner._underConstruct)\n                                this._owner.height = pos + this._target._height - this._target._height * pivot +\n                                    (this._owner.sourceHeight - pos - this._target.initHeight + this._target.initHeight * pivot) * delta;\n                            else\n                                this._owner.height = pos + (this._owner._rawHeight - pos) * delta;\n                        }\n                        else {\n                            v = pos + (tmp + this._owner._rawHeight - pos) * delta - (tmp + this._owner._rawHeight);\n                            this._owner.height = this._owner._rawHeight + v;\n                            this._owner.yMin = tmp;\n                        }\n                    }\n                    else {\n                        if (this._owner == this._target.parent) {\n                            if (this._owner._underConstruct)\n                                this._owner.height = this._owner.sourceHeight + (this._target._height - this._target.initHeight) * (1 - pivot);\n                            else\n                                this._owner.height = this._owner._rawHeight + delta * (1 - pivot);\n                        }\n                        else {\n                            v = delta * (1 - pivot);\n                            this._owner.height = this._owner._rawHeight + v;\n                            this._owner.yMin = tmp;\n                        }\n                    }\n                    break;\n            }\n        }\n        addRefTarget() {\n            if (this._target != this._owner.parent)\n                this._target.on(fgui.DisplayObjectEvent.XY_CHANGED, this.__targetXYChanged, this);\n            this._target.on(fgui.DisplayObjectEvent.SIZE_CHANGED, this.__targetSizeChanged, this);\n            this._targetX = this._target.x;\n            this._targetY = this._target.y;\n            this._targetWidth = this._target._width;\n            this._targetHeight = this._target._height;\n        }\n        releaseRefTarget() {\n            if (this._target.displayObject == null)\n                return;\n            this._target.off(fgui.DisplayObjectEvent.XY_CHANGED, this.__targetXYChanged, this);\n            this._target.off(fgui.DisplayObjectEvent.SIZE_CHANGED, this.__targetSizeChanged, this);\n        }\n        __targetXYChanged() {\n            if (this._owner.relations.handling || this._owner.group && this._owner.group._updating) {\n                this._targetX = this._target.x;\n                this._targetY = this._target.y;\n                return;\n            }\n            this._owner.relations.handling = this._target;\n            var ox = this._owner.x;\n            var oy = this._owner.y;\n            var dx = this._target.x - this._targetX;\n            var dy = this._target.y - this._targetY;\n            var cnt = this._defs.length;\n            for (var i = 0; i < cnt; i++) {\n                this.applyOnXYChanged(this._defs[i], dx, dy);\n            }\n            this._targetX = this._target.x;\n            this._targetY = this._target.y;\n            if (ox != this._owner.x || oy != this._owner.y) {\n                ox = this._owner.x - ox;\n                oy = this._owner.y - oy;\n                this._owner.updateGearFromRelations(1, ox, oy);\n                if (this._owner.parent && this._owner.parent._transitions.length > 0) {\n                    cnt = this._owner.parent._transitions.length;\n                    for (var j = 0; j < cnt; j++) {\n                        var trans = this._owner.parent._transitions[j];\n                        trans.updateFromRelations(this._owner.id, ox, oy);\n                    }\n                }\n            }\n            this._owner.relations.handling = null;\n        }\n        __targetSizeChanged() {\n            if (this._owner.relations.handling) {\n                this._targetWidth = this._target._width;\n                this._targetHeight = this._target._height;\n                return;\n            }\n            this._owner.relations.handling = this._target;\n            var ox = this._owner.x;\n            var oy = this._owner.y;\n            var ow = this._owner._rawWidth;\n            var oh = this._owner._rawHeight;\n            var cnt = this._defs.length;\n            for (var i = 0; i < cnt; i++) {\n                this.applyOnSizeChanged(this._defs[i]);\n            }\n            this._targetWidth = this._target._width;\n            this._targetHeight = this._target._height;\n            if (ox != this._owner.x || oy != this._owner.y) {\n                ox = this._owner.x - ox;\n                oy = this._owner.y - oy;\n                this._owner.updateGearFromRelations(1, ox, oy);\n                if (this._owner.parent && this._owner.parent._transitions.length > 0) {\n                    cnt = this._owner.parent._transitions.length;\n                    for (var j = 0; j < cnt; j++) {\n                        var trans = this._owner.parent._transitions[j];\n                        trans.updateFromRelations(this._owner.id, ox, oy);\n                    }\n                }\n            }\n            if (ow != this._owner._rawWidth || oh != this._owner._rawHeight) {\n                ow = this._owner._rawWidth - ow;\n                oh = this._owner._rawHeight - oh;\n                this._owner.updateGearFromRelations(2, ow, oh);\n            }\n            this._owner.relations.handling = null;\n        }\n    }\n    fgui.RelationItem = RelationItem;\n    class RelationDef {\n        constructor() {\n        }\n        copy(source) {\n            this.percent = source.percent;\n            this.type = source.type;\n            this.axis = source.axis;\n        }\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Relations {\n        constructor(owner) {\n            this._owner = owner;\n            this._items = [];\n        }\n        add(target, relationType, usePercent) {\n            var length = this._items.length;\n            for (var i = 0; i < length; i++) {\n                var item = this._items[i];\n                if (item.target == target) {\n                    item.add(relationType, usePercent);\n                    return;\n                }\n            }\n            var newItem = new fgui.RelationItem(this._owner);\n            newItem.target = target;\n            newItem.add(relationType, usePercent);\n            this._items.push(newItem);\n        }\n        remove(target, relationType) {\n            relationType = relationType || 0;\n            var cnt = this._items.length;\n            var i = 0;\n            while (i < cnt) {\n                var item = this._items[i];\n                if (item.target == target) {\n                    item.remove(relationType);\n                    if (item.isEmpty) {\n                        item.dispose();\n                        this._items.splice(i, 1);\n                        cnt--;\n                    }\n                    else\n                        i++;\n                }\n                else\n                    i++;\n            }\n        }\n        contains(target) {\n            var length = this._items.length;\n            for (var i = 0; i < length; i++) {\n                var item = this._items[i];\n                if (item.target == target)\n                    return true;\n            }\n            return false;\n        }\n        clearFor(target) {\n            var cnt = this._items.length;\n            var i = 0;\n            while (i < cnt) {\n                var item = this._items[i];\n                if (item.target == target) {\n                    item.dispose();\n                    this._items.splice(i, 1);\n                    cnt--;\n                }\n                else\n                    i++;\n            }\n        }\n        clearAll() {\n            var length = this._items.length;\n            for (var i = 0; i < length; i++) {\n                var item = this._items[i];\n                item.dispose();\n            }\n            this._items.length = 0;\n        }\n        copyFrom(source) {\n            this.clearAll();\n            var arr = source._items;\n            var length = arr.length;\n            for (var i = 0; i < length; i++) {\n                var ri = arr[i];\n                var item = new fgui.RelationItem(this._owner);\n                item.copy(ri);\n                this._items.push(item);\n            }\n        }\n        dispose() {\n            this.clearAll();\n        }\n        onOwnerSizeChanged(dWidth, dHeight, applyPivot) {\n            if (this._items.length == 0)\n                return;\n            var length = this._items.length;\n            for (var i = 0; i < length; i++) {\n                var item = this._items[i];\n                item.applyOnSelfResized(dWidth, dHeight, applyPivot);\n            }\n        }\n        get empty() {\n            return this._items.length == 0;\n        }\n        setup(buffer, parentToChild) {\n            var cnt = buffer.readByte();\n            var target;\n            for (var i = 0; i < cnt; i++) {\n                var targetIndex = buffer.readShort();\n                if (targetIndex == -1)\n                    target = this._owner.parent;\n                else if (parentToChild)\n                    target = (this._owner).getChildAt(targetIndex);\n                else\n                    target = this._owner.parent.getChildAt(targetIndex);\n                var newItem = new fgui.RelationItem(this._owner);\n                newItem.target = target;\n                this._items.push(newItem);\n                var cnt2 = buffer.readByte();\n                for (var j = 0; j < cnt2; j++) {\n                    var rt = buffer.readByte();\n                    var usePercent = buffer.readBool();\n                    newItem.internalAdd(rt, usePercent);\n                }\n            }\n        }\n    }\n    fgui.Relations = Relations;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_vec2 = new THREE.Vector2();\n    var s_rect = new fgui.Rect();\n    var s_endPos = new THREE.Vector2();\n    var s_oldChange = new THREE.Vector2();\n    var s_gestureFlag = 0;\n    const TWEEN_TIME_GO = 0.5;\n    const TWEEN_TIME_DEFAULT = 0.3;\n    const PULL_RATIO = 0.5;\n    class ScrollPane {\n        constructor(owner) {\n            this._owner = owner;\n            this._maskContainer = new fgui.DisplayObject();\n            this._owner.displayObject.addChild(this._maskContainer);\n            this._container = this._owner._container;\n            this._container.setPosition(0, 0);\n            this._maskContainer.addChild(this._container);\n            this._mouseWheelEnabled = true;\n            this._xPos = 0;\n            this._yPos = 0;\n            this._aniFlag = 0;\n            this._tweening = 0;\n            this._loop = 0;\n            this._footerLockedSize = 0;\n            this._headerLockedSize = 0;\n            this._scrollBarMargin = new fgui.Margin();\n            this._viewSize = new THREE.Vector2();\n            this._contentSize = new THREE.Vector2();\n            this._pageSize = new THREE.Vector2(1, 1);\n            this._overlapSize = new THREE.Vector2();\n            this._tweenTime = new THREE.Vector2();\n            this._tweenStart = new THREE.Vector2();\n            this._tweenDuration = new THREE.Vector2();\n            this._tweenChange = new THREE.Vector2();\n            this._velocity = new THREE.Vector2();\n            this._containerPos = new THREE.Vector2();\n            this._beginTouchPos = new THREE.Vector2();\n            this._lastTouchPos = new THREE.Vector2();\n            this._lastTouchGlobalPos = new THREE.Vector2();\n            this._scrollStep = fgui.UIConfig.defaultScrollStep;\n            this._decelerationRate = fgui.UIConfig.defaultScrollDecelerationRate;\n            this._owner.on(fgui.InteractiveEvents.Down, this.__touchBegin, this);\n            this._owner.on(fgui.InteractiveEvents.Move, this.__touchMove, this);\n            this._owner.on(fgui.InteractiveEvents.Up, this.__touchEnd, this);\n            this._owner.on(fgui.DisplayObjectEvent.MOUSE_WHEEL, this.__mouseWheel, this);\n        }\n        setup(buffer) {\n            this._scrollType = buffer.readByte();\n            var scrollBarDisplay = buffer.readByte();\n            var flags = buffer.readInt();\n            if (buffer.readBool()) {\n                this._scrollBarMargin.top = buffer.readInt();\n                this._scrollBarMargin.bottom = buffer.readInt();\n                this._scrollBarMargin.left = buffer.readInt();\n                this._scrollBarMargin.right = buffer.readInt();\n            }\n            var vtScrollBarRes = buffer.readS();\n            var hzScrollBarRes = buffer.readS();\n            var headerRes = buffer.readS();\n            var footerRes = buffer.readS();\n            this._displayOnLeft = (flags & 1) != 0;\n            this._snapToItem = (flags & 2) != 0;\n            this._displayInDemand = (flags & 4) != 0;\n            this._pageMode = (flags & 8) != 0;\n            if (flags & 16)\n                this._touchEffect = true;\n            else if (flags & 32)\n                this._touchEffect = false;\n            else\n                this._touchEffect = fgui.UIConfig.defaultScrollTouchEffect;\n            if (flags & 64)\n                this._bouncebackEffect = true;\n            else if (flags & 128)\n                this._bouncebackEffect = false;\n            else\n                this._bouncebackEffect = fgui.UIConfig.defaultScrollBounceEffect;\n            this._inertiaDisabled = (flags & 256) != 0;\n            if ((flags & 512) == 0)\n                this._maskContainer.clipRect = new fgui.Rect();\n            this._floating = (flags & 1024) != 0;\n            if (scrollBarDisplay == fgui.ScrollBarDisplayType.Default)\n                scrollBarDisplay = fgui.UIConfig.defaultScrollBarDisplay;\n            if (scrollBarDisplay != fgui.ScrollBarDisplayType.Hidden) {\n                if (this._scrollType == fgui.ScrollType.Both || this._scrollType == fgui.ScrollType.Vertical) {\n                    var res = vtScrollBarRes ? vtScrollBarRes : fgui.UIConfig.verticalScrollBar;\n                    if (res) {\n                        this._vtScrollBar = (fgui.UIPackage.createObjectFromURL(res));\n                        if (!this._vtScrollBar)\n                            throw \"cannot create scrollbar} from \" + res;\n                        this._vtScrollBar.setScrollPane(this, true);\n                        this._owner.displayObject.addChild(this._vtScrollBar.displayObject);\n                    }\n                }\n                if (this._scrollType == fgui.ScrollType.Both || this._scrollType == fgui.ScrollType.Horizontal) {\n                    res = hzScrollBarRes ? hzScrollBarRes : fgui.UIConfig.horizontalScrollBar;\n                    if (res) {\n                        this._hzScrollBar = (fgui.UIPackage.createObjectFromURL(res));\n                        if (!this._hzScrollBar)\n                            throw \"cannot create scrollbar} from \" + res;\n                        this._hzScrollBar.setScrollPane(this, false);\n                        this._owner.displayObject.addChild(this._hzScrollBar.displayObject);\n                    }\n                }\n                this._scrollBarDisplayAuto = scrollBarDisplay == fgui.ScrollBarDisplayType.Auto;\n                if (this._scrollBarDisplayAuto) {\n                    if (this._vtScrollBar)\n                        this._vtScrollBar.displayObject.visible = false;\n                    if (this._hzScrollBar)\n                        this._hzScrollBar.displayObject.visible = false;\n                }\n            }\n            else\n                this._mouseWheelEnabled = false;\n            if (headerRes) {\n                this._header = fgui.UIPackage.createObjectFromURL(headerRes);\n                if (!this._header)\n                    throw new Error(\"cannot create scrollPane header from \" + headerRes);\n            }\n            if (footerRes) {\n                this._footer = fgui.UIPackage.createObjectFromURL(footerRes);\n                if (!this._footer)\n                    throw new Error(\"cannot create scrollPane footer from \" + footerRes);\n            }\n            if (this._header || this._footer)\n                this._refreshBarAxis = (this._scrollType == fgui.ScrollType.Both || this._scrollType == fgui.ScrollType.Vertical) ? \"y\" : \"x\";\n            this.setSize(this.owner.width, this.owner.height);\n        }\n        dispose() {\n            if (this._tweening != 0)\n                fgui.Timers.remove(this.tweenUpdate, this);\n            this._pageController = null;\n            if (this._hzScrollBar)\n                this._hzScrollBar.dispose();\n            if (this._vtScrollBar)\n                this._vtScrollBar.dispose();\n            if (this._header)\n                this._header.dispose();\n            if (this._footer)\n                this._footer.dispose();\n        }\n        get owner() {\n            return this._owner;\n        }\n        get hzScrollBar() {\n            return this._hzScrollBar;\n        }\n        get vtScrollBar() {\n            return this._vtScrollBar;\n        }\n        get header() {\n            return this._header;\n        }\n        get footer() {\n            return this._footer;\n        }\n        get bouncebackEffect() {\n            return this._bouncebackEffect;\n        }\n        set bouncebackEffect(sc) {\n            this._bouncebackEffect = sc;\n        }\n        get touchEffect() {\n            return this._touchEffect;\n        }\n        set touchEffect(sc) {\n            this._touchEffect = sc;\n        }\n        set scrollStep(val) {\n            this._scrollStep = val;\n            if (this._scrollStep == 0)\n                this._scrollStep = fgui.UIConfig.defaultScrollStep;\n        }\n        get scrollStep() {\n            return this._scrollStep;\n        }\n        get snapToItem() {\n            return this._snapToItem;\n        }\n        set snapToItem(value) {\n            this._snapToItem = value;\n        }\n        get mouseWheelEnabled() {\n            return this._mouseWheelEnabled;\n        }\n        set mouseWheelEnabled(value) {\n            this._mouseWheelEnabled = value;\n        }\n        get decelerationRate() {\n            return this._decelerationRate;\n        }\n        set decelerationRate(value) {\n            this._decelerationRate = value;\n        }\n        get isDragged() {\n            return this._dragged;\n        }\n        get percX() {\n            return this._overlapSize.x == 0 ? 0 : this._xPos / this._overlapSize.x;\n        }\n        set percX(value) {\n            this.setPercX(value, false);\n        }\n        setPercX(value, ani) {\n            this._owner.ensureBoundsCorrect();\n            this.setPosX(this._overlapSize.x * fgui.clamp01(value), ani);\n        }\n        get percY() {\n            return this._overlapSize.y == 0 ? 0 : this._yPos / this._overlapSize.y;\n        }\n        set percY(value) {\n            this.setPercY(value, false);\n        }\n        setPercY(value, ani) {\n            this._owner.ensureBoundsCorrect();\n            this.setPosY(this._overlapSize.y * fgui.clamp01(value), ani);\n        }\n        get posX() {\n            return this._xPos;\n        }\n        set posX(value) {\n            this.setPosX(value, false);\n        }\n        setPosX(value, ani) {\n            this._owner.ensureBoundsCorrect();\n            if (this._loop == 1)\n                value = this.loopCheckingNewPos(value, \"x\");\n            value = fgui.clamp(value, 0, this._overlapSize.x);\n            if (value != this._xPos) {\n                this._xPos = value;\n                this.posChanged(ani);\n            }\n        }\n        get posY() {\n            return this._yPos;\n        }\n        set posY(value) {\n            this.setPosY(value, false);\n        }\n        setPosY(value, ani) {\n            this._owner.ensureBoundsCorrect();\n            if (this._loop == 1)\n                value = this.loopCheckingNewPos(value, \"y\");\n            value = fgui.clamp(value, 0, this._overlapSize.y);\n            if (value != this._yPos) {\n                this._yPos = value;\n                this.posChanged(ani);\n            }\n        }\n        get contentWidth() {\n            return this._contentSize.x;\n        }\n        get contentHeight() {\n            return this._contentSize.y;\n        }\n        get viewWidth() {\n            return this._viewSize.x;\n        }\n        set viewWidth(value) {\n            value = value + this._owner.margin.left + this._owner.margin.right;\n            if (this._vtScrollBar && !this._floating)\n                value += this._vtScrollBar.width;\n            this._owner.width = value;\n        }\n        get viewHeight() {\n            return this._viewSize.y;\n        }\n        set viewHeight(value) {\n            value = value + this._owner.margin.top + this._owner.margin.bottom;\n            if (this._hzScrollBar && !this._floating)\n                value += this._hzScrollBar.height;\n            this._owner.height = value;\n        }\n        get currentPageX() {\n            if (!this._pageMode)\n                return 0;\n            var page = Math.floor(this._xPos / this._pageSize.x);\n            if (this._xPos - page * this._pageSize.x > this._pageSize.x * 0.5)\n                page++;\n            return page;\n        }\n        set currentPageX(value) {\n            this.setCurrentPageX(value, false);\n        }\n        get currentPageY() {\n            if (!this._pageMode)\n                return 0;\n            var page = Math.floor(this._yPos / this._pageSize.y);\n            if (this._yPos - page * this._pageSize.y > this._pageSize.y * 0.5)\n                page++;\n            return page;\n        }\n        set currentPageY(value) {\n            this.setCurrentPageY(value, false);\n        }\n        setCurrentPageX(value, ani) {\n            if (!this._pageMode)\n                return;\n            this._owner.ensureBoundsCorrect();\n            if (this._overlapSize.x > 0)\n                this.setPosX(value * this._pageSize.x, ani);\n        }\n        setCurrentPageY(value, ani) {\n            if (!this._pageMode)\n                return;\n            this._owner.ensureBoundsCorrect();\n            if (this._overlapSize.y > 0)\n                this.setPosY(value * this._pageSize.y, ani);\n        }\n        get isBottomMost() {\n            return this._yPos == this._overlapSize.y || this._overlapSize.y == 0;\n        }\n        get isRightMost() {\n            return this._xPos == this._overlapSize.x || this._overlapSize.x == 0;\n        }\n        get pageController() {\n            return this._pageController;\n        }\n        set pageController(value) {\n            this._pageController = value;\n        }\n        get scrollingPosX() {\n            return fgui.clamp(-this._container.x, 0, this._overlapSize.x);\n        }\n        get scrollingPosY() {\n            return fgui.clamp(-this._container.y, 0, this._overlapSize.y);\n        }\n        scrollTop(ani) {\n            this.setPercY(0, ani);\n        }\n        scrollBottom(ani) {\n            this.setPercY(1, ani);\n        }\n        scrollUp(ratio = 1, ani) {\n            if (this._pageMode)\n                this.setPosY(this._yPos - this._pageSize.y * ratio, ani);\n            else\n                this.setPosY(this._yPos - this._scrollStep * ratio, ani);\n            ;\n        }\n        scrollDown(ratio = 1, ani) {\n            if (this._pageMode)\n                this.setPosY(this._yPos + this._pageSize.y * ratio, ani);\n            else\n                this.setPosY(this._yPos + this._scrollStep * ratio, ani);\n        }\n        scrollLeft(ratio = 1, ani) {\n            if (this._pageMode)\n                this.setPosX(this._xPos - this._pageSize.x * ratio, ani);\n            else\n                this.setPosX(this._xPos - this._scrollStep * ratio, ani);\n        }\n        scrollRight(ratio = 1, ani) {\n            if (this._pageMode)\n                this.setPosX(this._xPos + this._pageSize.x * ratio, ani);\n            else\n                this.setPosX(this._xPos + this._scrollStep * ratio, ani);\n        }\n        scrollToView(target, ani, setFirst) {\n            this._owner.ensureBoundsCorrect();\n            if (this._needRefresh)\n                this.refresh();\n            var rect;\n            if (target instanceof fgui.GObject) {\n                if (target.parent != this._owner) {\n                    target.parent.localToGlobalRect(target.x, target.y, target.width, target.height, s_rect);\n                    rect = this._owner.globalToLocalRect(s_rect.x, s_rect.y, s_rect.width, s_rect.height, s_rect);\n                }\n                else {\n                    rect = s_rect;\n                    rect.set(target.x, target.y, target.width, target.height);\n                }\n            }\n            else\n                rect = (target);\n            if (this._overlapSize.y > 0) {\n                var bottom = this._yPos + this._viewSize.y;\n                if (setFirst || rect.y <= this._yPos || rect.height >= this._viewSize.y) {\n                    if (this._pageMode)\n                        this.setPosY(Math.floor(rect.y / this._pageSize.y) * this._pageSize.y, ani);\n                    else\n                        this.setPosY(rect.y, ani);\n                }\n                else if (rect.y + rect.height > bottom) {\n                    if (this._pageMode)\n                        this.setPosY(Math.floor(rect.y / this._pageSize.y) * this._pageSize.y, ani);\n                    else if (rect.height <= this._viewSize.y / 2)\n                        this.setPosY(rect.y + rect.height * 2 - this._viewSize.y, ani);\n                    else\n                        this.setPosY(rect.y + rect.height - this._viewSize.y, ani);\n                }\n            }\n            if (this._overlapSize.x > 0) {\n                var right = this._xPos + this._viewSize.x;\n                if (setFirst || rect.x <= this._xPos || rect.width >= this._viewSize.x) {\n                    if (this._pageMode)\n                        this.setPosX(Math.floor(rect.x / this._pageSize.x) * this._pageSize.x, ani);\n                    else\n                        this.setPosX(rect.x, ani);\n                }\n                else if (rect.x + rect.width > right) {\n                    if (this._pageMode)\n                        this.setPosX(Math.floor(rect.x / this._pageSize.x) * this._pageSize.x, ani);\n                    else if (rect.width <= this._viewSize.x / 2)\n                        this.setPosX(rect.x + rect.width * 2 - this._viewSize.x, ani);\n                    else\n                        this.setPosX(rect.x + rect.width - this._viewSize.x, ani);\n                }\n            }\n            if (!ani && this._needRefresh)\n                this.refresh();\n        }\n        isChildInView(obj) {\n            if (this._overlapSize.y > 0) {\n                var dist = obj.y + this._container.y;\n                if (dist < -obj.height || dist > this._viewSize.y)\n                    return false;\n            }\n            if (this._overlapSize.x > 0) {\n                dist = obj.x + this._container.x;\n                if (dist < -obj.width || dist > this._viewSize.x)\n                    return false;\n            }\n            return true;\n        }\n        cancelDragging() {\n            fgui.Stage.removeTouchMonitor(this._owner.displayObject);\n            if (ScrollPane.draggingPane == this)\n                ScrollPane.draggingPane = null;\n            s_gestureFlag = 0;\n            this._dragged = false;\n        }\n        lockHeader(size) {\n            if (this._headerLockedSize == size)\n                return;\n            this._headerLockedSize = size;\n            if (!this._refreshEventDispatching && this._container[this._refreshBarAxis] >= 0) {\n                this._tweenStart.set(this._container.x, this._container.y);\n                this._tweenChange.set(0, 0);\n                this._tweenChange[this._refreshBarAxis] = this._headerLockedSize - this._tweenStart[this._refreshBarAxis];\n                this._tweenDuration.set(TWEEN_TIME_DEFAULT, TWEEN_TIME_DEFAULT);\n                this.startTween(2);\n            }\n        }\n        lockFooter(size) {\n            if (this._footerLockedSize == size)\n                return;\n            this._footerLockedSize = size;\n            if (!this._refreshEventDispatching && this._container[this._refreshBarAxis] <= -this._overlapSize[this._refreshBarAxis]) {\n                this._tweenStart.set(this._container.x, this._container.y);\n                this._tweenChange.set(0, 0);\n                var max = this._overlapSize[this._refreshBarAxis];\n                if (max == 0)\n                    max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);\n                else\n                    max += this._footerLockedSize;\n                this._tweenChange[this._refreshBarAxis] = -max - this._tweenStart[this._refreshBarAxis];\n                this._tweenDuration.set(TWEEN_TIME_DEFAULT, TWEEN_TIME_DEFAULT);\n                this.startTween(2);\n            }\n        }\n        onOwnerSizeChanged() {\n            this.setSize(this._owner.width, this._owner.height);\n            this.posChanged(false);\n        }\n        handleControllerChanged(c) {\n            if (this._pageController == c) {\n                if (this._scrollType == fgui.ScrollType.Horizontal)\n                    this.setCurrentPageX(c.selectedIndex, true);\n                else\n                    this.setCurrentPageY(c.selectedIndex, true);\n            }\n        }\n        updatePageController() {\n            if (this._pageController && !this._pageController.changing) {\n                var index;\n                if (this._scrollType == fgui.ScrollType.Horizontal)\n                    index = this.currentPageX;\n                else\n                    index = this.currentPageY;\n                if (index < this._pageController.pageCount) {\n                    var c = this._pageController;\n                    this._pageController = null;\n                    c.selectedIndex = index;\n                    this._pageController = c;\n                }\n            }\n        }\n        adjustMaskContainer() {\n            var mx, my;\n            if (this._displayOnLeft && this._vtScrollBar && !this._floating)\n                mx = Math.floor(this._owner.margin.left + this._vtScrollBar.width);\n            else\n                mx = Math.floor(this._owner.margin.left);\n            my = Math.floor(this._owner.margin.top);\n            this._maskContainer.setPosition(mx, my);\n            if (this._owner._alignOffset.x != 0 || this._owner._alignOffset.y != 0) {\n                if (this._alignContainer == null) {\n                    this._alignContainer = new fgui.DisplayObject();\n                    this._maskContainer.addChild(this._alignContainer);\n                    this._alignContainer.addChild(this._container);\n                }\n                this._alignContainer.setPosition(this._owner._alignOffset.x, this._owner._alignOffset.y);\n            }\n            else if (this._alignContainer) {\n                this._alignContainer.setPosition(0, 0);\n            }\n        }\n        setSize(aWidth, aHeight) {\n            this.adjustMaskContainer();\n            if (this._hzScrollBar) {\n                this._hzScrollBar.y = aHeight - this._hzScrollBar.height;\n                if (this._vtScrollBar) {\n                    this._hzScrollBar.width = aWidth - this._vtScrollBar.width - this._scrollBarMargin.left - this._scrollBarMargin.right;\n                    if (this._displayOnLeft)\n                        this._hzScrollBar.x = this._scrollBarMargin.left + this._vtScrollBar.width;\n                    else\n                        this._hzScrollBar.x = this._scrollBarMargin.left;\n                }\n                else {\n                    this._hzScrollBar.width = aWidth - this._scrollBarMargin.left - this._scrollBarMargin.right;\n                    this._hzScrollBar.x = this._scrollBarMargin.left;\n                }\n            }\n            if (this._vtScrollBar) {\n                if (!this._displayOnLeft)\n                    this._vtScrollBar.x = aWidth - this._vtScrollBar.width;\n                if (this._hzScrollBar)\n                    this._vtScrollBar.height = aHeight - this._hzScrollBar.height - this._scrollBarMargin.top - this._scrollBarMargin.bottom;\n                else\n                    this._vtScrollBar.height = aHeight - this._scrollBarMargin.top - this._scrollBarMargin.bottom;\n                this._vtScrollBar.y = this._scrollBarMargin.top;\n            }\n            this._viewSize.x = aWidth;\n            this._viewSize.y = aHeight;\n            if (this._hzScrollBar && !this._floating)\n                this._viewSize.y -= this._hzScrollBar.height;\n            if (this._vtScrollBar && !this._floating)\n                this._viewSize.x -= this._vtScrollBar.width;\n            this._viewSize.x -= (this._owner.margin.left + this._owner.margin.right);\n            this._viewSize.y -= (this._owner.margin.top + this._owner.margin.bottom);\n            this._viewSize.x = Math.max(1, this._viewSize.x);\n            this._viewSize.y = Math.max(1, this._viewSize.y);\n            this._pageSize.x = this._viewSize.x;\n            this._pageSize.y = this._viewSize.y;\n            this.handleSizeChanged();\n        }\n        setContentSize(aWidth, aHeight) {\n            if (this._contentSize.x == aWidth && this._contentSize.y == aHeight)\n                return;\n            this._contentSize.x = aWidth;\n            this._contentSize.y = aHeight;\n            this.handleSizeChanged();\n        }\n        changeContentSizeOnScrolling(deltaWidth, deltaHeight, deltaPosX, deltaPosY) {\n            var isRightmost = this._xPos == this._overlapSize.x;\n            var isBottom = this._yPos == this._overlapSize.y;\n            this._contentSize.x += deltaWidth;\n            this._contentSize.y += deltaHeight;\n            this.handleSizeChanged();\n            if (this._tweening == 1) {\n                if (deltaWidth != 0 && isRightmost && this._tweenChange.x < 0) {\n                    this._xPos = this._overlapSize.x;\n                    this._tweenChange.x = -this._xPos - this._tweenStart.x;\n                }\n                if (deltaHeight != 0 && isBottom && this._tweenChange.y < 0) {\n                    this._yPos = this._overlapSize.y;\n                    this._tweenChange.y = -this._yPos - this._tweenStart.y;\n                }\n            }\n            else if (this._tweening == 2) {\n                if (deltaPosX != 0) {\n                    this._container.x -= deltaPosX;\n                    this._tweenStart.x -= deltaPosX;\n                    this._xPos = -this._container.x;\n                }\n                if (deltaPosY != 0) {\n                    this._container.y -= deltaPosY;\n                    this._tweenStart.y -= deltaPosY;\n                    this._yPos = -this._container.y;\n                }\n            }\n            else if (this._dragged) {\n                if (deltaPosX != 0) {\n                    this._container.x -= deltaPosX;\n                    this._containerPos.x -= deltaPosX;\n                    this._xPos = -this._container.x;\n                }\n                if (deltaPosY != 0) {\n                    this._container.y -= deltaPosY;\n                    this._containerPos.y -= deltaPosY;\n                    this._yPos = -this._container.y;\n                }\n            }\n            else {\n                if (deltaWidth != 0 && isRightmost) {\n                    this._xPos = this._overlapSize.x;\n                    this._container.x = -this._xPos;\n                }\n                if (deltaHeight != 0 && isBottom) {\n                    this._yPos = this._overlapSize.y;\n                    this._container.y = -this._yPos;\n                }\n            }\n            if (this._pageMode)\n                this.updatePageController();\n        }\n        handleSizeChanged() {\n            if (this._displayInDemand) {\n                this._vScrollNone = this._contentSize.y <= this._viewSize.y;\n                this._hScrollNone = this._contentSize.x <= this._viewSize.x;\n            }\n            if (this._vtScrollBar) {\n                if (this._contentSize.y == 0)\n                    this._vtScrollBar.setDisplayPerc(0);\n                else\n                    this._vtScrollBar.setDisplayPerc(Math.min(1, this._viewSize.y / this._contentSize.y));\n            }\n            if (this._hzScrollBar) {\n                if (this._contentSize.x == 0)\n                    this._hzScrollBar.setDisplayPerc(0);\n                else\n                    this._hzScrollBar.setDisplayPerc(Math.min(1, this._viewSize.x / this._contentSize.x));\n            }\n            this.updateScrollBarVisible();\n            var rect = this._maskContainer.clipRect;\n            if (rect) {\n                rect.width = this._viewSize.x;\n                rect.height = this._viewSize.y;\n                if (this._vScrollNone && this._vtScrollBar)\n                    rect.width += this._vtScrollBar.width;\n                if (this._hScrollNone && this._hzScrollBar)\n                    rect.height += this._hzScrollBar.height;\n                this._maskContainer.clipRect = rect;\n            }\n            if (this._scrollType == fgui.ScrollType.Horizontal || this._scrollType == fgui.ScrollType.Both)\n                this._overlapSize.x = Math.ceil(Math.max(0, this._contentSize.x - this._viewSize.x));\n            else\n                this._overlapSize.x = 0;\n            if (this._scrollType == fgui.ScrollType.Vertical || this._scrollType == fgui.ScrollType.Both)\n                this._overlapSize.y = Math.ceil(Math.max(0, this._contentSize.y - this._viewSize.y));\n            else\n                this._overlapSize.y = 0;\n            this._xPos = fgui.clamp(this._xPos, 0, this._overlapSize.x);\n            this._yPos = fgui.clamp(this._yPos, 0, this._overlapSize.y);\n            if (this._refreshBarAxis) {\n                var max = this._overlapSize[this._refreshBarAxis];\n                if (max == 0)\n                    max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);\n                else\n                    max += this._footerLockedSize;\n                if (this._refreshBarAxis == \"x\") {\n                    this._container.setPosition(fgui.clamp(this._container.x, -max, this._headerLockedSize), fgui.clamp(this._container.y, -this._overlapSize.y, 0));\n                }\n                else {\n                    this._container.setPosition(fgui.clamp(this._container.x, -this._overlapSize.x, 0), fgui.clamp(this._container.y, -max, this._headerLockedSize));\n                }\n                if (this._header) {\n                    if (this._refreshBarAxis == \"x\")\n                        this._header.height = this._viewSize.y;\n                    else\n                        this._header.width = this._viewSize.x;\n                }\n                if (this._footer) {\n                    if (this._refreshBarAxis == \"y\")\n                        this._footer.height = this._viewSize.y;\n                    else\n                        this._footer.width = this._viewSize.x;\n                }\n            }\n            else {\n                this._container.setPosition(fgui.clamp(this._container.x, -this._overlapSize.x, 0), fgui.clamp(this._container.y, -this._overlapSize.y, 0));\n            }\n            this.updateScrollBarPos();\n            if (this._pageMode)\n                this.updatePageController();\n        }\n        posChanged(ani) {\n            if (this._aniFlag == 0)\n                this._aniFlag = ani ? 1 : -1;\n            else if (this._aniFlag == 1 && !ani)\n                this._aniFlag = -1;\n            this._needRefresh = true;\n            fgui.Timers.callLater(this.refresh, this);\n        }\n        refresh() {\n            if (this._owner.displayObject == null) {\n                return;\n            }\n            this._needRefresh = false;\n            fgui.Timers.remove(this.refresh, this);\n            if (this._pageMode || this._snapToItem) {\n                s_endPos.set(-this._xPos, -this._yPos);\n                this.alignPosition(s_endPos, false);\n                this._xPos = -s_endPos.x;\n                this._yPos = -s_endPos.y;\n            }\n            this.refresh2();\n            this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL);\n            if (this._needRefresh) {\n                this._needRefresh = false;\n                fgui.Timers.remove(this.refresh, this);\n                this.refresh2();\n            }\n            this.updateScrollBarPos();\n            this._aniFlag = 0;\n        }\n        refresh2() {\n            if (this._aniFlag == 1 && !this._dragged) {\n                var posX;\n                var posY;\n                if (this._overlapSize.x > 0)\n                    posX = -Math.floor(this._xPos);\n                else {\n                    if (this._container.x != 0)\n                        this._container.x = 0;\n                    posX = 0;\n                }\n                if (this._overlapSize.y > 0)\n                    posY = -Math.floor(this._yPos);\n                else {\n                    if (this._container.y != 0)\n                        this._container.y = 0;\n                    posY = 0;\n                }\n                if (posX != this._container.x || posY != this._container.y) {\n                    this._tweenDuration.set(TWEEN_TIME_GO, TWEEN_TIME_GO);\n                    this._tweenStart.set(this._container.x, this._container.y);\n                    this._tweenChange.set(posX - this._tweenStart.x, posY - this._tweenStart.y);\n                    this.startTween(1);\n                }\n                else if (this._tweening != 0)\n                    this.killTween();\n            }\n            else {\n                if (this._tweening != 0)\n                    this.killTween();\n                this._container.setPosition(Math.floor(-this._xPos), Math.floor(-this._yPos));\n                this.loopCheckingCurrent();\n            }\n            if (this._pageMode)\n                this.updatePageController();\n        }\n        __touchBegin(evt) {\n            if (!this._touchEffect)\n                return;\n            if (evt.input.button != 0)\n                return;\n            evt.captureTouch();\n            if (this._tweening != 0) {\n                this.killTween();\n                fgui.Stage.cancelClick(evt.input.touchId);\n                this._dragged = true;\n            }\n            else\n                this._dragged = false;\n            var pt = this._owner.globalToLocal(evt.input.x, evt.input.y, s_vec2);\n            this._containerPos.set(this._container.x, this._container.y);\n            this._beginTouchPos.set(pt.x, pt.y);\n            this._lastTouchPos.set(pt.x, pt.y);\n            this._lastTouchGlobalPos.set(evt.input.x, evt.input.y);\n            this._isHoldAreaDone = false;\n            this._velocity.set(0, 0);\n            this._velocityScale = 1;\n            this._lastMoveTime = performance.now() / 1000;\n        }\n        __touchMove(evt) {\n            if (!this._touchEffect || this.owner.isDisposed)\n                return;\n            if (ScrollPane.draggingPane && ScrollPane.draggingPane != this || fgui.GObject.draggingObject)\n                return;\n            var sensitivity = fgui.UIConfig.touchScrollSensitivity;\n            var pt = this._owner.globalToLocal(evt.input.x, evt.input.y);\n            var diff;\n            var sv, sh;\n            if (this._scrollType == fgui.ScrollType.Vertical) {\n                if (!this._isHoldAreaDone) {\n                    s_gestureFlag |= 1;\n                    diff = Math.abs(this._beginTouchPos.y - pt.y);\n                    if (diff < sensitivity)\n                        return;\n                    if ((s_gestureFlag & 2) != 0) {\n                        let diff2 = Math.abs(this._beginTouchPos.x - pt.x);\n                        if (diff < diff2)\n                            return;\n                    }\n                }\n                sv = true;\n            }\n            else if (this._scrollType == fgui.ScrollType.Horizontal) {\n                if (!this._isHoldAreaDone) {\n                    s_gestureFlag |= 2;\n                    diff = Math.abs(this._beginTouchPos.x - pt.x);\n                    if (diff < sensitivity)\n                        return;\n                    if ((s_gestureFlag & 1) != 0) {\n                        let diff2 = Math.abs(this._beginTouchPos.y - pt.y);\n                        if (diff < diff2)\n                            return;\n                    }\n                }\n                sh = true;\n            }\n            else {\n                s_gestureFlag = 3;\n                if (!this._isHoldAreaDone) {\n                    diff = Math.abs(this._beginTouchPos.y - pt.y);\n                    if (diff < sensitivity) {\n                        diff = Math.abs(this._beginTouchPos.x - pt.x);\n                        if (diff < sensitivity)\n                            return;\n                    }\n                }\n                sv = sh = true;\n            }\n            var newPosX = Math.floor(this._containerPos.x + pt.x - this._beginTouchPos.x);\n            var newPosY = Math.floor(this._containerPos.y + pt.y - this._beginTouchPos.y);\n            if (sv) {\n                if (newPosY > 0) {\n                    if (!this._bouncebackEffect)\n                        this._container.y = 0;\n                    else if (this._header && this._header.maxHeight != 0)\n                        this._container.y = Math.floor(Math.min(newPosY * 0.5, this._header.maxHeight));\n                    else\n                        this._container.y = Math.floor(Math.min(newPosY * 0.5, this._viewSize.y * PULL_RATIO));\n                }\n                else if (newPosY < -this._overlapSize.y) {\n                    if (!this._bouncebackEffect)\n                        this._container.y = -this._overlapSize.y;\n                    else if (this._footer && this._footer.maxHeight > 0)\n                        this._container.y = Math.floor(Math.max((newPosY + this._overlapSize.y) * 0.5, -this._footer.maxHeight) - this._overlapSize.y);\n                    else\n                        this._container.y = Math.floor(Math.max((newPosY + this._overlapSize.y) * 0.5, -this._viewSize.y * PULL_RATIO) - this._overlapSize.y);\n                }\n                else\n                    this._container.y = newPosY;\n            }\n            if (sh) {\n                if (newPosX > 0) {\n                    if (!this._bouncebackEffect)\n                        this._container.x = 0;\n                    else if (this._header && this._header.maxWidth != 0)\n                        this._container.x = Math.floor(Math.min(newPosX * 0.5, this._header.maxWidth));\n                    else\n                        this._container.x = Math.floor(Math.min(newPosX * 0.5, this._viewSize.x * PULL_RATIO));\n                }\n                else if (newPosX < 0 - this._overlapSize.x) {\n                    if (!this._bouncebackEffect)\n                        this._container.x = -this._overlapSize.x;\n                    else if (this._footer && this._footer.maxWidth > 0)\n                        this._container.x = Math.floor(Math.max((newPosX + this._overlapSize.x) * 0.5, -this._footer.maxWidth) - this._overlapSize.x);\n                    else\n                        this._container.x = Math.floor(Math.max((newPosX + this._overlapSize.x) * 0.5, -this._viewSize.x * PULL_RATIO) - this._overlapSize.x);\n                }\n                else\n                    this._container.x = newPosX;\n            }\n            var frameRate = 60;\n            var now = performance.now() / 1000;\n            var deltaTime = Math.max(now - this._lastMoveTime, 1 / frameRate);\n            var deltaPositionX = pt.x - this._lastTouchPos.x;\n            var deltaPositionY = pt.y - this._lastTouchPos.y;\n            if (!sh)\n                deltaPositionX = 0;\n            if (!sv)\n                deltaPositionY = 0;\n            if (deltaTime != 0) {\n                var elapsed = deltaTime * frameRate - 1;\n                if (elapsed > 1) {\n                    var factor = Math.pow(0.833, elapsed);\n                    this._velocity.x = this._velocity.x * factor;\n                    this._velocity.y = this._velocity.y * factor;\n                }\n                this._velocity.x = fgui.lerp(this._velocity.x, deltaPositionX * 60 / frameRate / deltaTime, deltaTime * 10);\n                this._velocity.y = fgui.lerp(this._velocity.y, deltaPositionY * 60 / frameRate / deltaTime, deltaTime * 10);\n            }\n            var deltaGlobalPositionX = this._lastTouchGlobalPos.x - evt.input.x;\n            var deltaGlobalPositionY = this._lastTouchGlobalPos.y - evt.input.y;\n            if (deltaPositionX != 0)\n                this._velocityScale = Math.abs(deltaGlobalPositionX / deltaPositionX);\n            else if (deltaPositionY != 0)\n                this._velocityScale = Math.abs(deltaGlobalPositionY / deltaPositionY);\n            this._lastTouchPos.set(pt.x, pt.y);\n            this._lastTouchGlobalPos.set(evt.input.x, evt.input.y);\n            this._lastMoveTime = now;\n            if (this._overlapSize.x > 0)\n                this._xPos = fgui.clamp(-this._container.x, 0, this._overlapSize.x);\n            if (this._overlapSize.y > 0)\n                this._yPos = fgui.clamp(-this._container.y, 0, this._overlapSize.y);\n            if (this._loop != 0) {\n                newPosX = this._container.x;\n                newPosY = this._container.y;\n                if (this.loopCheckingCurrent()) {\n                    this._containerPos.x += this._container.x - newPosX;\n                    this._containerPos.y += this._container.y - newPosY;\n                }\n            }\n            ScrollPane.draggingPane = this;\n            this._isHoldAreaDone = true;\n            this._dragged = true;\n            this.updateScrollBarPos();\n            this.updateScrollBarVisible();\n            if (this._pageMode)\n                this.updatePageController();\n            this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL);\n        }\n        __touchEnd() {\n            if (ScrollPane.draggingPane == this)\n                ScrollPane.draggingPane = null;\n            s_gestureFlag = 0;\n            if (!this._dragged || !this._touchEffect) {\n                this._dragged = false;\n                return;\n            }\n            this._dragged = false;\n            this._tweenStart.set(this._container.x, this._container.y);\n            s_endPos.set(this._tweenStart.x, this._tweenStart.y);\n            var flag = false;\n            if (this._container.x > 0) {\n                s_endPos.x = 0;\n                flag = true;\n            }\n            else if (this._container.x < -this._overlapSize.x) {\n                s_endPos.x = -this._overlapSize.x;\n                flag = true;\n            }\n            if (this._container.y > 0) {\n                s_endPos.y = 0;\n                flag = true;\n            }\n            else if (this._container.y < -this._overlapSize.y) {\n                s_endPos.y = -this._overlapSize.y;\n                flag = true;\n            }\n            if (flag) {\n                this._tweenChange.set(s_endPos.x - this._tweenStart.x, s_endPos.y - this._tweenStart.y);\n                if (this._tweenChange.x < -fgui.UIConfig.touchDragSensitivity || this._tweenChange.y < -fgui.UIConfig.touchDragSensitivity) {\n                    this._refreshEventDispatching = true;\n                    this._owner.dispatchEvent(fgui.ScrollEvent.PULL_DOWN_RELEASE);\n                    this._refreshEventDispatching = false;\n                }\n                else if (this._tweenChange.x > fgui.UIConfig.touchDragSensitivity || this._tweenChange.y > fgui.UIConfig.touchDragSensitivity) {\n                    this._refreshEventDispatching = true;\n                    this._owner.dispatchEvent(fgui.ScrollEvent.PULL_UP_RELEASE);\n                    this._refreshEventDispatching = false;\n                }\n                if (this._headerLockedSize > 0 && s_endPos[this._refreshBarAxis] == 0) {\n                    s_endPos[this._refreshBarAxis] = this._headerLockedSize;\n                    this._tweenChange.x = s_endPos.x - this._tweenStart.x;\n                    this._tweenChange.y = s_endPos.y - this._tweenStart.y;\n                }\n                else if (this._footerLockedSize > 0 && s_endPos[this._refreshBarAxis] == -this._overlapSize[this._refreshBarAxis]) {\n                    var max = this._overlapSize[this._refreshBarAxis];\n                    if (max == 0)\n                        max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);\n                    else\n                        max += this._footerLockedSize;\n                    s_endPos[this._refreshBarAxis] = -max;\n                    this._tweenChange.x = s_endPos.x - this._tweenStart.x;\n                    this._tweenChange.y = s_endPos.y - this._tweenStart.y;\n                }\n                this._tweenDuration.set(TWEEN_TIME_DEFAULT, TWEEN_TIME_DEFAULT);\n            }\n            else {\n                if (!this._inertiaDisabled) {\n                    var frameRate = 60;\n                    var elapsed = (performance.now() / 1000 - this._lastMoveTime) * frameRate - 1;\n                    if (elapsed > 1) {\n                        var factor = Math.pow(0.833, elapsed);\n                        this._velocity.x = this._velocity.x * factor;\n                        this._velocity.y = this._velocity.y * factor;\n                    }\n                    this.updateTargetAndDuration(this._tweenStart, s_endPos);\n                }\n                else\n                    this._tweenDuration.set(TWEEN_TIME_DEFAULT, TWEEN_TIME_DEFAULT);\n                s_oldChange.set(s_endPos.x - this._tweenStart.x, s_endPos.y - this._tweenStart.y);\n                this.loopCheckingTarget(s_endPos);\n                if (this._pageMode || this._snapToItem)\n                    this.alignPosition(s_endPos, true);\n                this._tweenChange.x = s_endPos.x - this._tweenStart.x;\n                this._tweenChange.y = s_endPos.y - this._tweenStart.y;\n                if (this._tweenChange.x == 0 && this._tweenChange.y == 0) {\n                    this.updateScrollBarVisible();\n                    return;\n                }\n                if (this._pageMode || this._snapToItem) {\n                    this.fixDuration(\"x\", s_oldChange.x);\n                    this.fixDuration(\"y\", s_oldChange.y);\n                }\n            }\n            this.startTween(2);\n        }\n        __mouseWheel(evt) {\n            if (!this._mouseWheelEnabled)\n                return;\n            var delta = evt.input.mouseWheelDelta / window.devicePixelRatio;\n            if (this._snapToItem && Math.abs(delta) < 1)\n                delta = Math.sign(delta);\n            if (this._overlapSize.x > 0 && this._overlapSize.y == 0) {\n                let step = this._pageMode ? this._pageSize.x : this._scrollStep;\n                this.setPosX(this._xPos + step * delta, false);\n            }\n            else {\n                let step = this._pageMode ? this._pageSize.y : this._scrollStep;\n                this.setPosY(this._yPos + step * delta, false);\n            }\n        }\n        updateScrollBarPos() {\n            if (this._vtScrollBar)\n                this._vtScrollBar.setScrollPerc(this._overlapSize.y == 0 ? 0 : fgui.clamp(-this._container.y, 0, this._overlapSize.y) / this._overlapSize.y);\n            if (this._hzScrollBar)\n                this._hzScrollBar.setScrollPerc(this._overlapSize.x == 0 ? 0 : fgui.clamp(-this._container.x, 0, this._overlapSize.x) / this._overlapSize.x);\n            this.checkRefreshBar();\n        }\n        updateScrollBarVisible() {\n            if (this._vtScrollBar) {\n                if (this._viewSize.y <= this._vtScrollBar.minSize || this._vScrollNone)\n                    this._vtScrollBar.displayObject.visible = false;\n                else\n                    this.updateScrollBarVisible2(this._vtScrollBar);\n            }\n            if (this._hzScrollBar) {\n                if (this._viewSize.x <= this._hzScrollBar.minSize || this._hScrollNone)\n                    this._hzScrollBar.displayObject.visible = false;\n                else\n                    this.updateScrollBarVisible2(this._hzScrollBar);\n            }\n        }\n        updateScrollBarVisible2(bar) {\n            if (this._scrollBarDisplayAuto)\n                fgui.GTween.kill(bar, false, \"alpha\");\n            if (this._scrollBarDisplayAuto && this._tweening == 0 && !this._dragged && !bar.gripDragging) {\n                if (bar.displayObject.visible)\n                    fgui.GTween.to(1, 0, 0.5).setDelay(0.5).onComplete(this.__barTweenComplete, this).setTarget(bar, \"alpha\");\n            }\n            else {\n                bar.alpha = 1;\n                bar.displayObject.visible = true;\n            }\n        }\n        __barTweenComplete(tweener) {\n            var bar = (tweener.target);\n            bar.alpha = 1;\n            bar.displayObject.visible = false;\n        }\n        getLoopPartSize(division, axis) {\n            return (this._contentSize[axis] + (axis == \"x\" ? (this._owner).columnGap : (this._owner).lineGap)) / division;\n        }\n        loopCheckingCurrent() {\n            var changed = false;\n            if (this._loop == 1 && this._overlapSize.x > 0) {\n                if (this._xPos < 0.001) {\n                    this._xPos += this.getLoopPartSize(2, \"x\");\n                    changed = true;\n                }\n                else if (this._xPos >= this._overlapSize.x) {\n                    this._xPos -= this.getLoopPartSize(2, \"x\");\n                    changed = true;\n                }\n            }\n            else if (this._loop == 2 && this._overlapSize.y > 0) {\n                if (this._yPos < 0.001) {\n                    this._yPos += this.getLoopPartSize(2, \"y\");\n                    changed = true;\n                }\n                else if (this._yPos >= this._overlapSize.y) {\n                    this._yPos -= this.getLoopPartSize(2, \"y\");\n                    changed = true;\n                }\n            }\n            if (changed)\n                this._container.setPosition(Math.floor(-this._xPos), Math.floor(-this._yPos));\n            return changed;\n        }\n        loopCheckingTarget(endPos) {\n            if (this._loop == 1)\n                this.loopCheckingTarget2(endPos, \"x\");\n            if (this._loop == 2)\n                this.loopCheckingTarget2(endPos, \"y\");\n        }\n        loopCheckingTarget2(endPos, axis) {\n            var halfSize;\n            var tmp;\n            if (endPos[axis] > 0) {\n                halfSize = this.getLoopPartSize(2, axis);\n                tmp = this._tweenStart[axis] - halfSize;\n                if (tmp <= 0 && tmp >= -this._overlapSize[axis]) {\n                    endPos[axis] -= halfSize;\n                    this._tweenStart[axis] = tmp;\n                }\n            }\n            else if (endPos[axis] < -this._overlapSize[axis]) {\n                halfSize = this.getLoopPartSize(2, axis);\n                tmp = this._tweenStart[axis] + halfSize;\n                if (tmp <= 0 && tmp >= -this._overlapSize[axis]) {\n                    endPos[axis] += halfSize;\n                    this._tweenStart[axis] = tmp;\n                }\n            }\n        }\n        loopCheckingNewPos(value, axis) {\n            if (this._overlapSize[axis] == 0)\n                return value;\n            var pos = axis == \"x\" ? this._xPos : this._yPos;\n            var changed = false;\n            var v;\n            if (value < 0.001) {\n                value += this.getLoopPartSize(2, axis);\n                if (value > pos) {\n                    v = this.getLoopPartSize(6, axis);\n                    v = Math.ceil((value - pos) / v) * v;\n                    pos = fgui.clamp(pos + v, 0, this._overlapSize[axis]);\n                    changed = true;\n                }\n            }\n            else if (value >= this._overlapSize[axis]) {\n                value -= this.getLoopPartSize(2, axis);\n                if (value < pos) {\n                    v = this.getLoopPartSize(6, axis);\n                    v = Math.ceil((pos - value) / v) * v;\n                    pos = fgui.clamp(pos - v, 0, this._overlapSize[axis]);\n                    changed = true;\n                }\n            }\n            if (changed) {\n                if (axis == \"x\")\n                    this._container.x = -Math.floor(pos);\n                else\n                    this._container.y = -Math.floor(pos);\n            }\n            return value;\n        }\n        alignPosition(pos, inertialScrolling) {\n            if (this._pageMode) {\n                pos.x = this.alignByPage(pos.x, \"x\", inertialScrolling);\n                pos.y = this.alignByPage(pos.y, \"y\", inertialScrolling);\n            }\n            else if (this._snapToItem) {\n                var xDir = 0;\n                var yDir = 0;\n                if (inertialScrolling) {\n                    xDir = pos.x - this._containerPos.x;\n                    yDir = pos.y - this._containerPos.y;\n                }\n                var pt = this._owner.getSnappingPositionWithDir(-pos.x, -pos.y, xDir, yDir, s_vec2);\n                if (pos.x < 0 && pos.x > -this._overlapSize.x)\n                    pos.x = -pt.x;\n                if (pos.y < 0 && pos.y > -this._overlapSize.y)\n                    pos.y = -pt.y;\n            }\n        }\n        alignByPage(pos, axis, inertialScrolling) {\n            var page;\n            if (pos > 0)\n                page = 0;\n            else if (pos < -this._overlapSize[axis])\n                page = Math.ceil(this._contentSize[axis] / this._pageSize[axis]) - 1;\n            else {\n                page = Math.floor(-pos / this._pageSize[axis]);\n                var change = inertialScrolling ? (pos - this._containerPos[axis]) : (pos - this._container[axis]);\n                var testPageSize = Math.min(this._pageSize[axis], this._contentSize[axis] - (page + 1) * this._pageSize[axis]);\n                var delta = -pos - page * this._pageSize[axis];\n                if (Math.abs(change) > this._pageSize[axis]) {\n                    if (delta > testPageSize * 0.5)\n                        page++;\n                }\n                else {\n                    if (delta > testPageSize * (change < 0 ? fgui.UIConfig.defaultScrollPagingThreshold : (1 - fgui.UIConfig.defaultScrollPagingThreshold)))\n                        page++;\n                }\n                pos = -page * this._pageSize[axis];\n                if (pos < -this._overlapSize[axis])\n                    pos = -this._overlapSize[axis];\n            }\n            if (inertialScrolling) {\n                var oldPos = this._tweenStart[axis];\n                var oldPage;\n                if (oldPos > 0)\n                    oldPage = 0;\n                else if (oldPos < -this._overlapSize[axis])\n                    oldPage = Math.ceil(this._contentSize[axis] / this._pageSize[axis]) - 1;\n                else\n                    oldPage = Math.floor(-oldPos / this._pageSize[axis]);\n                var startPage = Math.floor(-this._containerPos[axis] / this._pageSize[axis]);\n                if (Math.abs(page - startPage) > 1 && Math.abs(oldPage - startPage) <= 1) {\n                    if (page > startPage)\n                        page = startPage + 1;\n                    else\n                        page = startPage - 1;\n                    pos = -page * this._pageSize[axis];\n                }\n            }\n            return pos;\n        }\n        updateTargetAndDuration(orignPos, resultPos) {\n            resultPos.x = this.updateTargetAndDuration2(orignPos.x, \"x\");\n            resultPos.y = this.updateTargetAndDuration2(orignPos.y, \"y\");\n        }\n        updateTargetAndDuration2(pos, axis) {\n            var v = this._velocity[axis];\n            var duration = 0;\n            if (pos > 0)\n                pos = 0;\n            else if (pos < -this._overlapSize[axis])\n                pos = -this._overlapSize[axis];\n            else {\n                var v2 = Math.abs(v) * this._velocityScale;\n                if (fgui.Stage.touchScreen)\n                    v2 *= 1136 / Math.max(window.screen.width, window.screen.height);\n                var ratio = 0;\n                if (this._pageMode || !fgui.Stage.touchScreen) {\n                    if (v2 > 500)\n                        ratio = Math.pow((v2 - 500) / 500, 2);\n                }\n                else {\n                    if (v2 > 1000)\n                        ratio = Math.pow((v2 - 1000) / 1000, 2);\n                }\n                if (ratio != 0) {\n                    if (ratio > 1)\n                        ratio = 1;\n                    v2 *= ratio;\n                    v *= ratio;\n                    this._velocity[axis] = v;\n                    duration = Math.log(60 / v2) / Math.log(this._decelerationRate) / 60;\n                    var change = Math.floor(v * duration * 0.4);\n                    pos += change;\n                }\n            }\n            if (duration < TWEEN_TIME_DEFAULT)\n                duration = TWEEN_TIME_DEFAULT;\n            this._tweenDuration[axis] = duration;\n            return pos;\n        }\n        fixDuration(axis, oldChange) {\n            if (this._tweenChange[axis] == 0 || Math.abs(this._tweenChange[axis]) >= Math.abs(oldChange))\n                return;\n            var newDuration = Math.abs(this._tweenChange[axis] / oldChange) * this._tweenDuration[axis];\n            if (newDuration < TWEEN_TIME_DEFAULT)\n                newDuration = TWEEN_TIME_DEFAULT;\n            this._tweenDuration[axis] = newDuration;\n        }\n        startTween(type) {\n            this._tweenTime.set(0, 0);\n            this._tweening = type;\n            fgui.Timers.addUpdate(this.tweenUpdate, this);\n            this.updateScrollBarVisible();\n        }\n        killTween() {\n            if (this._tweening == 1) {\n                this._container.setPosition(this._tweenStart.x + this._tweenChange.x, this._tweenStart.y + this._tweenChange.y);\n                this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL);\n            }\n            this._tweening = 0;\n            fgui.Timers.remove(this.tweenUpdate, this);\n            this.updateScrollBarVisible();\n            this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL_END);\n        }\n        checkRefreshBar() {\n            if (this._header == null && this._footer == null)\n                return;\n            var pos = this._container[this._refreshBarAxis];\n            if (this._header) {\n                if (pos > 0) {\n                    if (this._header.displayObject.parent == null)\n                        this._maskContainer.addChildAt(this._header.displayObject, 0);\n                    var pt = s_vec2;\n                    pt.set(this._header.width, this._header.height);\n                    pt[this._refreshBarAxis] = pos;\n                    this._header.setSize(pt.x, pt.y);\n                }\n                else {\n                    if (this._header.displayObject.parent)\n                        this._maskContainer.removeChild(this._header.displayObject);\n                }\n            }\n            if (this._footer) {\n                var max = this._overlapSize[this._refreshBarAxis];\n                if (pos < -max || max == 0 && this._footerLockedSize > 0) {\n                    if (this._footer.displayObject.parent == null)\n                        this._maskContainer.addChildAt(this._footer.displayObject, 0);\n                    pt = s_vec2;\n                    pt.set(this._footer.x, this._footer.y);\n                    if (max > 0)\n                        pt[this._refreshBarAxis] = pos + this._contentSize[this._refreshBarAxis];\n                    else\n                        pt[this._refreshBarAxis] = Math.max(Math.min(pos + this._viewSize[this._refreshBarAxis], this._viewSize[this._refreshBarAxis] - this._footerLockedSize), this._viewSize[this._refreshBarAxis] - this._contentSize[this._refreshBarAxis]);\n                    this._footer.setPosition(pt.x, pt.y);\n                    pt.set(this._footer.width, this._footer.height);\n                    if (max > 0)\n                        pt[this._refreshBarAxis] = -max - pos;\n                    else\n                        pt[this._refreshBarAxis] = this._viewSize[this._refreshBarAxis] - this._footer[this._refreshBarAxis];\n                    this._footer.setSize(pt.x, pt.y);\n                }\n                else {\n                    if (this._footer.displayObject.parent)\n                        this._maskContainer.removeChild(this._footer.displayObject);\n                }\n            }\n        }\n        tweenUpdate() {\n            var nx = this.runTween(\"x\");\n            var ny = this.runTween(\"y\");\n            this._container.setPosition(nx, ny);\n            if (this._tweening == 2) {\n                if (this._overlapSize.x > 0)\n                    this._xPos = fgui.clamp(-nx, 0, this._overlapSize.x);\n                if (this._overlapSize.y > 0)\n                    this._yPos = fgui.clamp(-ny, 0, this._overlapSize.y);\n                if (this._pageMode)\n                    this.updatePageController();\n            }\n            if (this._tweenChange.x == 0 && this._tweenChange.y == 0) {\n                this._tweening = 0;\n                fgui.Timers.remove(this.tweenUpdate, this);\n                this.loopCheckingCurrent();\n                this.updateScrollBarPos();\n                this.updateScrollBarVisible();\n                this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL);\n                this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL_END);\n            }\n            else {\n                this.updateScrollBarPos();\n                this._owner.dispatchEvent(fgui.ScrollEvent.SCROLL);\n            }\n        }\n        runTween(axis) {\n            var newValue;\n            if (this._tweenChange[axis] != 0) {\n                this._tweenTime[axis] += fgui.Timers.deltaTime / 1000;\n                if (this._tweenTime[axis] >= this._tweenDuration[axis]) {\n                    newValue = this._tweenStart[axis] + this._tweenChange[axis];\n                    this._tweenChange[axis] = 0;\n                }\n                else {\n                    var ratio = easeFunc(this._tweenTime[axis], this._tweenDuration[axis]);\n                    newValue = this._tweenStart[axis] + Math.floor(this._tweenChange[axis] * ratio);\n                }\n                var threshold1 = 0;\n                var threshold2 = -this._overlapSize[axis];\n                if (this._headerLockedSize > 0 && this._refreshBarAxis == axis)\n                    threshold1 = this._headerLockedSize;\n                if (this._footerLockedSize > 0 && this._refreshBarAxis == axis) {\n                    var max = this._overlapSize[this._refreshBarAxis];\n                    if (max == 0)\n                        max = Math.max(this._contentSize[this._refreshBarAxis] + this._footerLockedSize - this._viewSize[this._refreshBarAxis], 0);\n                    else\n                        max += this._footerLockedSize;\n                    threshold2 = -max;\n                }\n                if (this._tweening == 2 && this._bouncebackEffect) {\n                    if (newValue > 20 + threshold1 && this._tweenChange[axis] > 0\n                        || newValue > threshold1 && this._tweenChange[axis] == 0) {\n                        this._tweenTime[axis] = 0;\n                        this._tweenDuration[axis] = TWEEN_TIME_DEFAULT;\n                        this._tweenChange[axis] = -newValue + threshold1;\n                        this._tweenStart[axis] = newValue;\n                    }\n                    else if (newValue < threshold2 - 20 && this._tweenChange[axis] < 0\n                        || newValue < threshold2 && this._tweenChange[axis] == 0) {\n                        this._tweenTime[axis] = 0;\n                        this._tweenDuration[axis] = TWEEN_TIME_DEFAULT;\n                        this._tweenChange[axis] = threshold2 - newValue;\n                        this._tweenStart[axis] = newValue;\n                    }\n                }\n                else {\n                    if (newValue > threshold1) {\n                        newValue = threshold1;\n                        this._tweenChange[axis] = 0;\n                    }\n                    else if (newValue < threshold2) {\n                        newValue = threshold2;\n                        this._tweenChange[axis] = 0;\n                    }\n                }\n            }\n            else\n                newValue = this._container[axis];\n            return newValue;\n        }\n    }\n    fgui.ScrollPane = ScrollPane;\n    function easeFunc(t, d) {\n        return (t = t / d - 1) * t * t + 1;\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    const OPTION_IGNORE_DISPLAY_CONTROLLER = 1;\n    const OPTION_AUTO_STOP_DISABLED = 2;\n    const OPTION_AUTO_STOP_AT_END = 4;\n    class Transition {\n        constructor(owner) {\n            this._owner = owner;\n            this._items = new Array();\n            this._totalDuration = 0;\n            this._autoPlayTimes = 1;\n            this._autoPlayDelay = 0;\n            this._timeScale = 1;\n            this._startTime = 0;\n            this._endTime = 0;\n        }\n        play(onComplete, times, delay, startTime, endTime) {\n            this._play(onComplete, times, delay, startTime, endTime, false);\n        }\n        playReverse(onComplete, times, delay, startTime, endTime) {\n            this._play(onComplete, times, delay, startTime, endTime, true);\n        }\n        changePlayTimes(value) {\n            this._totalTimes = value;\n        }\n        setAutoPlay(value, times, delay) {\n            if (this._autoPlay != value) {\n                this._autoPlay = value;\n                this._autoPlayTimes = times || 1;\n                this._autoPlayDelay = delay || 0;\n                if (this._autoPlay) {\n                    if (this._owner.onStage)\n                        this.play(null, null, this._autoPlayTimes, this._autoPlayDelay);\n                }\n                else {\n                    if (!this._owner.onStage)\n                        this.stop(false, true);\n                }\n            }\n        }\n        _play(onComplete, times, delay, startTime, endTime, reversed) {\n            this.stop(true, true);\n            delay = delay || 0;\n            this._totalTimes = times || 1;\n            this._reversed = reversed;\n            this._startTime = startTime || 0;\n            this._endTime = endTime || -1;\n            this._playing = true;\n            this._paused = false;\n            this._onComplete = onComplete;\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.target == null) {\n                    if (item.targetId)\n                        item.target = this._owner.getChildById(item.targetId);\n                    else\n                        item.target = this._owner;\n                }\n                else if (item.target != this._owner && item.target.parent != this._owner)\n                    item.target = null;\n                if (item.target && item.type == ActionType.Transition) {\n                    var trans = item.target.getTransition(item.value.transName);\n                    if (trans == this)\n                        trans = null;\n                    if (trans) {\n                        if (item.value.playTimes == 0) {\n                            var j;\n                            for (j = i - 1; j >= 0; j--) {\n                                var item2 = this._items[j];\n                                if (item2.type == ActionType.Transition) {\n                                    if (item2.value.trans == trans) {\n                                        item2.value.stopTime = item.time - item2.time;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (j < 0)\n                                item.value.stopTime = 0;\n                            else\n                                trans = null;\n                        }\n                        else\n                            item.value.stopTime = -1;\n                    }\n                    item.value.trans = trans;\n                }\n            }\n            if (delay == 0)\n                this.onDelayedPlay();\n            else\n                fgui.GTween.delayedCall(delay).onComplete(this.onDelayedPlay, this);\n        }\n        stop(setToComplete, processCallback) {\n            if (!this._playing)\n                return;\n            if (setToComplete == null)\n                setToComplete = true;\n            this._playing = false;\n            this._totalTasks = 0;\n            this._totalTimes = 0;\n            var handler = this._onComplete;\n            this._onComplete = null;\n            fgui.GTween.kill(this);\n            var cnt = this._items.length;\n            if (this._reversed) {\n                for (var i = cnt - 1; i >= 0; i--) {\n                    var item = this._items[i];\n                    if (item.target == null)\n                        continue;\n                    this.stopItem(item, setToComplete);\n                }\n            }\n            else {\n                for (i = 0; i < cnt; i++) {\n                    item = this._items[i];\n                    if (item.target == null)\n                        continue;\n                    this.stopItem(item, setToComplete);\n                }\n            }\n            if (processCallback && handler) {\n                handler();\n            }\n        }\n        stopItem(item, setToComplete) {\n            if (item.displayLockToken != 0) {\n                item.target.releaseDisplayLock(item.displayLockToken);\n                item.displayLockToken = 0;\n            }\n            if (item.tweener) {\n                item.tweener.kill(setToComplete);\n                item.tweener = null;\n                if (item.type == ActionType.Shake && !setToComplete) {\n                    item.target._gearLocked = true;\n                    item.target.setPosition(item.target.x - item.value.lastOffsetX, item.target.y - item.value.lastOffsetY);\n                    item.target._gearLocked = false;\n                }\n            }\n            if (item.type == ActionType.Transition) {\n                var trans = item.value.trans;\n                if (trans)\n                    trans.stop(setToComplete, false);\n            }\n        }\n        setPaused(paused) {\n            if (!this._playing || this._paused == paused)\n                return;\n            this._paused = paused;\n            var tweener = fgui.GTween.getTween(this);\n            if (tweener)\n                tweener.setPaused(paused);\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.target == null)\n                    continue;\n                if (item.type == ActionType.Transition) {\n                    if (item.value.trans)\n                        item.value.trans.setPaused(paused);\n                }\n                else if (item.type == ActionType.Animation) {\n                    if (paused) {\n                        item.value.flag = item.target.getProp(fgui.ObjectPropID.Playing);\n                        item.target.setProp(fgui.ObjectPropID.Playing, false);\n                    }\n                    else\n                        item.target.setProp(fgui.ObjectPropID.Playing, item.value.flag);\n                }\n                if (item.tweener)\n                    item.tweener.setPaused(paused);\n            }\n        }\n        dispose() {\n            if (this._playing)\n                fgui.GTween.kill(this);\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.tweener) {\n                    item.tweener.kill();\n                    item.tweener = null;\n                }\n                item.target = null;\n                item.hook = null;\n                if (item.tweenConfig)\n                    item.tweenConfig.endHook = null;\n            }\n            this._items.length = 0;\n            this._playing = false;\n            this._onComplete = null;\n        }\n        get playing() {\n            return this._playing;\n        }\n        setValue(label, ...args) {\n            var cnt = this._items.length;\n            var found = false;\n            var value;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.label == label) {\n                    if (item.tweenConfig)\n                        value = item.tweenConfig.startValue;\n                    else\n                        value = item.value;\n                    found = true;\n                }\n                else if (item.tweenConfig && item.tweenConfig.endLabel == label) {\n                    value = item.tweenConfig.endValue;\n                    found = true;\n                }\n                else\n                    continue;\n                switch (item.type) {\n                    case ActionType.XY:\n                    case ActionType.Size:\n                    case ActionType.Pivot:\n                    case ActionType.Scale:\n                    case ActionType.Skew:\n                        value.b1 = true;\n                        value.b2 = true;\n                        value.f1 = parseFloat(args[0]);\n                        value.f2 = parseFloat(args[1]);\n                        break;\n                    case ActionType.Alpha:\n                        value.f1 = parseFloat(args[0]);\n                        break;\n                    case ActionType.Rotation:\n                        value.f1 = parseFloat(args[0]);\n                        break;\n                    case ActionType.Color:\n                        value.f1 = parseFloat(args[0]);\n                        break;\n                    case ActionType.Animation:\n                        value.frame = parseInt(args[0]);\n                        if (args.length > 1)\n                            value.playing = args[1];\n                        break;\n                    case ActionType.Visible:\n                        value.visible = args[0];\n                        break;\n                    case ActionType.Sound:\n                        value.sound = args[0];\n                        if (args.length > 1)\n                            value.volume = parseFloat(args[1]);\n                        break;\n                    case ActionType.Transition:\n                        value.transName = args[0];\n                        if (args.length > 1)\n                            value.playTimes = parseInt(args[1]);\n                        break;\n                    case ActionType.Shake:\n                        value.amplitude = parseFloat(args[0]);\n                        if (args.length > 1)\n                            value.duration = parseFloat(args[1]);\n                        break;\n                    case ActionType.ColorFilter:\n                        value.f1 = parseFloat(args[0]);\n                        value.f2 = parseFloat(args[1]);\n                        value.f3 = parseFloat(args[2]);\n                        value.f4 = parseFloat(args[3]);\n                        break;\n                    case ActionType.Text:\n                    case ActionType.Icon:\n                        value.text = args[0];\n                        break;\n                }\n            }\n            if (!found)\n                throw new Error(\"this.label not exists\");\n        }\n        setHook(label, callback) {\n            var cnt = this._items.length;\n            var found = false;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.label == label) {\n                    item.hook = callback;\n                    found = true;\n                    break;\n                }\n                else if (item.tweenConfig && item.tweenConfig.endLabel == label) {\n                    item.tweenConfig.endHook = callback;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                throw new Error(\"this.label not exists\");\n        }\n        clearHooks() {\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                item.hook = null;\n                if (item.tweenConfig)\n                    item.tweenConfig.endHook = null;\n            }\n        }\n        setTarget(label, newTarget) {\n            var cnt = this._items.length;\n            var found = false;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.label == label) {\n                    item.targetId = (newTarget == this._owner || newTarget == null) ? \"\" : newTarget.id;\n                    if (this._playing) {\n                        if (item.targetId.length > 0)\n                            item.target = this._owner.getChildById(item.targetId);\n                        else\n                            item.target = this._owner;\n                    }\n                    else\n                        item.target = null;\n                    found = true;\n                }\n            }\n            if (!found)\n                throw new Error(\"this.label not exists\");\n        }\n        setDuration(label, value) {\n            var cnt = this._items.length;\n            var found = false;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.tweenConfig && item.label == label) {\n                    item.tweenConfig.duration = value;\n                    found = true;\n                }\n            }\n            if (!found)\n                throw new Error(\"this.label not exists\");\n        }\n        getLabelTime(label) {\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.label == label)\n                    return item.time;\n                else if (item.tweenConfig && item.tweenConfig.endLabel == label)\n                    return item.time + item.tweenConfig.duration;\n            }\n            return NaN;\n        }\n        get timeScale() {\n            return this._timeScale;\n        }\n        set timeScale(value) {\n            if (this._timeScale != value) {\n                this._timeScale = value;\n                if (this._playing) {\n                    var cnt = this._items.length;\n                    for (var i = 0; i < cnt; i++) {\n                        var item = this._items[i];\n                        if (item.tweener)\n                            item.tweener.setTimeScale(value);\n                        else if (item.type == ActionType.Transition) {\n                            if (item.value.trans)\n                                item.value.trans.timeScale = value;\n                        }\n                        else if (item.type == ActionType.Animation) {\n                            if (item.target)\n                                item.target.setProp(fgui.ObjectPropID.TimeScale, value);\n                        }\n                    }\n                }\n            }\n        }\n        updateFromRelations(targetId, dx, dy) {\n            var cnt = this._items.length;\n            if (cnt == 0)\n                return;\n            for (var i = 0; i < cnt; i++) {\n                var item = this._items[i];\n                if (item.type == ActionType.XY && item.targetId == targetId) {\n                    if (item.tweenConfig) {\n                        if (!item.tweenConfig.startValue.b3) {\n                            item.tweenConfig.startValue.f1 += dx;\n                            item.tweenConfig.startValue.f2 += dy;\n                        }\n                        if (!item.tweenConfig.endValue.b3) {\n                            item.tweenConfig.endValue.f1 += dx;\n                            item.tweenConfig.endValue.f2 += dy;\n                        }\n                    }\n                    else {\n                        if (!item.value.b3) {\n                            item.value.f1 += dx;\n                            item.value.f2 += dy;\n                        }\n                    }\n                }\n            }\n        }\n        onOwnerAddedToStage() {\n            if (this._autoPlay && !this._playing)\n                this.play(null, this._autoPlayTimes, this._autoPlayDelay);\n        }\n        onOwnerRemovedFromStage() {\n            if ((this._options & OPTION_AUTO_STOP_DISABLED) == 0)\n                this.stop((this._options & OPTION_AUTO_STOP_AT_END) != 0 ? true : false, false);\n        }\n        onDelayedPlay() {\n            this.internalPlay();\n            this._playing = this._totalTasks > 0;\n            if (this._playing) {\n                if ((this._options & OPTION_IGNORE_DISPLAY_CONTROLLER) != 0) {\n                    var cnt = this._items.length;\n                    for (var i = 0; i < cnt; i++) {\n                        var item = this._items[i];\n                        if (item.target && item.target != this._owner)\n                            item.displayLockToken = item.target.addDisplayLock();\n                    }\n                }\n            }\n            else if (this._onComplete) {\n                var handler = this._onComplete;\n                this._onComplete = null;\n                handler();\n            }\n        }\n        internalPlay() {\n            this._ownerBaseX = this._owner.x;\n            this._ownerBaseY = this._owner.y;\n            this._totalTasks = 0;\n            var cnt = this._items.length;\n            var item;\n            var needSkipAnimations = false;\n            if (!this._reversed) {\n                for (var i = 0; i < cnt; i++) {\n                    item = this._items[i];\n                    if (item.target == null)\n                        continue;\n                    if (item.type == ActionType.Animation && this._startTime != 0 && item.time <= this._startTime) {\n                        needSkipAnimations = true;\n                        item.value.flag = false;\n                    }\n                    else\n                        this.playItem(item);\n                }\n            }\n            else {\n                for (i = cnt - 1; i >= 0; i--) {\n                    item = this._items[i];\n                    if (item.target == null)\n                        continue;\n                    this.playItem(item);\n                }\n            }\n            if (needSkipAnimations)\n                this.skipAnimations();\n        }\n        playItem(item) {\n            var time;\n            if (item.tweenConfig) {\n                if (this._reversed)\n                    time = (this._totalDuration - item.time - item.tweenConfig.duration);\n                else\n                    time = item.time;\n                if (this._endTime == -1 || time <= this._endTime) {\n                    var startValue;\n                    var endValue;\n                    if (this._reversed) {\n                        startValue = item.tweenConfig.endValue;\n                        endValue = item.tweenConfig.startValue;\n                    }\n                    else {\n                        startValue = item.tweenConfig.startValue;\n                        endValue = item.tweenConfig.endValue;\n                    }\n                    item.value.b1 = startValue.b1 || endValue.b1;\n                    item.value.b2 = startValue.b2 || endValue.b2;\n                    switch (item.type) {\n                        case ActionType.XY:\n                        case ActionType.Size:\n                        case ActionType.Scale:\n                        case ActionType.Skew:\n                            item.tweener = fgui.GTween.to2(startValue.f1, startValue.f2, endValue.f1, endValue.f2, item.tweenConfig.duration);\n                            break;\n                        case ActionType.Alpha:\n                        case ActionType.Rotation:\n                            item.tweener = fgui.GTween.to(startValue.f1, endValue.f1, item.tweenConfig.duration);\n                            break;\n                        case ActionType.Color:\n                            item.tweener = fgui.GTween.toColor(startValue.f1, endValue.f1, item.tweenConfig.duration);\n                            break;\n                        case ActionType.ColorFilter:\n                            item.tweener = fgui.GTween.to4(startValue.f1, startValue.f2, startValue.f3, startValue.f4, endValue.f1, endValue.f2, endValue.f3, endValue.f4, item.tweenConfig.duration);\n                            break;\n                    }\n                    item.tweener.setDelay(time)\n                        .setEase(item.tweenConfig.easeType)\n                        .setRepeat(item.tweenConfig.repeat, item.tweenConfig.yoyo)\n                        .setTimeScale(this._timeScale)\n                        .setTarget(item)\n                        .onStart(this.onTweenStart, this)\n                        .onUpdate(this.onTweenUpdate, this)\n                        .onComplete(this.onTweenComplete, this);\n                    if (this._endTime >= 0)\n                        item.tweener.setBreakpoint(this._endTime - time);\n                    this._totalTasks++;\n                }\n            }\n            else if (item.type == ActionType.Shake) {\n                if (this._reversed)\n                    time = (this._totalDuration - item.time - item.value.duration);\n                else\n                    time = item.time;\n                item.value.offsetX = item.value.offsetY = 0;\n                item.value.lastOffsetX = item.value.lastOffsetY = 0;\n                item.tweener = fgui.GTween.shake(0, 0, item.value.amplitude, item.value.duration)\n                    .setDelay(time)\n                    .setTimeScale(this._timeScale)\n                    .setTarget(item)\n                    .onUpdate(this.onTweenUpdate, this)\n                    .onComplete(this.onTweenComplete, this);\n                if (this._endTime >= 0)\n                    item.tweener.setBreakpoint(this._endTime - item.time);\n                this._totalTasks++;\n            }\n            else {\n                if (this._reversed)\n                    time = (this._totalDuration - item.time);\n                else\n                    time = item.time;\n                if (time <= this._startTime) {\n                    this.applyValue(item);\n                    this.callHook(item, false);\n                }\n                else if (this._endTime == -1 || time <= this._endTime) {\n                    this._totalTasks++;\n                    item.tweener = fgui.GTween.delayedCall(time)\n                        .setTimeScale(this._timeScale)\n                        .setTarget(item)\n                        .onComplete(this.onDelayedPlayItem, this);\n                }\n            }\n            if (item.tweener)\n                item.tweener.seek(this._startTime);\n        }\n        skipAnimations() {\n            var frame;\n            var playStartTime;\n            var playTotalTime;\n            var value;\n            var target;\n            var item;\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                item = this._items[i];\n                if (item.type != ActionType.Animation || item.time > this._startTime)\n                    continue;\n                value = item.value;\n                if (value.flag)\n                    continue;\n                target = item.target;\n                frame = target.getProp(fgui.ObjectPropID.Frame);\n                playStartTime = target.getProp(fgui.ObjectPropID.Playing) ? 0 : -1;\n                playTotalTime = 0;\n                for (var j = i; j < cnt; j++) {\n                    item = this._items[j];\n                    if (item.type != ActionType.Animation || item.target != target || item.time > this._startTime)\n                        continue;\n                    value = item.value;\n                    value.flag = true;\n                    if (value.frame != -1) {\n                        frame = value.frame;\n                        if (value.playing)\n                            playStartTime = item.time;\n                        else\n                            playStartTime = -1;\n                        playTotalTime = 0;\n                    }\n                    else {\n                        if (value.playing) {\n                            if (playStartTime < 0)\n                                playStartTime = item.time;\n                        }\n                        else {\n                            if (playStartTime >= 0)\n                                playTotalTime += (item.time - playStartTime);\n                            playStartTime = -1;\n                        }\n                    }\n                    this.callHook(item, false);\n                }\n                if (playStartTime >= 0)\n                    playTotalTime += (this._startTime - playStartTime);\n                target.setProp(fgui.ObjectPropID.Playing, playStartTime >= 0);\n                target.setProp(fgui.ObjectPropID.Frame, frame);\n                if (playTotalTime > 0)\n                    target.setProp(fgui.ObjectPropID.DeltaTime, playTotalTime * 1000);\n            }\n        }\n        onDelayedPlayItem(tweener) {\n            var item = tweener.target;\n            item.tweener = null;\n            this._totalTasks--;\n            this.applyValue(item);\n            this.callHook(item, false);\n            this.checkAllComplete();\n        }\n        onTweenStart(tweener) {\n            var item = tweener.target;\n            if (item.type == ActionType.XY || item.type == ActionType.Size) {\n                var startValue;\n                var endValue;\n                if (this._reversed) {\n                    startValue = item.tweenConfig.endValue;\n                    endValue = item.tweenConfig.startValue;\n                }\n                else {\n                    startValue = item.tweenConfig.startValue;\n                    endValue = item.tweenConfig.endValue;\n                }\n                if (item.type == ActionType.XY) {\n                    if (item.target != this._owner) {\n                        if (!startValue.b1)\n                            tweener.startValue.x = item.target.x;\n                        else if (startValue.b3)\n                            tweener.startValue.x = startValue.f1 * this._owner.width;\n                        if (!startValue.b2)\n                            tweener.startValue.y = item.target.y;\n                        else if (startValue.b3)\n                            tweener.startValue.y = startValue.f2 * this._owner.height;\n                        if (!endValue.b1)\n                            tweener.endValue.x = tweener.startValue.x;\n                        else if (endValue.b3)\n                            tweener.endValue.x = endValue.f1 * this._owner.width;\n                        if (!endValue.b2)\n                            tweener.endValue.y = tweener.startValue.y;\n                        else if (endValue.b3)\n                            tweener.endValue.y = endValue.f2 * this._owner.height;\n                    }\n                    else {\n                        if (!startValue.b1)\n                            tweener.startValue.x = item.target.x - this._ownerBaseX;\n                        if (!startValue.b2)\n                            tweener.startValue.y = item.target.y - this._ownerBaseY;\n                        if (!endValue.b1)\n                            tweener.endValue.x = tweener.startValue.x;\n                        if (!endValue.b2)\n                            tweener.endValue.y = tweener.startValue.y;\n                    }\n                }\n                else {\n                    if (!startValue.b1)\n                        tweener.startValue.x = item.target.width;\n                    if (!startValue.b2)\n                        tweener.startValue.y = item.target.height;\n                    if (!endValue.b1)\n                        tweener.endValue.x = tweener.startValue.x;\n                    if (!endValue.b2)\n                        tweener.endValue.y = tweener.startValue.y;\n                }\n                if (item.tweenConfig.path) {\n                    item.value.b1 = item.value.b2 = true;\n                    tweener.setPath(item.tweenConfig.path);\n                }\n            }\n            this.callHook(item, false);\n        }\n        onTweenUpdate(tweener) {\n            var item = tweener.target;\n            switch (item.type) {\n                case ActionType.XY:\n                case ActionType.Size:\n                case ActionType.Scale:\n                case ActionType.Skew:\n                    item.value.f1 = tweener.value.x;\n                    item.value.f2 = tweener.value.y;\n                    if (item.tweenConfig.path) {\n                        item.value.f1 += tweener.startValue.x;\n                        item.value.f2 += tweener.startValue.y;\n                    }\n                    break;\n                case ActionType.Alpha:\n                case ActionType.Rotation:\n                    item.value.f1 = tweener.value.x;\n                    break;\n                case ActionType.Color:\n                    item.value.f1 = tweener.value.color;\n                    break;\n                case ActionType.ColorFilter:\n                    item.value.f1 = tweener.value.x;\n                    item.value.f2 = tweener.value.y;\n                    item.value.f3 = tweener.value.z;\n                    item.value.f4 = tweener.value.w;\n                    break;\n                case ActionType.Shake:\n                    item.value.offsetX = tweener.deltaValue.x;\n                    item.value.offsetY = tweener.deltaValue.y;\n                    break;\n            }\n            this.applyValue(item);\n        }\n        onTweenComplete(tweener) {\n            var item = tweener.target;\n            item.tweener = null;\n            this._totalTasks--;\n            if (tweener.allCompleted)\n                this.callHook(item, true);\n            this.checkAllComplete();\n        }\n        onPlayTransCompleted(item) {\n            this._totalTasks--;\n            this.checkAllComplete();\n        }\n        callHook(item, tweenEnd) {\n            if (tweenEnd) {\n                if (item.tweenConfig && item.tweenConfig.endHook)\n                    item.tweenConfig.endHook();\n            }\n            else {\n                if (item.time >= this._startTime && item.hook)\n                    item.hook();\n            }\n        }\n        checkAllComplete() {\n            if (this._playing && this._totalTasks == 0) {\n                if (this._totalTimes < 0) {\n                    this.internalPlay();\n                }\n                else {\n                    this._totalTimes--;\n                    if (this._totalTimes > 0)\n                        this.internalPlay();\n                    else {\n                        this._playing = false;\n                        var cnt = this._items.length;\n                        for (var i = 0; i < cnt; i++) {\n                            var item = this._items[i];\n                            if (item.target && item.displayLockToken != 0) {\n                                item.target.releaseDisplayLock(item.displayLockToken);\n                                item.displayLockToken = 0;\n                            }\n                        }\n                        if (this._onComplete) {\n                            var handler = this._onComplete;\n                            this._onComplete = null;\n                            handler();\n                        }\n                    }\n                }\n            }\n        }\n        applyValue(item) {\n            item.target._gearLocked = true;\n            var value = item.value;\n            switch (item.type) {\n                case ActionType.XY:\n                    if (item.target == this._owner) {\n                        if (value.b1 && value.b2)\n                            item.target.setPosition(value.f1 + this._ownerBaseX, value.f2 + this._ownerBaseY);\n                        else if (value.b1)\n                            item.target.x = value.f1 + this._ownerBaseX;\n                        else\n                            item.target.y = value.f2 + this._ownerBaseY;\n                    }\n                    else {\n                        if (value.b3) {\n                            if (value.b1 && value.b2)\n                                item.target.setPosition(value.f1 * this._owner.width, value.f2 * this._owner.height);\n                            else if (value.b1)\n                                item.target.x = value.f1 * this._owner.width;\n                            else if (value.b2)\n                                item.target.y = value.f2 * this._owner.height;\n                        }\n                        else {\n                            if (value.b1 && value.b2)\n                                item.target.setPosition(value.f1, value.f2);\n                            else if (value.b1)\n                                item.target.x = value.f1;\n                            else if (value.b2)\n                                item.target.y = value.f2;\n                        }\n                    }\n                    break;\n                case ActionType.Size:\n                    if (!value.b1)\n                        value.f1 = item.target.width;\n                    if (!value.b2)\n                        value.f2 = item.target.height;\n                    item.target.setSize(value.f1, value.f2);\n                    break;\n                case ActionType.Pivot:\n                    item.target.setPivot(value.f1, value.f2, item.target.pivotAsAnchor);\n                    break;\n                case ActionType.Alpha:\n                    item.target.alpha = value.f1;\n                    break;\n                case ActionType.Rotation:\n                    item.target.rotation = value.f1;\n                    break;\n                case ActionType.Scale:\n                    item.target.setScale(value.f1, value.f2);\n                    break;\n                case ActionType.Skew:\n                    item.target.setSkew(value.f1, value.f2);\n                    break;\n                case ActionType.Color:\n                    item.target.setProp(fgui.ObjectPropID.Color, value.f1);\n                    break;\n                case ActionType.Animation:\n                    if (value.frame >= 0)\n                        item.target.setProp(fgui.ObjectPropID.Frame, value.frame);\n                    item.target.setProp(fgui.ObjectPropID.Playing, value.playing);\n                    item.target.setProp(fgui.ObjectPropID.TimeScale, this._timeScale);\n                    break;\n                case ActionType.Visible:\n                    item.target.visible = value.visible;\n                    break;\n                case ActionType.Transition:\n                    if (this._playing) {\n                        var trans = value.trans;\n                        if (trans) {\n                            this._totalTasks++;\n                            var startTime = this._startTime > item.time ? (this._startTime - item.time) : 0;\n                            var endTime = this._endTime >= 0 ? (this._endTime - item.time) : -1;\n                            if (value.stopTime >= 0 && (endTime < 0 || endTime > value.stopTime))\n                                endTime = value.stopTime;\n                            trans.timeScale = this._timeScale;\n                            trans._play(this.onPlayTransCompleted.bind(this, item), value.playTimes, 0, startTime, endTime, this._reversed);\n                        }\n                    }\n                    break;\n                case ActionType.Sound:\n                    if (this._playing && item.time >= this._startTime) {\n                        if (value.audioClip == null) {\n                            var pi = fgui.UIPackage.getItemByURL(value.sound);\n                            if (pi)\n                                value.audioClip = pi.file;\n                            else\n                                value.audioClip = value.sound;\n                        }\n                        if (value.audioClip)\n                            fgui.Decls.GRoot.inst.playOneShotSound(value.audioClip, value.volume);\n                    }\n                    break;\n                case ActionType.Shake:\n                    item.target.setPosition(item.target.x - value.lastOffsetX + value.offsetX, item.target.y - value.lastOffsetY + value.offsetY);\n                    value.lastOffsetX = value.offsetX;\n                    value.lastOffsetY = value.offsetY;\n                    break;\n                case ActionType.ColorFilter:\n                    {\n                        break;\n                    }\n                case ActionType.Text:\n                    item.target.text = value.text;\n                    break;\n                case ActionType.Icon:\n                    item.target.icon = value.text;\n                    break;\n            }\n            item.target._gearLocked = false;\n        }\n        setup(buffer) {\n            this.name = buffer.readS();\n            this._options = buffer.readInt();\n            this._autoPlay = buffer.readBool();\n            this._autoPlayTimes = buffer.readInt();\n            this._autoPlayDelay = buffer.readFloat();\n            var cnt = buffer.readShort();\n            for (var i = 0; i < cnt; i++) {\n                var dataLen = buffer.readShort();\n                var curPos = buffer.pos;\n                buffer.seek(curPos, 0);\n                var item = new Item(buffer.readByte());\n                this._items[i] = item;\n                item.time = buffer.readFloat();\n                var targetId = buffer.readShort();\n                if (targetId < 0)\n                    item.targetId = \"\";\n                else\n                    item.targetId = this._owner.getChildAt(targetId).id;\n                item.label = buffer.readS();\n                if (buffer.readBool()) {\n                    buffer.seek(curPos, 1);\n                    item.tweenConfig = new TweenConfig();\n                    item.tweenConfig.duration = buffer.readFloat();\n                    if (item.time + item.tweenConfig.duration > this._totalDuration)\n                        this._totalDuration = item.time + item.tweenConfig.duration;\n                    item.tweenConfig.easeType = buffer.readByte();\n                    item.tweenConfig.repeat = buffer.readInt();\n                    item.tweenConfig.yoyo = buffer.readBool();\n                    item.tweenConfig.endLabel = buffer.readS();\n                    buffer.seek(curPos, 2);\n                    this.decodeValue(item, buffer, item.tweenConfig.startValue);\n                    buffer.seek(curPos, 3);\n                    this.decodeValue(item, buffer, item.tweenConfig.endValue);\n                    if (buffer.version >= 2) {\n                        var pathLen = buffer.readInt();\n                        if (pathLen > 0) {\n                            item.tweenConfig.path = new fgui.GPath();\n                            var pts = new Array();\n                            for (var j = 0; j < pathLen; j++) {\n                                var curveType = buffer.readByte();\n                                switch (curveType) {\n                                    case fgui.CurveType.Bezier:\n                                        pts.push(fgui.GPathPoint.newBezierPoint(buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat()));\n                                        break;\n                                    case fgui.CurveType.CubicBezier:\n                                        pts.push(fgui.GPathPoint.newCubicBezierPoint(buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat(), buffer.readFloat()));\n                                        break;\n                                    default:\n                                        pts.push(fgui.GPathPoint.newPoint(buffer.readFloat(), buffer.readFloat(), curveType));\n                                        break;\n                                }\n                            }\n                            item.tweenConfig.path.create(pts);\n                        }\n                    }\n                }\n                else {\n                    if (item.time > this._totalDuration)\n                        this._totalDuration = item.time;\n                    buffer.seek(curPos, 2);\n                    this.decodeValue(item, buffer, item.value);\n                }\n                buffer.pos = curPos + dataLen;\n            }\n        }\n        decodeValue(item, buffer, value) {\n            switch (item.type) {\n                case ActionType.XY:\n                case ActionType.Size:\n                case ActionType.Pivot:\n                case ActionType.Skew:\n                    value.b1 = buffer.readBool();\n                    value.b2 = buffer.readBool();\n                    value.f1 = buffer.readFloat();\n                    value.f2 = buffer.readFloat();\n                    if (buffer.version >= 2 && item.type == ActionType.XY)\n                        value.b3 = buffer.readBool();\n                    break;\n                case ActionType.Alpha:\n                case ActionType.Rotation:\n                    value.b1 = value.b2 = true;\n                    value.f1 = buffer.readFloat();\n                    break;\n                case ActionType.Scale:\n                    value.b1 = value.b2 = true;\n                    value.f1 = buffer.readFloat();\n                    value.f2 = buffer.readFloat();\n                    break;\n                case ActionType.Color:\n                    value.b1 = value.b2 = true;\n                    value.f1 = buffer.readColor();\n                    break;\n                case ActionType.Animation:\n                    value.playing = buffer.readBool();\n                    value.frame = buffer.readInt();\n                    break;\n                case ActionType.Visible:\n                    value.visible = buffer.readBool();\n                    break;\n                case ActionType.Sound:\n                    value.sound = buffer.readS();\n                    value.volume = buffer.readFloat();\n                    break;\n                case ActionType.Transition:\n                    value.transName = buffer.readS();\n                    value.playTimes = buffer.readInt();\n                    break;\n                case ActionType.Shake:\n                    value.amplitude = buffer.readFloat();\n                    value.duration = buffer.readFloat();\n                    break;\n                case ActionType.ColorFilter:\n                    value.b1 = value.b2 = true;\n                    value.f1 = buffer.readFloat();\n                    value.f2 = buffer.readFloat();\n                    value.f3 = buffer.readFloat();\n                    value.f4 = buffer.readFloat();\n                    break;\n                case ActionType.Text:\n                case ActionType.Icon:\n                    value.text = buffer.readS();\n                    break;\n            }\n        }\n    }\n    fgui.Transition = Transition;\n    let ActionType;\n    (function (ActionType) {\n        ActionType[ActionType[\"XY\"] = 0] = \"XY\";\n        ActionType[ActionType[\"Size\"] = 1] = \"Size\";\n        ActionType[ActionType[\"Scale\"] = 2] = \"Scale\";\n        ActionType[ActionType[\"Pivot\"] = 3] = \"Pivot\";\n        ActionType[ActionType[\"Alpha\"] = 4] = \"Alpha\";\n        ActionType[ActionType[\"Rotation\"] = 5] = \"Rotation\";\n        ActionType[ActionType[\"Color\"] = 6] = \"Color\";\n        ActionType[ActionType[\"Animation\"] = 7] = \"Animation\";\n        ActionType[ActionType[\"Visible\"] = 8] = \"Visible\";\n        ActionType[ActionType[\"Sound\"] = 9] = \"Sound\";\n        ActionType[ActionType[\"Transition\"] = 10] = \"Transition\";\n        ActionType[ActionType[\"Shake\"] = 11] = \"Shake\";\n        ActionType[ActionType[\"ColorFilter\"] = 12] = \"ColorFilter\";\n        ActionType[ActionType[\"Skew\"] = 13] = \"Skew\";\n        ActionType[ActionType[\"Text\"] = 14] = \"Text\";\n        ActionType[ActionType[\"Icon\"] = 15] = \"Icon\";\n        ActionType[ActionType[\"Unknown\"] = 16] = \"Unknown\";\n    })(ActionType || (ActionType = {}));\n    class Item {\n        constructor(type) {\n            this.type = type;\n            this.value = {};\n            this.displayLockToken = 0;\n        }\n    }\n    class TweenConfig {\n        constructor() {\n            this.easeType = fgui.EaseType.QuadOut;\n            this.startValue = { b1: true, b2: true };\n            this.endValue = { b1: true, b2: true };\n        }\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class TranslationHelper {\n        constructor() {\n        }\n        static loadFromXML(source) {\n            let strings = {};\n            TranslationHelper.strings = strings;\n            let arr = source.elements(\"string\");\n            arr.forEach(cxml => {\n                let key = cxml.getAttrString(\"name\");\n                let text = cxml.text;\n                let i = key.indexOf(\"-\");\n                if (i == -1)\n                    return;\n                let key2 = key.substr(0, i);\n                let key3 = key.substr(i + 1);\n                let col = strings[key2];\n                if (!col) {\n                    col = {};\n                    strings[key2] = col;\n                }\n                col[key3] = text;\n            });\n        }\n        static translateComponent(item) {\n            if (TranslationHelper.strings == null)\n                return;\n            var compStrings = TranslationHelper.strings[item.owner.id + item.id];\n            if (compStrings == null)\n                return;\n            var elementId, value;\n            var buffer = item.rawData;\n            var nextPos;\n            var itemCount;\n            var i, j, k;\n            var dataLen;\n            var curPos;\n            var valueCnt;\n            var page;\n            buffer.seek(0, 2);\n            var childCount = buffer.readShort();\n            for (i = 0; i < childCount; i++) {\n                dataLen = buffer.readShort();\n                curPos = buffer.pos;\n                buffer.seek(curPos, 0);\n                var baseType = buffer.readByte();\n                var type = baseType;\n                buffer.skip(4);\n                elementId = buffer.readS();\n                if (type == fgui.ObjectType.Component) {\n                    if (buffer.seek(curPos, 6))\n                        type = buffer.readByte();\n                }\n                buffer.seek(curPos, 1);\n                if ((value = compStrings[elementId + \"-tips\"]) != null)\n                    buffer.writeS(value);\n                buffer.seek(curPos, 2);\n                var gearCnt = buffer.readShort();\n                for (j = 0; j < gearCnt; j++) {\n                    nextPos = buffer.readShort();\n                    nextPos += buffer.pos;\n                    if (buffer.readByte() == 6) {\n                        buffer.skip(2);\n                        valueCnt = buffer.readShort();\n                        for (k = 0; k < valueCnt; k++) {\n                            page = buffer.readS();\n                            if (page != null) {\n                                if ((value = compStrings[elementId + \"-texts_\" + k]) != null)\n                                    buffer.writeS(value);\n                                else\n                                    buffer.skip(2);\n                            }\n                        }\n                        if (buffer.readBool() && (value = compStrings[elementId + \"-texts_def\"]) != null)\n                            buffer.writeS(value);\n                    }\n                    buffer.pos = nextPos;\n                }\n                if (baseType == fgui.ObjectType.Component && buffer.version >= 2) {\n                    buffer.seek(curPos, 4);\n                    buffer.skip(2);\n                    buffer.skip(4 * buffer.readUshort());\n                    var cpCount = buffer.readUshort();\n                    for (var k = 0; k < cpCount; k++) {\n                        var target = buffer.readS();\n                        var propertyId = buffer.readUshort();\n                        if (propertyId == 0 && (value = compStrings[elementId + \"-cp-\" + target]) != null)\n                            buffer.writeS(value);\n                        else\n                            buffer.skip(2);\n                    }\n                }\n                switch (type) {\n                    case fgui.ObjectType.Text:\n                    case fgui.ObjectType.RichText:\n                    case fgui.ObjectType.InputText:\n                        {\n                            if ((value = compStrings[elementId]) != null) {\n                                buffer.seek(curPos, 6);\n                                buffer.writeS(value);\n                            }\n                            if ((value = compStrings[elementId + \"-prompt\"]) != null) {\n                                buffer.seek(curPos, 4);\n                                buffer.writeS(value);\n                            }\n                            break;\n                        }\n                    case fgui.ObjectType.List:\n                    case fgui.ObjectType.Tree:\n                        {\n                            buffer.seek(curPos, 8);\n                            buffer.skip(2);\n                            itemCount = buffer.readUshort();\n                            for (j = 0; j < itemCount; j++) {\n                                nextPos = buffer.readUshort();\n                                nextPos += buffer.pos;\n                                buffer.skip(2);\n                                if (type == fgui.ObjectType.Tree)\n                                    buffer.skip(2);\n                                if ((value = compStrings[elementId + \"-\" + j]) != null)\n                                    buffer.writeS(value);\n                                else\n                                    buffer.skip(2);\n                                if ((value = compStrings[elementId + \"-\" + j + \"-0\"]) != null)\n                                    buffer.writeS(value);\n                                else\n                                    buffer.skip(2);\n                                if (buffer.version >= 2) {\n                                    buffer.skip(6);\n                                    buffer.skip(buffer.readUshort() * 4);\n                                    var cpCount = buffer.readUshort();\n                                    for (var k = 0; k < cpCount; k++) {\n                                        var target = buffer.readS();\n                                        var propertyId = buffer.readUshort();\n                                        if (propertyId == 0 && (value = compStrings[elementId + \"-\" + j + \"-\" + target]) != null)\n                                            buffer.writeS(value);\n                                        else\n                                            buffer.skip(2);\n                                    }\n                                }\n                                buffer.pos = nextPos;\n                            }\n                            break;\n                        }\n                    case fgui.ObjectType.Label:\n                        {\n                            if (buffer.seek(curPos, 6) && buffer.readByte() == type) {\n                                if ((value = compStrings[elementId]) != null)\n                                    buffer.writeS(value);\n                                else\n                                    buffer.skip(2);\n                                buffer.skip(2);\n                                if (buffer.readBool())\n                                    buffer.skip(4);\n                                buffer.skip(4);\n                                if (buffer.readBool() && (value = compStrings[elementId + \"-prompt\"]) != null)\n                                    buffer.writeS(value);\n                            }\n                            break;\n                        }\n                    case fgui.ObjectType.Button:\n                        {\n                            if (buffer.seek(curPos, 6) && buffer.readByte() == type) {\n                                if ((value = compStrings[elementId]) != null)\n                                    buffer.writeS(value);\n                                else\n                                    buffer.skip(2);\n                                if ((value = compStrings[elementId + \"-0\"]) != null)\n                                    buffer.writeS(value);\n                            }\n                            break;\n                        }\n                    case fgui.ObjectType.ComboBox:\n                        {\n                            if (buffer.seek(curPos, 6) && buffer.readByte() == type) {\n                                itemCount = buffer.readShort();\n                                for (j = 0; j < itemCount; j++) {\n                                    nextPos = buffer.readShort();\n                                    nextPos += buffer.pos;\n                                    if ((value = compStrings[elementId + \"-\" + j]) != null)\n                                        buffer.writeS(value);\n                                    buffer.pos = nextPos;\n                                }\n                                if ((value = compStrings[elementId]) != null)\n                                    buffer.writeS(value);\n                            }\n                            break;\n                        }\n                }\n                buffer.pos = curPos + dataLen;\n            }\n        }\n    }\n    fgui.TranslationHelper = TranslationHelper;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class UIConfig {\n    }\n    UIConfig.defaultFont = \"Arial\";\n    UIConfig.modalLayerColor = new fgui.Color4(0x333333, 0.2);\n    UIConfig.buttonSound = null;\n    UIConfig.buttonSoundVolumeScale = 1;\n    UIConfig.horizontalScrollBar = null;\n    UIConfig.verticalScrollBar = null;\n    UIConfig.defaultScrollStep = 25;\n    UIConfig.defaultScrollDecelerationRate = 0.967;\n    UIConfig.defaultScrollBarDisplay = fgui.ScrollBarDisplayType.Visible;\n    UIConfig.defaultScrollTouchEffect = true;\n    UIConfig.defaultScrollBounceEffect = true;\n    UIConfig.defaultScrollSnappingThreshold = 0.1;\n    UIConfig.defaultScrollPagingThreshold = 0.3;\n    UIConfig.popupMenu = null;\n    UIConfig.popupMenu_seperator = null;\n    UIConfig.loaderErrorSign = null;\n    UIConfig.tooltipsWin = null;\n    UIConfig.defaultComboBoxVisibleItemCount = 10;\n    UIConfig.touchScrollSensitivity = 20;\n    UIConfig.touchDragSensitivity = 10;\n    UIConfig.clickDragSensitivity = 2;\n    UIConfig.bringWindowToFrontOnClick = true;\n    UIConfig.frameTimeForAsyncUIConstruction = 2;\n    UIConfig.packageFileExtension = \"fui\";\n    fgui.UIConfig = UIConfig;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let ScaleMode;\n    (function (ScaleMode) {\n        ScaleMode[ScaleMode[\"ConstantPixelSize\"] = 0] = \"ConstantPixelSize\";\n        ScaleMode[ScaleMode[\"ScaleWithScreenSize\"] = 1] = \"ScaleWithScreenSize\";\n        ScaleMode[ScaleMode[\"ConstantPhysicalSize\"] = 2] = \"ConstantPhysicalSize\";\n    })(ScaleMode = fgui.ScaleMode || (fgui.ScaleMode = {}));\n    let ScreenMatchMode;\n    (function (ScreenMatchMode) {\n        ScreenMatchMode[ScreenMatchMode[\"MatchWidthOrHeight\"] = 0] = \"MatchWidthOrHeight\";\n        ScreenMatchMode[ScreenMatchMode[\"MatchWidth\"] = 1] = \"MatchWidth\";\n        ScreenMatchMode[ScreenMatchMode[\"MatchHeight\"] = 2] = \"MatchHeight\";\n    })(ScreenMatchMode = fgui.ScreenMatchMode || (fgui.ScreenMatchMode = {}));\n    class UIContentScaler {\n        static get scaleFactor() { return _scaleFactor; }\n        static get scaleLevel() { return _scaleLevel; }\n        static scaleWithScreenSize(designResolutionX, designResolutionY, screenMatchMode) {\n            _designResolutionX = designResolutionX;\n            _designResolutionY = designResolutionY;\n            _scaleMode = ScaleMode.ScaleWithScreenSize;\n            _screenMatchMode = screenMatchMode || ScreenMatchMode.MatchWidthOrHeight;\n            refresh();\n        }\n        static setConstant(constantScaleFactor) {\n            _scaleMode = ScaleMode.ConstantPixelSize;\n            _constantScaleFactor = constantScaleFactor || 1;\n            refresh();\n        }\n    }\n    fgui.UIContentScaler = UIContentScaler;\n    var _scaleMode = ScaleMode.ConstantPixelSize;\n    var _screenMatchMode;\n    var _designResolutionX = 1136;\n    var _designResolutionY = 640;\n    var _constantScaleFactor = 1;\n    var _ignoreOrientation;\n    var _scaleFactor = 1;\n    var _scaleLevel = 0;\n    fgui.Stage.eventDispatcher.on(fgui.DisplayObjectEvent.SIZE_CHANGED, refresh);\n    function refresh() {\n        let screenWidth = fgui.Stage.width;\n        let screenHeight = fgui.Stage.height;\n        if (_scaleMode == ScaleMode.ScaleWithScreenSize) {\n            if (_designResolutionX == 0 || _designResolutionY == 0)\n                return;\n            let dx = _designResolutionX;\n            let dy = _designResolutionY;\n            if (!_ignoreOrientation && (screenWidth > screenHeight && dx < dy || screenWidth < screenHeight && dx > dy)) {\n                let tmp = dx;\n                dx = dy;\n                dy = tmp;\n            }\n            if (_screenMatchMode == ScreenMatchMode.MatchWidthOrHeight) {\n                let s1 = screenWidth / dx;\n                let s2 = screenHeight / dy;\n                _scaleFactor = Math.min(s1, s2);\n            }\n            else if (_screenMatchMode == ScreenMatchMode.MatchWidth)\n                _scaleFactor = screenWidth / dx;\n            else\n                _scaleFactor = screenHeight / dy;\n        }\n        else if (_scaleMode == ScaleMode.ConstantPhysicalSize) {\n        }\n        else\n            _scaleFactor = _constantScaleFactor;\n        if (_scaleFactor > 10)\n            _scaleFactor = 10;\n        if (_scaleFactor > 3)\n            _scaleLevel = 3;\n        else if (_scaleFactor > 2)\n            _scaleLevel = 2;\n        else if (_scaleFactor > 1)\n            _scaleLevel = 1;\n        else\n            _scaleLevel = 0;\n        fgui.broadcastEvent(fgui.Stage.scene, fgui.StageEvent.ContentScaleChanged);\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class UIObjectFactory {\n        static setExtension(url, type) {\n            if (url == null)\n                throw new Error(\"Invaild url: \" + url);\n            var pi = fgui.UIPackage.getItemByURL(url);\n            if (pi)\n                pi.extensionType = type;\n            UIObjectFactory.extensions[url] = type;\n        }\n        static setLoaderExtension(type) {\n            UIObjectFactory.loaderType = type;\n        }\n        static resolvePackageItemExtension(pi) {\n            var extensionType = UIObjectFactory.extensions[\"ui://\" + pi.owner.id + pi.id];\n            if (!extensionType)\n                extensionType = UIObjectFactory.extensions[\"ui://\" + pi.owner.name + \"/\" + pi.name];\n            if (extensionType)\n                pi.extensionType = extensionType;\n        }\n        static newObject(type, userClass) {\n            var obj;\n            if (typeof type === 'number') {\n                switch (type) {\n                    case fgui.ObjectType.Image:\n                        return new fgui.GImage();\n                    case fgui.ObjectType.MovieClip:\n                        return new fgui.GMovieClip();\n                    case fgui.ObjectType.Component:\n                        return new fgui.GComponent();\n                    case fgui.ObjectType.Text:\n                        return new fgui.GTextField();\n                    case fgui.ObjectType.RichText:\n                        return new fgui.GRichTextField();\n                    case fgui.ObjectType.InputText:\n                        return new fgui.GTextInput();\n                    case fgui.ObjectType.Group:\n                        return new fgui.GGroup();\n                    case fgui.ObjectType.List:\n                        return new fgui.GList();\n                    case fgui.ObjectType.Graph:\n                        return new fgui.GGraph();\n                    case fgui.ObjectType.Loader:\n                        if (UIObjectFactory.loaderType)\n                            return new UIObjectFactory.loaderType();\n                        else\n                            return new fgui.GLoader();\n                    case fgui.ObjectType.Button:\n                        return new fgui.GButton();\n                    case fgui.ObjectType.Label:\n                        return new fgui.GLabel();\n                    case fgui.ObjectType.ProgressBar:\n                        return new fgui.GProgressBar();\n                    case fgui.ObjectType.Slider:\n                        return new fgui.GSlider();\n                    case fgui.ObjectType.ScrollBar:\n                        return new fgui.GScrollBar();\n                    case fgui.ObjectType.ComboBox:\n                        return new fgui.GComboBox();\n                    case fgui.ObjectType.Tree:\n                        return new fgui.GTree();\n                    case fgui.ObjectType.Loader3D:\n                        return new fgui.GLoader3D();\n                    default:\n                        return null;\n                }\n            }\n            else {\n                if (type.type == fgui.PackageItemType.Component) {\n                    if (userClass)\n                        obj = new userClass();\n                    else if (type.extensionType)\n                        obj = new type.extensionType();\n                    else\n                        obj = UIObjectFactory.newObject(type.objectType);\n                }\n                else\n                    obj = UIObjectFactory.newObject(type.objectType);\n                if (obj)\n                    obj.packageItem = type;\n            }\n            return obj;\n        }\n    }\n    UIObjectFactory.extensions = {};\n    fgui.UIObjectFactory = UIObjectFactory;\n    fgui.Decls.UIObjectFactory = UIObjectFactory;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class UIPackage {\n        constructor() {\n            this._items = [];\n            this._itemsById = {};\n            this._itemsByName = {};\n            this._sprites = {};\n            this._dependencies = Array();\n            this._branches = Array();\n            this._branchIndex = -1;\n        }\n        static get branch() {\n            return _branch;\n        }\n        static set branch(value) {\n            _branch = value;\n            for (var pkgId in _instById) {\n                var pkg = _instById[pkgId];\n                if (pkg._branches) {\n                    pkg._branchIndex = pkg._branches.indexOf(value);\n                }\n            }\n        }\n        static getVar(key) {\n            return _vars[key];\n        }\n        static setVar(key, value) {\n            _vars[key] = value;\n        }\n        static getById(id) {\n            return _instById[id];\n        }\n        static getByName(name) {\n            return _instByName[name];\n        }\n        static loadPackage(resKey, onProgress) {\n            return new Promise(resolve => {\n                let pkg = _instById[resKey];\n                if (pkg) {\n                    resolve(pkg);\n                    return;\n                }\n                let url = resKey + \".\" + fgui.UIConfig.packageFileExtension;\n                var loader = new THREE.FileLoader();\n                loader.setResponseType(\"arraybuffer\");\n                loader.load(url, asset => {\n                    pkg = new UIPackage();\n                    pkg._resKey = resKey;\n                    pkg.loadPackage(new fgui.ByteBuffer(asset));\n                    let promises = [];\n                    let cnt = pkg._items.length;\n                    for (var i = 0; i < cnt; i++) {\n                        var pi = pkg._items[i];\n                        if (pi.type == fgui.PackageItemType.Atlas) {\n                            promises.push(loadTexture(pi, onProgress));\n                        }\n                        else if (pi.type == fgui.PackageItemType.Sound) {\n                            promises.push(loadSound(pi, onProgress));\n                        }\n                    }\n                    let resolve2 = () => {\n                        _instById[pkg.id] = pkg;\n                        _instByName[pkg.name] = pkg;\n                        _instByName[pkg._resKey] = pkg;\n                        resolve(pkg);\n                    };\n                    if (promises.length > 0)\n                        Promise.all(promises).then(resolve2);\n                    else\n                        resolve2();\n                });\n            });\n        }\n        static removePackage(packageIdOrName) {\n            var pkg = _instById[packageIdOrName];\n            if (!pkg)\n                pkg = _instByName[packageIdOrName];\n            if (!pkg)\n                throw new Error(\"unknown package: \" + packageIdOrName);\n            pkg.dispose();\n            delete _instById[pkg.id];\n            delete _instByName[pkg.name];\n            delete _instById[pkg._resKey];\n            if (pkg._customId != null)\n                delete _instById[pkg._customId];\n        }\n        static createObject(pkgName, resName, userClass) {\n            var pkg = UIPackage.getByName(pkgName);\n            if (pkg)\n                return pkg.createObject(resName, userClass);\n            else\n                return null;\n        }\n        static createObjectFromURL(url, userClass) {\n            var pi = UIPackage.getItemByURL(url);\n            if (pi)\n                return pi.owner.internalCreateObject(pi, userClass);\n            else\n                return null;\n        }\n        static getItemURL(pkgName, resName) {\n            var pkg = UIPackage.getByName(pkgName);\n            if (!pkg)\n                return null;\n            var pi = pkg._itemsByName[resName];\n            if (!pi)\n                return null;\n            return \"ui://\" + pkg.id + pi.id;\n        }\n        static getItemByURL(url) {\n            var pos1 = url.indexOf(\"//\");\n            if (pos1 == -1)\n                return null;\n            var pos2 = url.indexOf(\"/\", pos1 + 2);\n            if (pos2 == -1) {\n                if (url.length > 13) {\n                    var pkgId = url.substr(5, 8);\n                    var pkg = UIPackage.getById(pkgId);\n                    if (pkg) {\n                        var srcId = url.substr(13);\n                        return pkg.getItemById(srcId);\n                    }\n                }\n            }\n            else {\n                var pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);\n                pkg = UIPackage.getByName(pkgName);\n                if (pkg) {\n                    var srcName = url.substr(pos2 + 1);\n                    return pkg.getItemByName(srcName);\n                }\n            }\n            return null;\n        }\n        static getItemAssetByURL(url) {\n            var item = UIPackage.getItemByURL(url);\n            if (item == null)\n                return null;\n            return item.owner.getItemAsset(item);\n        }\n        static normalizeURL(url) {\n            if (url == null)\n                return null;\n            var pos1 = url.indexOf(\"//\");\n            if (pos1 == -1)\n                return null;\n            var pos2 = url.indexOf(\"/\", pos1 + 2);\n            if (pos2 == -1)\n                return url;\n            var pkgName = url.substr(pos1 + 2, pos2 - pos1 - 2);\n            var srcName = url.substr(pos2 + 1);\n            return UIPackage.getItemURL(pkgName, srcName);\n        }\n        loadPackage(buffer) {\n            if (buffer.readUint() != 0x46475549)\n                throw new Error(\"old package format found in '\" + this._resKey + \"'\");\n            buffer.version = buffer.readInt();\n            var compressed = buffer.readBool();\n            this._id = buffer.readString();\n            this._name = buffer.readString();\n            buffer.skip(20);\n            if (compressed) {\n            }\n            var ver2 = buffer.version >= 2;\n            var indexTablePos = buffer.pos;\n            var cnt;\n            var i;\n            var j;\n            var nextPos;\n            var str;\n            var branchIncluded;\n            buffer.seek(indexTablePos, 4);\n            cnt = buffer.readInt();\n            var stringTable = [];\n            for (i = 0; i < cnt; i++)\n                stringTable[i] = buffer.readString();\n            buffer.stringTable = stringTable;\n            buffer.seek(indexTablePos, 0);\n            cnt = buffer.readShort();\n            for (i = 0; i < cnt; i++)\n                this._dependencies.push({ id: buffer.readS(), name: buffer.readS() });\n            if (ver2) {\n                cnt = buffer.readShort();\n                if (cnt > 0) {\n                    this._branches = buffer.readSArray(cnt);\n                    if (_branch)\n                        this._branchIndex = this._branches.indexOf(_branch);\n                }\n                branchIncluded = cnt > 0;\n            }\n            buffer.seek(indexTablePos, 1);\n            var pi;\n            var fileNamePrefix = this._resKey + \"_\";\n            cnt = buffer.readUshort();\n            for (i = 0; i < cnt; i++) {\n                nextPos = buffer.readInt();\n                nextPos += buffer.pos;\n                pi = new fgui.PackageItem();\n                pi.owner = this;\n                pi.type = buffer.readByte();\n                pi.id = buffer.readS();\n                pi.name = buffer.readS();\n                buffer.readS();\n                str = buffer.readS();\n                if (str)\n                    pi.file = str;\n                buffer.readBool();\n                pi.width = buffer.readInt();\n                pi.height = buffer.readInt();\n                switch (pi.type) {\n                    case fgui.PackageItemType.Image:\n                        {\n                            pi.objectType = fgui.ObjectType.Image;\n                            var scaleOption = buffer.readByte();\n                            if (scaleOption == 1) {\n                                pi.scale9Grid = new fgui.Rect();\n                                pi.scale9Grid.x = buffer.readInt();\n                                pi.scale9Grid.y = buffer.readInt();\n                                pi.scale9Grid.width = buffer.readInt();\n                                pi.scale9Grid.height = buffer.readInt();\n                                pi.tileGridIndice = buffer.readInt();\n                            }\n                            else if (scaleOption == 2)\n                                pi.scaleByTile = true;\n                            pi.smoothing = buffer.readBool();\n                            break;\n                        }\n                    case fgui.PackageItemType.MovieClip:\n                        {\n                            pi.smoothing = buffer.readBool();\n                            pi.objectType = fgui.ObjectType.MovieClip;\n                            pi.rawData = buffer.readBuffer();\n                            break;\n                        }\n                    case fgui.PackageItemType.Font:\n                        {\n                            pi.rawData = buffer.readBuffer();\n                            break;\n                        }\n                    case fgui.PackageItemType.Component:\n                        {\n                            var extension = buffer.readByte();\n                            if (extension > 0)\n                                pi.objectType = extension;\n                            else\n                                pi.objectType = fgui.ObjectType.Component;\n                            pi.rawData = buffer.readBuffer();\n                            fgui.Decls.UIObjectFactory.resolvePackageItemExtension(pi);\n                            break;\n                        }\n                    case fgui.PackageItemType.Atlas:\n                    case fgui.PackageItemType.Sound:\n                    case fgui.PackageItemType.Misc:\n                        {\n                            pi.file = fileNamePrefix + pi.file;\n                            break;\n                        }\n                }\n                if (ver2) {\n                    str = buffer.readS();\n                    if (str)\n                        pi.name = str + \"/\" + pi.name;\n                    var branchCnt = buffer.readByte();\n                    if (branchCnt > 0) {\n                        if (branchIncluded)\n                            pi.branches = buffer.readSArray(branchCnt);\n                        else\n                            this._itemsById[buffer.readS()] = pi;\n                    }\n                    var highResCnt = buffer.readByte();\n                    if (highResCnt > 0)\n                        pi.highResolution = buffer.readSArray(highResCnt);\n                }\n                this._items.push(pi);\n                this._itemsById[pi.id] = pi;\n                if (pi.name != null)\n                    this._itemsByName[pi.name] = pi;\n                buffer.pos = nextPos;\n            }\n            buffer.seek(indexTablePos, 2);\n            cnt = buffer.readUshort();\n            for (i = 0; i < cnt; i++) {\n                nextPos = buffer.readUshort();\n                nextPos += buffer.pos;\n                var itemId = buffer.readS();\n                pi = this._itemsById[buffer.readS()];\n                var sprite = new AtlasSprite();\n                sprite.atlas = pi;\n                sprite.rect.x = buffer.readInt();\n                sprite.rect.y = buffer.readInt();\n                sprite.rect.width = buffer.readInt();\n                sprite.rect.height = buffer.readInt();\n                sprite.rotated = buffer.readBool();\n                if (ver2 && buffer.readBool()) {\n                    sprite.offset.x = buffer.readInt();\n                    sprite.offset.y = buffer.readInt();\n                    sprite.originalSize.x = buffer.readInt();\n                    sprite.originalSize.y = buffer.readInt();\n                }\n                else {\n                    sprite.originalSize.x = sprite.rect.width;\n                    sprite.originalSize.y = sprite.rect.height;\n                }\n                this._sprites[itemId] = sprite;\n                buffer.pos = nextPos;\n            }\n            if (buffer.seek(indexTablePos, 3)) {\n                cnt = buffer.readUshort();\n                for (i = 0; i < cnt; i++) {\n                    nextPos = buffer.readInt();\n                    nextPos += buffer.pos;\n                    pi = this._itemsById[buffer.readS()];\n                    if (pi && pi.type == fgui.PackageItemType.Image) {\n                        pi.pixelHitTestData = new fgui.PixelHitTestData();\n                        pi.pixelHitTestData.load(buffer);\n                    }\n                    buffer.pos = nextPos;\n                }\n            }\n        }\n        dispose() {\n            var cnt = this._items.length;\n            for (var i = 0; i < cnt; i++) {\n                var pi = this._items[i];\n                if (pi.type == fgui.PackageItemType.Atlas) {\n                    if (pi.texture) {\n                        pi.texture.dispose();\n                        pi.texture = null;\n                    }\n                }\n                else if (pi.type == fgui.PackageItemType.Sound) {\n                }\n            }\n        }\n        get id() {\n            return this._id;\n        }\n        get name() {\n            return this._name;\n        }\n        get customId() {\n            return this._customId;\n        }\n        set customId(value) {\n            if (this._customId != null)\n                delete _instById[this._customId];\n            this._customId = value;\n            if (this._customId != null)\n                _instById[this._customId] = this;\n        }\n        createObject(resName, userClass) {\n            var pi = this._itemsByName[resName];\n            if (pi)\n                return this.internalCreateObject(pi, userClass);\n            else\n                return null;\n        }\n        internalCreateObject(item, userClass) {\n            var g = fgui.Decls.UIObjectFactory.newObject(item, userClass);\n            if (g == null)\n                return null;\n            fgui.constructingDepth.n++;\n            g.constructFromResource();\n            fgui.constructingDepth.n--;\n            return g;\n        }\n        getItemById(itemId) {\n            return this._itemsById[itemId];\n        }\n        getItemByName(resName) {\n            return this._itemsByName[resName];\n        }\n        getItemAssetByName(resName) {\n            var pi = this._itemsByName[resName];\n            if (pi == null) {\n                throw \"Resource not found -\" + resName;\n            }\n            return this.getItemAsset(pi);\n        }\n        getItemAsset(item) {\n            switch (item.type) {\n                case fgui.PackageItemType.Image:\n                    if (!item.decoded) {\n                        item.decoded = true;\n                        var sprite = this._sprites[item.id];\n                        if (sprite) {\n                            var atlasTexture = (this.getItemAsset(sprite.atlas));\n                            item.texture = atlasTexture.createSubTexture(sprite.rect, sprite.rotated, sprite.offset, sprite.originalSize);\n                        }\n                        else\n                            item.texture = null;\n                    }\n                    return item.texture;\n                case fgui.PackageItemType.Atlas:\n                    return item.texture;\n                case fgui.PackageItemType.Font:\n                    if (!item.decoded) {\n                        item.decoded = true;\n                        this.loadFont(item);\n                    }\n                    return item.bitmapFont;\n                case fgui.PackageItemType.MovieClip:\n                    if (!item.decoded) {\n                        item.decoded = true;\n                        this.loadMovieClip(item);\n                    }\n                    return item.frames;\n                case fgui.PackageItemType.Component:\n                    return item.rawData;\n                default:\n                    return null;\n            }\n        }\n        loadMovieClip(item) {\n            var buffer = item.rawData;\n            buffer.seek(0, 0);\n            item.interval = buffer.readInt();\n            item.swing = buffer.readBool();\n            item.repeatDelay = buffer.readInt();\n            buffer.seek(0, 1);\n            var frameCount = buffer.readShort();\n            item.frames = [];\n            var spriteId;\n            var frame;\n            var sprite;\n            var fx;\n            var fy;\n            for (var i = 0; i < frameCount; i++) {\n                var nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                frame = { texture: null };\n                fx = buffer.readInt();\n                fy = buffer.readInt();\n                buffer.readInt();\n                buffer.readInt();\n                frame.addDelay = buffer.readInt();\n                spriteId = buffer.readS();\n                if (spriteId != null && (sprite = this._sprites[spriteId]) != null) {\n                    var atlasTexture = (this.getItemAsset(sprite.atlas));\n                    frame.texture = atlasTexture.createSubTexture(sprite.rect, sprite.rotated, new THREE.Vector2(fx, fy), new THREE.Vector2(item.width, item.height));\n                }\n                item.frames[i] = frame;\n                buffer.pos = nextPos;\n            }\n        }\n        loadFont(item) {\n            item = item.getBranch();\n            var font = new fgui.BitmapFont();\n            font.name = \"ui://\" + this._id + item.id;\n            item.bitmapFont = font;\n            var buffer = item.rawData;\n            buffer.seek(0, 0);\n            let ttf = buffer.readBool();\n            font.tint = buffer.readBool();\n            font.resizable = buffer.readBool();\n            font.hasChannel = buffer.readBool();\n            var fontSize = buffer.readInt();\n            var xadvance = buffer.readInt();\n            var lineHeight = buffer.readInt();\n            var texScaleX = 1;\n            var texScaleY = 1;\n            var bgX;\n            var bgY;\n            var bgWidth;\n            var bgHeight;\n            var mainTexture = null;\n            var mainSprite = ttf ? this._sprites[item.id] : null;\n            if (mainSprite) {\n                mainTexture = (this.getItemAsset(mainSprite.atlas));\n                texScaleX = mainTexture.root.uvRect.width / mainTexture.width;\n                texScaleY = mainTexture.root.uvRect.height / mainTexture.height;\n            }\n            buffer.seek(0, 1);\n            var bg = null;\n            var cnt = buffer.readInt();\n            for (var i = 0; i < cnt; i++) {\n                var nextPos = buffer.readShort();\n                nextPos += buffer.pos;\n                bg = new fgui.BMGlyph();\n                var ch = buffer.readChar();\n                font.glyphs[ch] = bg;\n                var img = buffer.readS();\n                var bx = buffer.readInt();\n                var by = buffer.readInt();\n                bgX = buffer.readInt();\n                bgY = buffer.readInt();\n                bgWidth = buffer.readInt();\n                bgHeight = buffer.readInt();\n                bg.advance = buffer.readInt();\n                bg.channel = buffer.readByte();\n                if (bg.channel == 1)\n                    bg.channel = 2;\n                else if (bg.channel == 2)\n                    bg.channel = 1;\n                else if (bg.channel == 4)\n                    bg.channel = 0;\n                else if (bg.channel == 8)\n                    bg.channel = 3;\n                if (ttf) {\n                    if (mainSprite.rotated) {\n                        bg.uv[0].set((by + bgHeight + mainSprite.rect.x) * texScaleX, 1 - (mainSprite.rect.yMax - bx) * texScaleY);\n                        bg.uv[1].set(bg.uv[0].x - bgHeight * texScaleX, bg.uv[0].y);\n                        bg.uv[2].set(bg.uv[1].x, bg.uv[0].y + bgWidth * texScaleY);\n                        bg.uv[3].set(bg.uv[0].x, bg.uv[2].y);\n                    }\n                    else {\n                        bg.uv[0].set((bx + mainSprite.rect.x) * texScaleX, 1 - (by + bgHeight + mainSprite.rect.y) * texScaleY);\n                        bg.uv[1].set(bg.uv[0].x, bg.uv[0].y + bgHeight * texScaleY);\n                        bg.uv[2].set(bg.uv[0].x + bgWidth * texScaleX, bg.uv[1].y);\n                        bg.uv[3].set(bg.uv[2].x, bg.uv[0].y);\n                    }\n                    bg.lineHeight = lineHeight;\n                    bg.x = bgX;\n                    bg.y = bgY;\n                    bg.width = bgWidth;\n                    bg.height = bgHeight;\n                }\n                else {\n                    var charImg = this._itemsById[img];\n                    if (charImg) {\n                        charImg = charImg.getBranch();\n                        bgWidth = charImg.width;\n                        bgHeight = charImg.height;\n                        charImg = charImg.getHighResolution();\n                        this.getItemAsset(charImg);\n                        charImg.texture.getUV(bg.uv);\n                        texScaleX = bgWidth / charImg.width;\n                        texScaleY = bgHeight / charImg.height;\n                        bg.x = bgX + charImg.texture.offset.x * texScaleX;\n                        bg.y = bgY + charImg.texture.offset.y * texScaleY;\n                        bg.width = charImg.texture.width * texScaleX;\n                        bg.height = charImg.texture.height * texScaleY;\n                        if (!mainTexture)\n                            mainTexture = charImg.texture.root;\n                    }\n                    if (fontSize == 0)\n                        fontSize = bgHeight;\n                    if (bg.advance == 0) {\n                        if (xadvance == 0)\n                            bg.advance = bgX + bgWidth;\n                        else\n                            bg.advance = xadvance;\n                    }\n                    bg.lineHeight = bgY < 0 ? bgHeight : (bgY + bgHeight);\n                    if (bg.lineHeight < font.size)\n                        bg.lineHeight = font.size;\n                }\n                buffer.pos = nextPos;\n            }\n            font.size = fontSize;\n            font.mainTexture = mainTexture;\n        }\n    }\n    fgui.UIPackage = UIPackage;\n    class AtlasSprite {\n        constructor() {\n            this.rect = new fgui.Rect();\n            this.offset = new THREE.Vector2;\n            this.originalSize = new THREE.Vector2;\n        }\n    }\n    var _instById = {};\n    var _instByName = {};\n    var _branch = \"\";\n    var _vars = {};\n    fgui.FontManager.packageFontGetter = name => UIPackage.getItemAssetByURL(name);\n    function loadTexture(pi, onProgress) {\n        return new Promise((resolve, reject) => {\n            new THREE.TextureLoader().load(pi.file, texture => {\n                texture.generateMipmaps = false;\n                texture.magFilter = THREE.LinearFilter;\n                texture.minFilter = THREE.LinearFilter;\n                pi.texture = new fgui.NTexture(texture);\n                resolve();\n            }, onProgress, ev => {\n                reject(ev.message);\n            });\n        });\n    }\n    function loadSound(pi, onProgress) {\n        return new Promise((resolve, reject) => {\n            new THREE.AudioLoader().load(pi.file, buffer => {\n                pi.audioBuffer = buffer;\n                resolve();\n            }, onProgress, ev => {\n                reject(ev.message);\n            });\n        });\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Window extends fgui.GComponent {\n        constructor() {\n            super();\n            this._requestingCmd = 0;\n            this._uiSources = [];\n            this.bringToFontOnClick = fgui.UIConfig.bringWindowToFrontOnClick;\n            this.on(fgui.StageEvent.AddtoStage, this.__onShown, this);\n            this.on(fgui.StageEvent.RemoveFromStage, this.__onHidden, this);\n            this.on(fgui.InteractiveEvents.Down, this.__winTouchBegin, this);\n        }\n        addUISource(source) {\n            this._uiSources.push(source);\n        }\n        set contentPane(val) {\n            if (this._contentPane != val) {\n                if (this._contentPane)\n                    this.removeChild(this._contentPane);\n                this._contentPane = val;\n                if (this._contentPane) {\n                    this.addChild(this._contentPane);\n                    this.setSize(this._contentPane.width, this._contentPane.height);\n                    this._contentPane.addRelation(this, fgui.RelationType.Size);\n                    this._frame = (this._contentPane.getChild(\"frame\"));\n                    if (this._frame) {\n                        this.closeButton = this._frame.getChild(\"closeButton\");\n                        this.dragArea = this._frame.getChild(\"dragArea\");\n                        this.contentArea = this._frame.getChild(\"contentArea\");\n                    }\n                }\n            }\n        }\n        get contentPane() {\n            return this._contentPane;\n        }\n        get frame() {\n            return this._frame;\n        }\n        get closeButton() {\n            return this._closeButton;\n        }\n        set closeButton(value) {\n            if (this._closeButton)\n                this._closeButton.offClick(this.closeEventHandler, this);\n            this._closeButton = value;\n            if (this._closeButton)\n                this._closeButton.onClick(this.closeEventHandler, this);\n        }\n        get dragArea() {\n            return this._dragArea;\n        }\n        set dragArea(value) {\n            if (this._dragArea != value) {\n                if (this._dragArea) {\n                    this._dragArea.draggable = false;\n                    this._dragArea.off(fgui.DragEvent.START, this.__dragStart, this);\n                }\n                this._dragArea = value;\n                if (this._dragArea) {\n                    if (this._dragArea instanceof fgui.GGraph)\n                        this._dragArea.shape.drawRect(0, new fgui.Color4(0, 0), new fgui.Color4(0, 0));\n                    this._dragArea.draggable = true;\n                    this._dragArea.on(fgui.DragEvent.START, this.__dragStart, this);\n                }\n            }\n        }\n        get contentArea() {\n            return this._contentArea;\n        }\n        set contentArea(value) {\n            this._contentArea = value;\n        }\n        show() {\n            fgui.GRoot.inst.showWindow(this);\n        }\n        showOn(root) {\n            root.showWindow(this);\n        }\n        hide() {\n            if (this.isShowing)\n                this.doHideAnimation();\n        }\n        hideImmediately() {\n            var r = fgui.GRoot.findFor(this.parent);\n            r.hideWindowImmediately(this);\n        }\n        centerOn(r, restraint) {\n            this.setPosition(Math.round((r.width - this.width) / 2), Math.round((r.height - this.height) / 2));\n            if (restraint) {\n                this.addRelation(r, fgui.RelationType.Center_Center);\n                this.addRelation(r, fgui.RelationType.Middle_Middle);\n            }\n        }\n        toggleStatus() {\n            if (this.isTop)\n                this.hide();\n            else\n                this.show();\n        }\n        get isShowing() {\n            return this.parent != null;\n        }\n        get isTop() {\n            return this.parent && this.parent.getChildIndex(this) == this.parent.numChildren - 1;\n        }\n        get modal() {\n            return this._modal;\n        }\n        set modal(val) {\n            this._modal = val;\n        }\n        bringToFront() {\n            fgui.GRoot.findFor(this).bringToFront(this);\n        }\n        showModalWait(requestingCmd) {\n            if (requestingCmd && requestingCmd != 0)\n                this._requestingCmd = requestingCmd;\n            if (fgui.UIConfig.windowModalWaiting) {\n                if (!this._modalWaitPane)\n                    this._modalWaitPane = fgui.UIPackage.createObjectFromURL(fgui.UIConfig.windowModalWaiting);\n                this.layoutModalWaitPane();\n                this.addChild(this._modalWaitPane);\n            }\n        }\n        layoutModalWaitPane() {\n            if (this._contentArea) {\n                var pt = this._frame.localToGlobal();\n                pt = this.globalToLocal(pt.x, pt.y, pt);\n                this._modalWaitPane.setPosition(pt.x + this._contentArea.x, pt.y + this._contentArea.y);\n                this._modalWaitPane.setSize(this._contentArea.width, this._contentArea.height);\n            }\n            else\n                this._modalWaitPane.setSize(this.width, this.height);\n        }\n        closeModalWait(requestingCmd) {\n            if (requestingCmd && requestingCmd != 0) {\n                if (this._requestingCmd != requestingCmd)\n                    return false;\n            }\n            this._requestingCmd = 0;\n            if (this.modalWaiting)\n                this.removeChild(this._modalWaitPane);\n            return true;\n        }\n        get modalWaiting() {\n            return this._modalWaitPane != null && this._modalWaitPane.parent != null;\n        }\n        init() {\n            if (this._inited || this._loading)\n                return;\n            if (this._uiSources.length > 0) {\n                this._loading = false;\n                var cnt = this._uiSources.length;\n                for (var i = 0; i < cnt; i++) {\n                    var lib = this._uiSources[i];\n                    if (!lib.loaded) {\n                        lib.load(this.__uiLoadComplete, this);\n                        this._loading = true;\n                    }\n                }\n                if (!this._loading)\n                    this._init();\n            }\n            else\n                this._init();\n        }\n        onInit() {\n        }\n        onShown() {\n        }\n        onHide() {\n        }\n        doShowAnimation() {\n            this.onShown();\n        }\n        doHideAnimation() {\n            this.hideImmediately();\n        }\n        __uiLoadComplete() {\n            var cnt = this._uiSources.length;\n            for (var i = 0; i < cnt; i++) {\n                var lib = this._uiSources[i];\n                if (!lib.loaded)\n                    return;\n            }\n            this._loading = false;\n            this._init();\n        }\n        _init() {\n            this._inited = true;\n            this.onInit();\n            if (this.isShowing)\n                this.doShowAnimation();\n        }\n        dispose() {\n            if (this.parent)\n                this.hideImmediately();\n            super.dispose();\n        }\n        closeEventHandler() {\n            this.hide();\n        }\n        __onShown() {\n            if (!this._inited)\n                this.init();\n            else\n                this.doShowAnimation();\n        }\n        __onHidden() {\n            this.closeModalWait();\n            this.onHide();\n        }\n        __winTouchBegin() {\n            if (this.isShowing && this.bringToFontOnClick)\n                this.bringToFront();\n        }\n        __dragStart(evt) {\n            evt.preventDefault();\n            this.startDrag();\n        }\n    }\n    fgui.Window = Window;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class ByteBuffer {\n        constructor(buffer, offset, length) {\n            this.version = 0;\n            offset = offset || 0;\n            if (length == null || length == -1)\n                length = buffer.byteLength - offset;\n            this._buffer = buffer;\n            this._view = new DataView(this._buffer, offset, length);\n            this._pos = 0;\n            this._length = length;\n        }\n        get data() {\n            return this._buffer;\n        }\n        get pos() {\n            return this._pos;\n        }\n        set pos(value) {\n            if (value > this._length)\n                throw \"Out of bounds\";\n            this._pos = value;\n        }\n        get length() {\n            return this._length;\n        }\n        skip(count) {\n            this._pos += count;\n        }\n        validate(forward) {\n            if (this._pos + forward > this._length)\n                throw \"Out of bounds\";\n        }\n        readByte() {\n            this.validate(1);\n            let ret = this._view.getUint8(this._pos);\n            this._pos++;\n            return ret;\n        }\n        readBool() {\n            return this.readByte() == 1;\n        }\n        readShort() {\n            this.validate(2);\n            let ret = this._view.getInt16(this._pos, this.littleEndian);\n            this._pos += 2;\n            return ret;\n        }\n        readUshort() {\n            this.validate(2);\n            let ret = this._view.getUint16(this._pos, this.littleEndian);\n            this._pos += 2;\n            return ret;\n        }\n        readInt() {\n            this.validate(4);\n            let ret = this._view.getInt32(this._pos, this.littleEndian);\n            this._pos += 4;\n            return ret;\n        }\n        readUint() {\n            this.validate(4);\n            let ret = this._view.getUint32(this._pos, this.littleEndian);\n            this._pos += 4;\n            return ret;\n        }\n        readFloat() {\n            this.validate(4);\n            let ret = this._view.getFloat32(this._pos, this.littleEndian);\n            this._pos += 4;\n            return ret;\n        }\n        readString(len) {\n            if (len == undefined)\n                len = this.readUshort();\n            this.validate(len);\n            let decoder = new TextDecoder();\n            let ret = decoder.decode(new DataView(this._buffer, this._view.byteOffset + this._pos, len));\n            this._pos += len;\n            return ret;\n        }\n        readS() {\n            var index = this.readUshort();\n            if (index == 65534)\n                return null;\n            else if (index == 65533)\n                return \"\";\n            else\n                return this.stringTable[index];\n        }\n        readSArray(cnt) {\n            var ret = new Array(cnt);\n            for (var i = 0; i < cnt; i++)\n                ret[i] = this.readS();\n            return ret;\n        }\n        writeS(value) {\n            var index = this.readUshort();\n            if (index != 65534 && index != 65533)\n                this.stringTable[index] = value;\n        }\n        readColor() {\n            var r = this.readByte();\n            var g = this.readByte();\n            var b = this.readByte();\n            this.readByte();\n            return (r << 16) + (g << 8) + b;\n        }\n        readFullColor() {\n            var r = this.readByte();\n            var g = this.readByte();\n            var b = this.readByte();\n            var a = this.readByte();\n            return new fgui.Color4((r << 16) + (g << 8) + b, a / 255);\n        }\n        readChar() {\n            var i = this.readUshort();\n            return String.fromCharCode(i);\n        }\n        readBuffer() {\n            var count = this.readUint();\n            this.validate(count);\n            var ba = new ByteBuffer(this._buffer, this._view.byteOffset + this._pos, count);\n            ba.stringTable = this.stringTable;\n            ba.version = this.version;\n            this._pos += count;\n            return ba;\n        }\n        seek(indexTablePos, blockIndex) {\n            var tmp = this._pos;\n            this._pos = indexTablePos;\n            var segCount = this.readByte();\n            if (blockIndex < segCount) {\n                var useShort = this.readByte() == 1;\n                var newPos;\n                if (useShort) {\n                    this._pos += 2 * blockIndex;\n                    newPos = this.readUshort();\n                }\n                else {\n                    this._pos += 4 * blockIndex;\n                    newPos = this.readUint();\n                }\n                if (newPos > 0) {\n                    this._pos = indexTablePos + newPos;\n                    return true;\n                }\n                else {\n                    this._pos = tmp;\n                    return false;\n                }\n            }\n            else {\n                this._pos = tmp;\n                return false;\n            }\n        }\n    }\n    fgui.ByteBuffer = ByteBuffer;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    const LUMA_R = 0.299;\n    const LUMA_G = 0.587;\n    const LUMA_B = 0.114;\n    const IDENTITY_MATRIX = [\n        1, 0, 0, 0, 0,\n        0, 1, 0, 0, 0,\n        0, 0, 1, 0, 0,\n        0, 0, 0, 1, 0\n    ];\n    const LENGTH = IDENTITY_MATRIX.length;\n    class ColorMatrix {\n        constructor() {\n            this.matrix = new Array(LENGTH);\n            this.reset();\n        }\n        static create(p_brightness, p_contrast, p_saturation, p_hue) {\n            var ret = new ColorMatrix();\n            ret.adjustColor(p_brightness, p_contrast, p_saturation, p_hue);\n            return ret;\n        }\n        static getMatrix(p_brightness, p_contrast, p_saturation, p_hue, result) {\n            if (!result)\n                result = new Array(ColorMatrix.length);\n            let mat = helper;\n            mat.reset();\n            mat.adjustColor(p_brightness, p_contrast, p_saturation, p_hue);\n            var l = LENGTH;\n            for (var i = 0; i < l; i++) {\n                result[i] = mat.matrix[i];\n            }\n            return result;\n        }\n        reset() {\n            for (var i = 0; i < LENGTH; i++) {\n                this.matrix[i] = IDENTITY_MATRIX[i];\n            }\n        }\n        invert() {\n            this.multiplyMatrix([-1, 0, 0, 0, 255,\n                0, -1, 0, 0, 255,\n                0, 0, -1, 0, 255,\n                0, 0, 0, 1, 0]);\n        }\n        adjustColor(p_brightness, p_contrast, p_saturation, p_hue) {\n            this.adjustBrightness(p_brightness);\n            this.adjustContrast(p_contrast);\n            this.adjustSaturation(p_saturation);\n            this.adjustHue(p_hue);\n        }\n        adjustBrightness(p_val) {\n            p_val = this.cleanValue(p_val, 1) * 255;\n            this.multiplyMatrix([\n                1, 0, 0, 0, p_val,\n                0, 1, 0, 0, p_val,\n                0, 0, 1, 0, p_val,\n                0, 0, 0, 1, 0\n            ]);\n        }\n        adjustContrast(p_val) {\n            p_val = this.cleanValue(p_val, 1);\n            var s = p_val + 1;\n            var o = 128 * (1 - s);\n            this.multiplyMatrix([\n                s, 0, 0, 0, o,\n                0, s, 0, 0, o,\n                0, 0, s, 0, o,\n                0, 0, 0, 1, 0\n            ]);\n        }\n        adjustSaturation(p_val) {\n            p_val = this.cleanValue(p_val, 1);\n            p_val += 1;\n            var invSat = 1 - p_val;\n            var invLumR = invSat * LUMA_R;\n            var invLumG = invSat * LUMA_G;\n            var invLumB = invSat * LUMA_B;\n            this.multiplyMatrix([\n                (invLumR + p_val), invLumG, invLumB, 0, 0,\n                invLumR, (invLumG + p_val), invLumB, 0, 0,\n                invLumR, invLumG, (invLumB + p_val), 0, 0,\n                0, 0, 0, 1, 0\n            ]);\n        }\n        adjustHue(p_val) {\n            p_val = this.cleanValue(p_val, 1);\n            p_val *= Math.PI;\n            var cos = Math.cos(p_val);\n            var sin = Math.sin(p_val);\n            this.multiplyMatrix([\n                ((LUMA_R + (cos * (1 - LUMA_R))) + (sin * -(LUMA_R))), ((LUMA_G + (cos * -(LUMA_G))) + (sin * -(LUMA_G))), ((LUMA_B + (cos * -(LUMA_B))) + (sin * (1 - LUMA_B))), 0, 0,\n                ((LUMA_R + (cos * -(LUMA_R))) + (sin * 0.143)), ((LUMA_G + (cos * (1 - LUMA_G))) + (sin * 0.14)), ((LUMA_B + (cos * -(LUMA_B))) + (sin * -0.283)), 0, 0,\n                ((LUMA_R + (cos * -(LUMA_R))) + (sin * -((1 - LUMA_R)))), ((LUMA_G + (cos * -(LUMA_G))) + (sin * LUMA_G)), ((LUMA_B + (cos * (1 - LUMA_B))) + (sin * LUMA_B)), 0, 0,\n                0, 0, 0, 1, 0\n            ]);\n        }\n        concat(p_matrix) {\n            if (p_matrix.length != LENGTH) {\n                return;\n            }\n            this.multiplyMatrix(p_matrix);\n        }\n        clone() {\n            var result = new ColorMatrix();\n            result.copyMatrix(this.matrix);\n            return result;\n        }\n        copyMatrix(p_matrix) {\n            var l = LENGTH;\n            for (var i = 0; i < l; i++) {\n                this.matrix[i] = p_matrix[i];\n            }\n        }\n        multiplyMatrix(p_matrix) {\n            var col = [];\n            var i = 0;\n            for (var y = 0; y < 4; ++y) {\n                for (var x = 0; x < 5; ++x) {\n                    col[i + x] = p_matrix[i] * this.matrix[x] +\n                        p_matrix[i + 1] * this.matrix[x + 5] +\n                        p_matrix[i + 2] * this.matrix[x + 10] +\n                        p_matrix[i + 3] * this.matrix[x + 15] +\n                        (x == 4 ? p_matrix[i + 4] : 0);\n                }\n                i += 5;\n            }\n            this.copyMatrix(col);\n        }\n        cleanValue(p_val, p_limit) {\n            return Math.min(p_limit, Math.max(-p_limit, p_val));\n        }\n    }\n    fgui.ColorMatrix = ColorMatrix;\n    let helper = new ColorMatrix();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class Timers {\n        static add(delayInMiniseconds, repeat, callback, target, callbackParam) {\n            let item;\n            let index = _items.findIndex(e => e.target == target && e.callback == callback);\n            if (index != -1)\n                item = _items[index];\n            else {\n                item = _pool.borrow();\n                item.callback = callback;\n                item.target = target;\n                _items.push(item);\n            }\n            item.delay = delayInMiniseconds;\n            item.counter = 0;\n            item.repeat = repeat;\n            item.param = callbackParam;\n            item.end = false;\n        }\n        static callLater(callback, target, callbackParam) {\n            this.add(0, 1, callback, target, callbackParam);\n        }\n        static callDelay(delay, callback, target, callbackParam) {\n            this.add(delay, 1, callback, target, callbackParam);\n        }\n        static addUpdate(callback, target, callbackParam) {\n            this.add(0, 0, callback, target, callbackParam);\n        }\n        static exists(callback, target) {\n            return _items.findIndex(e => e.target == target && e.callback == callback) != -1;\n        }\n        static remove(callback, target) {\n            let index = _items.findIndex(e => e.target == target && e.callback == callback);\n            if (index != -1) {\n                let item = _items[index];\n                _items.splice(index, 1);\n                if (index < _enumI)\n                    _enumI--;\n                _enumCount--;\n                _pool.returns(item);\n            }\n        }\n    }\n    Timers.deltaTime = 0;\n    Timers.time = 0;\n    Timers.frameCount = 0;\n    fgui.Timers = Timers;\n    class TimerItem {\n        constructor() {\n            this.delay = 0;\n            this.counter = 0;\n            this.repeat = 0;\n        }\n        advance(elapsed) {\n            this.counter += elapsed;\n            if (this.counter >= this.delay) {\n                this.counter -= this.delay;\n                if (this.counter > this.delay)\n                    this.counter = this.delay;\n                if (this.repeat > 0) {\n                    this.repeat--;\n                    if (this.repeat == 0)\n                        this.end = true;\n                }\n                return true;\n            }\n            else\n                return false;\n        }\n        reset() {\n            this.callback = null;\n            this.target = null;\n            this.param = null;\n        }\n    }\n    var _items = new Array();\n    var _pool = new fgui.Pool(TimerItem, e => e.reset());\n    var _enumI = 0;\n    var _enumCount = 0;\n    var _lastTime = 0;\n    requestAnimationFrame(__timer);\n    function __timer(timeStamp) {\n        requestAnimationFrame(__timer);\n        Timers.frameCount++;\n        Timers.time = timeStamp;\n        let deltaTime = timeStamp - _lastTime;\n        Timers.deltaTime = deltaTime;\n        _lastTime = timeStamp;\n        _enumI = 0;\n        _enumCount = _items.length;\n        while (_enumI < _enumCount) {\n            var item = _items[_enumI];\n            _enumI++;\n            if (item.advance(deltaTime)) {\n                if (item.end) {\n                    _enumI--;\n                    _enumCount--;\n                    _items.splice(_enumI, 1);\n                }\n                item.callback.call(item.target, item.param);\n                if (item.end)\n                    _pool.returns(item);\n            }\n        }\n        return false;\n    }\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    function convertToHtmlColor(argb, hasAlpha) {\n        var alpha;\n        if (hasAlpha)\n            alpha = (argb >> 24 & 0xFF).toString(16);\n        else\n            alpha = \"\";\n        var red = (argb >> 16 & 0xFF).toString(16);\n        var green = (argb >> 8 & 0xFF).toString(16);\n        var blue = (argb & 0xFF).toString(16);\n        if (alpha.length == 1)\n            alpha = \"0\" + alpha;\n        if (red.length == 1)\n            red = \"0\" + red;\n        if (green.length == 1)\n            green = \"0\" + green;\n        if (blue.length == 1)\n            blue = \"0\" + blue;\n        return \"#\" + alpha + red + green + blue;\n    }\n    fgui.convertToHtmlColor = convertToHtmlColor;\n    function convertFromHtmlColor(str, hasAlpha) {\n        if (str.length < 1)\n            return 0;\n        if (str.charAt(0) == \"#\")\n            str = str.substr(1);\n        if (str.length == 8)\n            return (parseInt(str.substr(0, 2), 16) << 24) + parseInt(str.substr(2), 16);\n        else if (hasAlpha)\n            return 0xFF000000 + parseInt(str, 16);\n        else\n            return parseInt(str, 16);\n    }\n    fgui.convertFromHtmlColor = convertFromHtmlColor;\n    function clamp(value, min, max) {\n        if (value < min)\n            value = min;\n        else if (value > max)\n            value = max;\n        return value;\n    }\n    fgui.clamp = clamp;\n    function clamp01(value) {\n        if (isNaN(value))\n            value = 0;\n        else if (value > 1)\n            value = 1;\n        else if (value < 0)\n            value = 0;\n        return value;\n    }\n    fgui.clamp01 = clamp01;\n    function lerp(start, end, percent) {\n        return (start + percent * (end - start));\n    }\n    fgui.lerp = lerp;\n    function repeat(t, length) {\n        return t - Math.floor(t / length) * length;\n    }\n    fgui.repeat = repeat;\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n    }\n    fgui.distance = distance;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class UBBParser {\n        constructor() {\n            this._readPos = 0;\n            this.defaultImgWidth = 0;\n            this.defaultImgHeight = 0;\n            this._handlers = {};\n            this._handlers[\"url\"] = this.onTag_URL;\n            this._handlers[\"img\"] = this.onTag_IMG;\n            this._handlers[\"b\"] = this.onTag_B;\n            this._handlers[\"i\"] = this.onTag_I;\n            this._handlers[\"u\"] = this.onTag_U;\n            this._handlers[\"sup\"] = this.onTag_Simple;\n            this._handlers[\"sub\"] = this.onTag_Simple;\n            this._handlers[\"color\"] = this.onTag_COLOR;\n            this._handlers[\"font\"] = this.onTag_FONT;\n            this._handlers[\"size\"] = this.onTag_SIZE;\n        }\n        onTag_URL(tagName, end, attr) {\n            if (!end) {\n                if (attr != null)\n                    return \"<a href=\\\"\" + attr + \"\\\">\";\n                else {\n                    var href = this.getTagText();\n                    return \"<a href=\\\"\" + href + \"\\\">\";\n                }\n            }\n            else\n                return \"</a>\";\n        }\n        onTag_IMG(tagName, end, attr) {\n            if (!end) {\n                var src = this.getTagText(true);\n                if (!src)\n                    return null;\n                if (this.defaultImgWidth)\n                    return \"<img src=\\\"\" + src + \"\\\" width=\\\"\" + this.defaultImgWidth + \"\\\" height=\\\"\" + this.defaultImgHeight + \"\\\"/>\";\n                else\n                    return \"<img src=\\\"\" + src + \"\\\"/>\";\n            }\n            else\n                return null;\n        }\n        onTag_B(tagName, end, attr) {\n            return end ? (\"</b>\") : (\"<b>\");\n        }\n        onTag_I(tagName, end, attr) {\n            return end ? (\"</i>\") : (\"<i>\");\n        }\n        onTag_U(tagName, end, attr) {\n            return end ? (\"</u>\") : (\"<u>\");\n        }\n        onTag_Simple(tagName, end, attr) {\n            return end ? (\"</\" + tagName + \">\") : (\"<\" + tagName + \">\");\n        }\n        onTag_COLOR(tagName, end, attr) {\n            if (!end) {\n                this.lastColor = attr;\n                return \"<font color=\\\"\" + attr + \"\\\">\";\n            }\n            else\n                return \"</font>\";\n        }\n        onTag_FONT(tagName, end, attr) {\n            if (!end)\n                return \"<font face=\\\"\" + attr + \"\\\">\";\n            else\n                return \"</font>\";\n        }\n        onTag_SIZE(tagName, end, attr) {\n            if (!end) {\n                this.lastSize = attr;\n                return \"<font size=\\\"\" + attr + \"\\\">\";\n            }\n            else\n                return \"</font>\";\n        }\n        getTagText(remove) {\n            var pos1 = this._readPos;\n            var pos2;\n            var result = \"\";\n            while ((pos2 = this._text.indexOf(\"[\", pos1)) != -1) {\n                if (this._text.charCodeAt(pos2 - 1) == 92) {\n                    result += this._text.substring(pos1, pos2 - 1);\n                    result += \"[\";\n                    pos1 = pos2 + 1;\n                }\n                else {\n                    result += this._text.substring(pos1, pos2);\n                    break;\n                }\n            }\n            if (pos2 == -1)\n                return null;\n            if (remove)\n                this._readPos = pos2;\n            return result;\n        }\n        parse(text, remove) {\n            this._text = text;\n            this.lastColor = null;\n            this.lastSize = null;\n            var pos1 = 0, pos2, pos3;\n            var end;\n            var tag, attr;\n            var repl;\n            var func;\n            var result = \"\";\n            while ((pos2 = this._text.indexOf(\"[\", pos1)) != -1) {\n                if (pos2 > 0 && this._text.charCodeAt(pos2 - 1) == 92) {\n                    result += this._text.substring(pos1, pos2 - 1);\n                    result += \"[\";\n                    pos1 = pos2 + 1;\n                    continue;\n                }\n                result += this._text.substring(pos1, pos2);\n                pos1 = pos2;\n                pos2 = this._text.indexOf(\"]\", pos1);\n                if (pos2 == -1)\n                    break;\n                end = this._text.charAt(pos1 + 1) == '/';\n                tag = this._text.substring(end ? pos1 + 2 : pos1 + 1, pos2);\n                this._readPos = pos2 + 1;\n                attr = null;\n                repl = null;\n                pos3 = tag.indexOf(\"=\");\n                if (pos3 != -1) {\n                    attr = tag.substring(pos3 + 1);\n                    tag = tag.substring(0, pos3);\n                }\n                tag = tag.toLowerCase();\n                func = this._handlers[tag];\n                if (func != null) {\n                    if (!remove) {\n                        repl = func.call(this, tag, end, attr);\n                        if (repl != null)\n                            result += repl;\n                    }\n                }\n                else\n                    result += this._text.substring(pos1, this._readPos);\n                pos1 = this._readPos;\n            }\n            if (pos1 < this._text.length)\n                result += this._text.substr(pos1);\n            this._text = null;\n            return result;\n        }\n    }\n    fgui.UBBParser = UBBParser;\n    fgui.defaultParser = new UBBParser();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let HtmlElementType;\n    (function (HtmlElementType) {\n        HtmlElementType[HtmlElementType[\"Text\"] = 0] = \"Text\";\n        HtmlElementType[HtmlElementType[\"Link\"] = 1] = \"Link\";\n        HtmlElementType[HtmlElementType[\"Image\"] = 2] = \"Image\";\n        HtmlElementType[HtmlElementType[\"Input\"] = 3] = \"Input\";\n        HtmlElementType[HtmlElementType[\"Select\"] = 4] = \"Select\";\n        HtmlElementType[HtmlElementType[\"Object\"] = 5] = \"Object\";\n        HtmlElementType[HtmlElementType[\"LinkEnd\"] = 6] = \"LinkEnd\";\n    })(HtmlElementType = fgui.HtmlElementType || (fgui.HtmlElementType = {}));\n    class HtmlElement {\n        constructor() {\n            this.format = new fgui.TextFormat();\n            this.position = new THREE.Vector2();\n        }\n        getAttr(attrName) {\n            if (this._attributes == null)\n                return null;\n            return this._attributes[attrName];\n        }\n        setAttr(attrName, attrValue) {\n            if (this._attributes == null)\n                this._attributes = {};\n            this._attributes[attrName] = attrValue;\n        }\n        getAttrString(attrName, defValue) {\n            return fgui.XMLUtils.getString(this._attributes, attrName, defValue);\n        }\n        getAttrInt(attrName, defValue) {\n            return fgui.XMLUtils.getInt(this._attributes, attrName, defValue);\n        }\n        getAttrFloat(attrName, defValue) {\n            return fgui.XMLUtils.getFloat(this._attributes, attrName, defValue);\n        }\n        getAttrBool(attrName, defValue) {\n            return fgui.XMLUtils.getBool(this._attributes, attrName, defValue);\n        }\n        getAttrColor(attrName, defValue) {\n            return fgui.XMLUtils.getColor(this._attributes, attrName, defValue);\n        }\n        fetchAttributes() {\n            this._attributes = fgui.XMLIterator.getAttributes(this._attributes);\n        }\n        get isEntity() {\n            return this.type == HtmlElementType.Image || this.type == HtmlElementType.Select\n                || this.type == HtmlElementType.Input || this.type == HtmlElementType.Object;\n        }\n        reset() {\n            this.name = null;\n            this.text = null;\n            this.htmlObject = null;\n            this.status = 0;\n            this._attributes = null;\n        }\n    }\n    fgui.HtmlElement = HtmlElement;\n    fgui.elementPool = new fgui.Pool(HtmlElement, (element, ...argArray) => {\n        element.type = argArray[0];\n        if (element.type != HtmlElementType.Text && element._attributes == null)\n            element._attributes = {};\n    }, element => element.reset());\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class HtmlImage {\n        constructor() {\n            this.loader = fgui.Decls.UIObjectFactory.newObject(fgui.ObjectType.Loader);\n            this.loader.fill = fgui.LoaderFillType.ScaleFree;\n            this.loader.touchable = false;\n        }\n        get displayObject() {\n            return this.loader.displayObject;\n        }\n        get element() {\n            return this._element;\n        }\n        get width() {\n            return this.loader.width;\n        }\n        get height() {\n            return this.loader.height;\n        }\n        create(owner, element) {\n            this._owner = owner;\n            this._element = element;\n            let sourceWidth = 0;\n            let sourceHeight = 0;\n            let src = element.getAttrString(\"src\");\n            if (src != null) {\n                let pi = fgui.UIPackage.getItemByURL(src);\n                if (pi) {\n                    sourceWidth = pi.width;\n                    sourceHeight = pi.height;\n                }\n            }\n            this.loader.url = src;\n            let width = element.getAttrInt(\"width\", sourceWidth);\n            let height = element.getAttrInt(\"height\", sourceHeight);\n            if (width == 0)\n                width = 5;\n            if (height == 0)\n                height = 10;\n            this.loader.setSize(width, height);\n        }\n        setPosition(x, y) {\n            this.loader.setPosition(x, y);\n        }\n        add() {\n            this._owner.addChild(this.loader.displayObject);\n        }\n        remove() {\n            if (this.loader.displayObject.parent)\n                this._owner.removeChild(this.loader.displayObject);\n        }\n        release() {\n            this.loader.offAll();\n            this.loader.url = null;\n            this._owner = null;\n            this._element = null;\n        }\n        dispose() {\n            this.loader.dispose();\n        }\n    }\n    fgui.HtmlImage = HtmlImage;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class HtmlLink {\n        constructor() {\n            this._shape = new fgui.SelectionShape();\n            this._shape.on(fgui.InteractiveEvents.Click, () => {\n                fgui.bubbleEvent(this._owner.obj3D, fgui.TextEvent.LinkClick, this._element.getAttrString(\"href\"));\n            });\n        }\n        get displayObject() {\n            return this._shape;\n        }\n        get element() {\n            return this._element;\n        }\n        get width() {\n            return 0;\n        }\n        get height() {\n            return 0;\n        }\n        create(owner, element) {\n            this._owner = owner;\n            this._element = element;\n        }\n        setArea(startLine, startCharX, endLine, endCharX) {\n            if (startLine == endLine && startCharX > endCharX) {\n                let tmp = startCharX;\n                startCharX = endCharX;\n                endCharX = tmp;\n            }\n            this._shape.rects.length = 0;\n            this._owner.getLinesShape(startLine, startCharX, endLine, endCharX, true, this._shape.rects);\n            this._shape.refresh();\n        }\n        setPosition(x, y) {\n            this._shape.setPosition(x, y);\n        }\n        add() {\n            this._owner.addChild(this._shape);\n        }\n        remove() {\n            if (this._shape.parent)\n                this._owner.removeChild(this._shape);\n        }\n        release() {\n            this._shape.offAll();\n            this._owner = null;\n            this._element = null;\n        }\n        dispose() {\n            this._shape.dispose();\n        }\n    }\n    fgui.HtmlLink = HtmlLink;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class HtmlPageContext {\n        constructor() {\n            this._imagePool = new fgui.Pool(fgui.HtmlImage);\n            this._linkPool = new fgui.Pool(fgui.HtmlLink);\n        }\n        createObject(owner, element) {\n            let ret = null;\n            if (element.type == fgui.HtmlElementType.Image)\n                ret = this._imagePool.borrow();\n            else if (element.type == fgui.HtmlElementType.Link)\n                ret = this._linkPool.borrow();\n            if (ret)\n                ret.create(owner, element);\n            return ret;\n        }\n        freeObject(obj) {\n            obj.release();\n            if (obj instanceof fgui.HtmlImage)\n                this._imagePool.returns(obj);\n            else if (obj instanceof fgui.HtmlLink)\n                this._linkPool.returns(obj);\n        }\n    }\n    fgui.HtmlPageContext = HtmlPageContext;\n    fgui.defaultContext = new HtmlPageContext();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class HtmlParseOptions {\n        constructor() {\n            this.linkUnderline = HtmlParseOptions.defaultLinkUnderline;\n            this.linkColor = HtmlParseOptions.defaultLinkColor;\n        }\n    }\n    HtmlParseOptions.defaultLinkUnderline = true;\n    HtmlParseOptions.defaultLinkColor = 0x3A67CC;\n    fgui.HtmlParseOptions = HtmlParseOptions;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    var s_list1 = new Array();\n    var s_list2 = new Array();\n    class HtmlParser {\n        constructor() {\n            this._textFormatStack = new Array();\n            this._format = new fgui.TextFormat();\n            this._defaultOptions = new fgui.HtmlParseOptions();\n        }\n        parse(aSource, defaultFormat, elements, parseOptions) {\n            if (parseOptions == null)\n                parseOptions = this._defaultOptions;\n            this._elements = elements;\n            this._textFormatStackTop = 0;\n            this._format.copy(defaultFormat);\n            this._format[\"colorChanged\"] = false;\n            let skipText = 0;\n            let ignoreWhiteSpace = parseOptions.ignoreWhiteSpace;\n            let skipNextCR = false;\n            let text;\n            fgui.XMLIterator.begin(aSource, true);\n            while (fgui.XMLIterator.nextTag()) {\n                if (skipText == 0) {\n                    text = fgui.XMLIterator.getText(ignoreWhiteSpace);\n                    if (text.length > 0) {\n                        if (skipNextCR && text[0] == '\\n')\n                            text = text.substr(1);\n                        this.appendText(text);\n                    }\n                }\n                skipNextCR = false;\n                switch (fgui.XMLIterator.tagName) {\n                    case \"b\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.bold = true;\n                        }\n                        else\n                            this.popTextFormat();\n                        break;\n                    case \"i\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.italic = true;\n                        }\n                        else\n                            this.popTextFormat();\n                        break;\n                    case \"u\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.underline = true;\n                        }\n                        else\n                            this.popTextFormat();\n                        break;\n                    case \"strike\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.strikethrough = true;\n                        }\n                        else\n                            this.popTextFormat();\n                        break;\n                    case \"font\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.size = fgui.XMLUtils.getInt(fgui.XMLIterator.attributes, \"size\", this._format.size);\n                            let color = fgui.XMLIterator.getAttribute(\"color\");\n                            if (color != null)\n                                this._format.color = fgui.convertFromHtmlColor(color);\n                        }\n                        else if (fgui.XMLIterator.tagType == fgui.XMLTagType.End)\n                            this.popTextFormat();\n                        break;\n                    case \"br\":\n                        this.appendText(\"\\n\");\n                        break;\n                    case \"img\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start || fgui.XMLIterator.tagType == fgui.XMLTagType.Void) {\n                            let element = fgui.elementPool.borrow(fgui.HtmlElementType.Image);\n                            element.fetchAttributes();\n                            element.name = element.getAttrString(\"name\");\n                            element.format.align = this._format.align;\n                            this._elements.push(element);\n                        }\n                        break;\n                    case \"a\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.underline = this._format.underline || parseOptions.linkUnderline;\n                            if (!this._format[\"colorChanged\"])\n                                this._format.color = parseOptions.linkColor;\n                            let element = fgui.elementPool.borrow(fgui.HtmlElementType.Link);\n                            element.fetchAttributes();\n                            element.name = element.getAttrString(\"name\");\n                            element.format.align = this._format.align;\n                            this._elements.push(element);\n                        }\n                        else if (fgui.XMLIterator.tagType == fgui.XMLTagType.End) {\n                            this.popTextFormat();\n                            let element = fgui.elementPool.borrow(fgui.HtmlElementType.LinkEnd);\n                            this._elements.push(element);\n                        }\n                        break;\n                    case \"input\":\n                        {\n                            let element = fgui.elementPool.borrow(fgui.HtmlElementType.Input);\n                            element.fetchAttributes();\n                            element.name = element.getAttrString(\"name\");\n                            element.format.copy(this._format);\n                            this._elements.push(element);\n                        }\n                        break;\n                    case \"select\":\n                        {\n                            if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start || fgui.XMLIterator.tagType == fgui.XMLTagType.Void) {\n                                let element = fgui.elementPool.borrow(fgui.HtmlElementType.Select);\n                                element.fetchAttributes();\n                                if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                                    s_list1.length = 0;\n                                    s_list2.length = 0;\n                                    while (fgui.XMLIterator.nextTag()) {\n                                        if (fgui.XMLIterator.tagName == \"select\")\n                                            break;\n                                        if (fgui.XMLIterator.tagName == \"option\") {\n                                            if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start || fgui.XMLIterator.tagType == fgui.XMLTagType.Void)\n                                                s_list2.push(fgui.XMLUtils.getString(fgui.XMLIterator.attributes, \"value\", \"\"));\n                                            else\n                                                s_list1.push(fgui.XMLIterator.getText());\n                                        }\n                                    }\n                                    element.setAttr(\"items\", s_list1.slice());\n                                    element.setAttr(\"values\", s_list2.slice());\n                                }\n                                element.name = element.getAttrString(\"name\");\n                                element.format.copy(this._format);\n                                this._elements.push(element);\n                            }\n                        }\n                        break;\n                    case \"p\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            this.pushTextFormat();\n                            this._format.align = fgui.XMLIterator.getAttribute(\"align\");\n                            if (!this.isNewLine())\n                                this.appendText(\"\\n\");\n                        }\n                        else if (fgui.XMLIterator.tagType == fgui.XMLTagType.End) {\n                            this.appendText(\"\\n\");\n                            skipNextCR = true;\n                            this.popTextFormat();\n                        }\n                        break;\n                    case \"ui\":\n                    case \"div\":\n                    case \"li\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start) {\n                            if (!this.isNewLine())\n                                this.appendText(\"\\n\");\n                        }\n                        else {\n                            this.appendText(\"\\n\");\n                            skipNextCR = true;\n                        }\n                        break;\n                    case \"html\":\n                    case \"body\":\n                        ignoreWhiteSpace = true;\n                        break;\n                    case \"head\":\n                    case \"style\":\n                    case \"script\":\n                    case \"form\":\n                        if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start)\n                            skipText++;\n                        else if (fgui.XMLIterator.tagType == fgui.XMLTagType.End)\n                            skipText--;\n                        break;\n                }\n            }\n            if (skipText == 0) {\n                text = fgui.XMLIterator.getText(ignoreWhiteSpace);\n                if (text.length > 0) {\n                    if (skipNextCR && text[0] == '\\n')\n                        text = text.substr(1);\n                    this.appendText(text);\n                }\n            }\n            this._elements = null;\n        }\n        pushTextFormat() {\n            let tf;\n            if (this._textFormatStack.length <= this._textFormatStackTop) {\n                tf = new fgui.TextFormat();\n                this._textFormatStack.push(tf);\n            }\n            else\n                tf = this._textFormatStack[this._textFormatStackTop];\n            tf.copy(this._format);\n            tf[\"colorChanged\"] = this._format[\"colorChanged\"];\n            this._textFormatStackTop++;\n        }\n        popTextFormat() {\n            if (this._textFormatStackTop > 0) {\n                let tf = this._textFormatStack[this._textFormatStackTop - 1];\n                this._format.copy(tf);\n                this._format[\"colorChanged\"] = tf[\"colorChanged\"];\n                this._textFormatStackTop--;\n            }\n        }\n        isNewLine() {\n            if (this._elements.length > 0) {\n                let element = this._elements[this._elements.length - 1];\n                if (element && element.type == fgui.HtmlElementType.Text)\n                    return element.text.endsWith(\"\\n\");\n                else\n                    return false;\n            }\n            return true;\n        }\n        appendText(text) {\n            let element;\n            if (this._elements.length > 0) {\n                element = this._elements[this._elements.length - 1];\n                if (element.type == fgui.HtmlElementType.Text && element.format.equalStyle(this._format)) {\n                    element.text += text;\n                    return;\n                }\n            }\n            element = fgui.elementPool.borrow(fgui.HtmlElementType.Text);\n            element.text = text;\n            element.format.copy(this._format);\n            this._elements.push(element);\n        }\n    }\n    fgui.HtmlParser = HtmlParser;\n    fgui.htmldefaultParser = new HtmlParser();\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class XML {\n        constructor(XmlString) {\n            if (XmlString)\n                this.parse(XmlString);\n        }\n        get attributes() {\n            if (!this._attributes)\n                this._attributes = {};\n            return this._attributes;\n        }\n        getAttrString(attrName, defValue) {\n            return fgui.XMLUtils.getString(this._attributes, attrName, defValue);\n        }\n        getAttrInt(attrName, defValue) {\n            return fgui.XMLUtils.getInt(this._attributes, attrName, defValue);\n        }\n        getAttrFloat(attrName, defValue) {\n            return fgui.XMLUtils.getFloat(this._attributes, attrName, defValue);\n        }\n        getAttrBool(attrName, defValue) {\n            return fgui.XMLUtils.getBool(this._attributes, attrName, defValue);\n        }\n        getAttrColor(attrName, defValue) {\n            return fgui.XMLUtils.getColor(this._attributes, attrName, defValue);\n        }\n        setAttribute(attrName, attrValue) {\n            if (!this._attributes)\n                this._attributes = {};\n            this._attributes[attrName] = attrValue;\n        }\n        getNode(selector) {\n            if (!this._children)\n                return null;\n            else\n                this._children.find(value => {\n                    return value.name == selector;\n                });\n        }\n        elements(selector) {\n            if (!this._children)\n                this._children = new Array();\n            if (selector)\n                return this._children.filter(value => {\n                    return value.name == selector;\n                });\n            else\n                return this._children;\n        }\n        parse(aSource) {\n            this.reset();\n            let lastOpenNode;\n            let nodeStack = new Array();\n            fgui.XMLIterator.begin(aSource);\n            while (fgui.XMLIterator.nextTag()) {\n                if (fgui.XMLIterator.tagType == fgui.XMLTagType.Start || fgui.XMLIterator.tagType == fgui.XMLTagType.Void) {\n                    let childNode;\n                    if (lastOpenNode)\n                        childNode = new XML();\n                    else {\n                        if (this.name != null) {\n                            this.reset();\n                            throw new Error(\"Invalid xml format - no root node.\");\n                        }\n                        childNode = this;\n                    }\n                    childNode.name = fgui.XMLIterator.tagName;\n                    childNode._attributes = fgui.XMLIterator.getAttributes(childNode._attributes);\n                    if (lastOpenNode) {\n                        if (fgui.XMLIterator.tagType != fgui.XMLTagType.Void)\n                            nodeStack.push(lastOpenNode);\n                        if (lastOpenNode._children == null)\n                            lastOpenNode._children = new Array();\n                        lastOpenNode._children.push(childNode);\n                    }\n                    if (fgui.XMLIterator.tagType != fgui.XMLTagType.Void)\n                        lastOpenNode = childNode;\n                }\n                else if (fgui.XMLIterator.tagType == fgui.XMLTagType.End) {\n                    if (lastOpenNode == null || lastOpenNode.name != fgui.XMLIterator.tagName) {\n                        this.reset();\n                        throw new Error(\"Invalid xml format - <\" + fgui.XMLIterator.tagName + \"> dismatched.\");\n                    }\n                    if (lastOpenNode._children == null || lastOpenNode._children.length == 0) {\n                        lastOpenNode.text = fgui.XMLIterator.getText();\n                    }\n                    if (nodeStack.length > 0)\n                        lastOpenNode = nodeStack.pop();\n                    else\n                        lastOpenNode = null;\n                }\n            }\n        }\n        reset() {\n            this._attributes = null;\n            if (this._children != null)\n                this._children.length == 0;\n            this.text = null;\n        }\n    }\n    fgui.XML = XML;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    let XMLTagType;\n    (function (XMLTagType) {\n        XMLTagType[XMLTagType[\"Start\"] = 0] = \"Start\";\n        XMLTagType[XMLTagType[\"End\"] = 1] = \"End\";\n        XMLTagType[XMLTagType[\"Void\"] = 2] = \"Void\";\n        XMLTagType[XMLTagType[\"CDATA\"] = 3] = \"CDATA\";\n        XMLTagType[XMLTagType[\"Comment\"] = 4] = \"Comment\";\n        XMLTagType[XMLTagType[\"Instruction\"] = 5] = \"Instruction\";\n    })(XMLTagType = fgui.XMLTagType || (fgui.XMLTagType = {}));\n    ;\n    const CDATA_START = \"<![CDATA[\";\n    const CDATA_END = \"]]>\";\n    const COMMENT_START = \"<!--\";\n    const COMMENT_END = \"-->\";\n    class XMLIterator {\n        static begin(source, lowerCaseName) {\n            XMLIterator.source = source;\n            XMLIterator.lowerCaseName = lowerCaseName;\n            this.sourceLen = source.length;\n            this.parsePos = 0;\n            this.lastTagEnd = 0;\n            this.tagPos = 0;\n            this.tagLength = 0;\n            this.tagName = null;\n        }\n        static nextTag() {\n            let pos;\n            let c;\n            let buffer = \"\";\n            this.tagType = XMLTagType.Start;\n            this.lastTagEnd = this.parsePos;\n            this.attrParsed = false;\n            this.lastTagName = this.tagName;\n            while ((pos = this.source.indexOf('<', this.parsePos)) != -1) {\n                this.parsePos = pos;\n                pos++;\n                if (pos == this.sourceLen)\n                    break;\n                c = this.source[pos];\n                if (c == '!') {\n                    if (this.sourceLen > pos + 7 && this.source.substr(pos - 1, 9) == CDATA_START) {\n                        pos = this.source.indexOf(CDATA_END, pos);\n                        this.tagType = XMLTagType.CDATA;\n                        this.tagName = \"\";\n                        this.tagPos = this.parsePos;\n                        if (pos == -1)\n                            this.tagLength = this.sourceLen - this.parsePos;\n                        else\n                            this.tagLength = pos + 3 - this.parsePos;\n                        this.parsePos += this.tagLength;\n                        return true;\n                    }\n                    else if (this.sourceLen > pos + 2 && this.source.substr(pos - 1, 4) == COMMENT_START) {\n                        pos = this.source.indexOf(COMMENT_END, pos);\n                        this.tagType = XMLTagType.Comment;\n                        this.tagName = \"\";\n                        this.tagPos = this.parsePos;\n                        if (pos == -1)\n                            this.tagLength = this.sourceLen - this.parsePos;\n                        else\n                            this.tagLength = pos + 3 - this.parsePos;\n                        this.parsePos += this.tagLength;\n                        return true;\n                    }\n                    else {\n                        pos++;\n                        this.tagType = XMLTagType.Instruction;\n                    }\n                }\n                else if (c == '/') {\n                    pos++;\n                    this.tagType = XMLTagType.End;\n                }\n                else if (c == '?') {\n                    pos++;\n                    this.tagType = XMLTagType.Instruction;\n                }\n                for (; pos < this.sourceLen; pos++) {\n                    c = this.source[pos];\n                    if (' \\t\\n\\r\\v'.indexOf(c) != -1 || c == '>' || c == '/')\n                        break;\n                }\n                if (pos == this.sourceLen)\n                    break;\n                buffer += this.source.substr(this.parsePos + 1, pos - this.parsePos - 1);\n                if (buffer.length > 0 && buffer[0] == '/')\n                    buffer = buffer.substr(1);\n                let singleQuoted = false, doubleQuoted = false;\n                let possibleEnd = -1;\n                for (; pos < this.sourceLen; pos++) {\n                    c = this.source[pos];\n                    if (c == '\"') {\n                        if (!singleQuoted)\n                            doubleQuoted = !doubleQuoted;\n                    }\n                    else if (c == '\\'') {\n                        if (!doubleQuoted)\n                            singleQuoted = !singleQuoted;\n                    }\n                    if (c == '>') {\n                        if (!(singleQuoted || doubleQuoted)) {\n                            possibleEnd = -1;\n                            break;\n                        }\n                        possibleEnd = pos;\n                    }\n                    else if (c == '<')\n                        break;\n                }\n                if (possibleEnd != -1)\n                    pos = possibleEnd;\n                if (pos == this.sourceLen)\n                    break;\n                if (this.source[pos - 1] == '/')\n                    this.tagType = XMLTagType.Void;\n                this.tagName = buffer;\n                if (this.lowerCaseName)\n                    this.tagName = this.tagName.toLowerCase();\n                this.tagPos = this.parsePos;\n                this.tagLength = pos + 1 - this.parsePos;\n                this.parsePos += this.tagLength;\n                return true;\n            }\n            this.tagPos = this.sourceLen;\n            this.tagLength = 0;\n            this.tagName = null;\n            return false;\n        }\n        static getTagSource() {\n            return this.source.substr(this.tagPos, this.tagLength);\n        }\n        static getRawText(trim) {\n            if (this.lastTagEnd == this.tagPos)\n                return \"\";\n            else if (trim) {\n                let i = this.lastTagEnd;\n                for (; i < this.tagPos; i++) {\n                    let c = this.source[i];\n                    if (' \\t\\n\\r\\v'.indexOf(c) == -1)\n                        break;\n                }\n                if (i == this.tagPos)\n                    return \"\";\n                else\n                    return this.source.substr(i, this.tagPos - i).trim();\n            }\n            else\n                return this.source.substr(this.lastTagEnd, this.tagPos - this.lastTagEnd);\n        }\n        static getText(trim) {\n            if (this.lastTagEnd == this.tagPos)\n                return \"\";\n            else if (trim) {\n                let i = this.lastTagEnd;\n                for (; i < this.tagPos; i++) {\n                    let c = this.source[i];\n                    if (' \\t\\n\\r\\v'.indexOf(c) == -1)\n                        break;\n                }\n                if (i == this.tagPos)\n                    return \"\";\n                else\n                    return fgui.XMLUtils.decodeString(this.source.substr(i, this.tagPos - i)).trimRight();\n            }\n            else\n                return fgui.XMLUtils.decodeString(this.source.substr(this.lastTagEnd, this.tagPos - this.lastTagEnd));\n        }\n        static getAttribute(attrName) {\n            if (!this.attrParsed) {\n                for (var key in this.attributes) {\n                    delete this.attributes[key];\n                }\n                this.parseAttributes(this.attributes);\n                this.attrParsed = true;\n            }\n            return this.attributes[attrName];\n        }\n        static getAttributes(result) {\n            if (result == null)\n                result = {};\n            if (this.attrParsed) {\n                for (let k in this.attributes)\n                    result[k] = this.attributes[k];\n            }\n            else\n                this.parseAttributes(result);\n            return result;\n        }\n        static parseAttributes(attrs) {\n            let attrName;\n            let valueStart = 0;\n            let valueEnd = 0;\n            let waitValue = false;\n            let quoted = 0;\n            let buffer = \"\";\n            let i = this.tagPos;\n            let attrEnd = this.tagPos + this.tagLength;\n            if (i < attrEnd && this.source[i] == '<') {\n                for (; i < attrEnd; i++) {\n                    let c = this.source[i];\n                    if (' \\t\\n\\r\\v'.indexOf(c) != -1 || c == '>' || c == '/')\n                        break;\n                }\n            }\n            for (; i < attrEnd; i++) {\n                let c = this.source[i];\n                if (c == '=') {\n                    valueStart = -1;\n                    valueEnd = -1;\n                    quoted = 0;\n                    for (let j = i + 1; j < attrEnd; j++) {\n                        let c2 = this.source[j];\n                        if (' \\t\\n\\r\\v'.indexOf(c2) != -1) {\n                            if (valueStart != -1 && quoted == 0) {\n                                valueEnd = j - 1;\n                                break;\n                            }\n                        }\n                        else if (c2 == '>') {\n                            if (quoted == 0) {\n                                valueEnd = j - 1;\n                                break;\n                            }\n                        }\n                        else if (c2 == '\"') {\n                            if (valueStart != -1) {\n                                if (quoted != 1) {\n                                    valueEnd = j - 1;\n                                    break;\n                                }\n                            }\n                            else {\n                                quoted = 2;\n                                valueStart = j + 1;\n                            }\n                        }\n                        else if (c2 == '\\'') {\n                            if (valueStart != -1) {\n                                if (quoted != 2) {\n                                    valueEnd = j - 1;\n                                    break;\n                                }\n                            }\n                            else {\n                                quoted = 1;\n                                valueStart = j + 1;\n                            }\n                        }\n                        else if (valueStart == -1) {\n                            valueStart = j;\n                        }\n                    }\n                    if (valueStart != -1 && valueEnd != -1) {\n                        attrName = buffer;\n                        if (this.lowerCaseName)\n                            attrName = attrName.toLowerCase();\n                        buffer = \"\";\n                        attrs[attrName] = fgui.XMLUtils.decodeString(this.source.substr(valueStart, valueEnd - valueStart + 1));\n                        i = valueEnd + 1;\n                    }\n                    else\n                        break;\n                }\n                else if (' \\t\\n\\r\\v'.indexOf(c) == -1) {\n                    if (waitValue || c == '/' || c == '>') {\n                        if (buffer.length > 0) {\n                            attrName = buffer;\n                            if (this.lowerCaseName)\n                                attrName = attrName.toLowerCase();\n                            attrs[attrName] = \"\";\n                            buffer = \"\";\n                        }\n                        waitValue = false;\n                    }\n                    if (c != '/' && c != '>')\n                        buffer += c;\n                }\n                else {\n                    if (buffer.length > 0)\n                        waitValue = true;\n                }\n            }\n        }\n    }\n    XMLIterator.attributes = {};\n    fgui.XMLIterator = XMLIterator;\n})(fgui || (fgui = {}));\nvar fgui;\n(function (fgui) {\n    class XMLUtils {\n        static decodeString(aSource) {\n            let len = aSource.length;\n            let sb = \"\";\n            let pos1 = 0, pos2 = 0;\n            while (true) {\n                pos2 = aSource.indexOf('&', pos1);\n                if (pos2 == -1) {\n                    sb += aSource.substr(pos1);\n                    break;\n                }\n                sb += aSource.substr(pos1, pos2 - pos1);\n                pos1 = pos2 + 1;\n                pos2 = pos1;\n                let end = Math.min(len, pos2 + 10);\n                for (; pos2 < end; pos2++) {\n                    if (aSource[pos2] == ';')\n                        break;\n                }\n                if (pos2 < end && pos2 > pos1) {\n                    let entity = aSource.substr(pos1, pos2 - pos1);\n                    let u = 0;\n                    if (entity[0] == '#') {\n                        if (entity.length > 1) {\n                            if (entity[1] == 'x')\n                                u = parseInt(entity.substr(2), 16);\n                            else\n                                u = parseInt(entity.substr(1));\n                            sb += String.fromCharCode(u);\n                            pos1 = pos2 + 1;\n                        }\n                        else\n                            sb += '&';\n                    }\n                    else {\n                        switch (entity) {\n                            case \"amp\":\n                                u = 38;\n                                break;\n                            case \"apos\":\n                                u = 39;\n                                break;\n                            case \"gt\":\n                                u = 62;\n                                break;\n                            case \"lt\":\n                                u = 60;\n                                break;\n                            case \"nbsp\":\n                                u = 32;\n                                break;\n                            case \"quot\":\n                                u = 34;\n                                break;\n                        }\n                        if (u > 0) {\n                            sb += String.fromCharCode(u);\n                            pos1 = pos2 + 1;\n                        }\n                        else\n                            sb += '&';\n                    }\n                }\n                else {\n                    sb += '&';\n                }\n            }\n            return sb;\n        }\n        static encodeString(str) {\n            return str.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\")\n                .replace(/>/g, \"&gt;\").replace(/'/g, \"&apos;\").replace(/\"/g, \"&quot;\");\n        }\n        static getString(attrs, attrName, defValue) {\n            if (attrs == null)\n                return defValue == null ? null : defValue;\n            let ret = attrs[attrName];\n            if (ret != null)\n                return \"\" + ret;\n            else\n                return defValue == null ? null : defValue;\n        }\n        static getInt(attrs, attrName, defValue) {\n            let value = this.getString(attrs, attrName);\n            if (value == null || value.length == 0)\n                return defValue == null ? 0 : defValue;\n            if (value[value.length - 1] == '%') {\n                let ret = parseInt(value.substring(0, value.length - 1));\n                return Math.ceil(ret / 100.0 * defValue);\n            }\n            else\n                return parseInt(value);\n        }\n        static getFloat(attrs, attrName, defValue) {\n            let value = this.getString(attrs, attrName);\n            if (value == null || value.length == 0)\n                return defValue == null ? 0 : defValue;\n            let ret = parseFloat(value);\n            if (isNaN(ret))\n                return defValue == null ? 0 : defValue;\n            else\n                return ret;\n        }\n        static getBool(attrs, attrName, defValue) {\n            let value = this.getString(attrs, attrName);\n            if (value == null || value.length == 0)\n                return defValue == null ? false : defValue;\n            if (value == \"true\" || value == \"1\")\n                return true;\n            else if (value == \"false\" || value == \"0\")\n                return false;\n            else\n                return defValue == null ? false : defValue;\n        }\n        static getColor(attrs, attrName, defValue) {\n            let value = this.getString(attrs, attrName);\n            if (value == null || value.length == 0)\n                return defValue == null ? 0 : defValue;\n            return fgui.convertFromHtmlColor(value);\n        }\n    }\n    fgui.XMLUtils = XMLUtils;\n    const ESCAPES = [\n        \"&\", \"&amp;\",\n        \"<\", \"&lt;\",\n        \">\", \"&gt;\",\n        \"'\", \"&apos;\",\n        \"\\\"\", \"&quot;\"\n    ];\n})(fgui || (fgui = {}));\n"],"file":"dist/fairygui.js","sourceRoot":"/source/"}